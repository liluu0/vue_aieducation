{"ast":null,"code":"/*\n *      bit reservoir source file\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Reservoir.java,v 1.9 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n/**\n * ResvFrameBegin:<BR>\n * Called (repeatedly) at the beginning of a frame. Updates the maximum size of\n * the reservoir, and checks to make sure main_data_begin was set properly by\n * the formatter<BR>\n * Background information:\n * \n * This is the original text from the ISO standard. Because of sooo many bugs\n * and irritations correcting comments are added in brackets []. A '^W' means\n * you should remove the last word.\n * \n * <PRE>\n *  1. The following rule can be used to calculate the maximum\n *     number of bits used for one granule [^W frame]:<BR>\n *     At the highest possible bitrate of Layer III (320 kbps\n *     per stereo signal [^W^W^W], 48 kHz) the frames must be of\n *     [^W^W^W are designed to have] constant length, i.e.\n *     one buffer [^W^W the frame] length is:<BR>\n * \n *         320 kbps * 1152/48 kHz = 7680 bit = 960 byte\n * \n *     This value is used as the maximum buffer per channel [^W^W] at\n *     lower bitrates [than 320 kbps]. At 64 kbps mono or 128 kbps\n *     stereo the main granule length is 64 kbps * 576/48 kHz = 768 bit\n *     [per granule and channel] at 48 kHz sampling frequency.\n *     This means that there is a maximum deviation (short time buffer\n *     [= reservoir]) of 7680 - 2*2*768 = 4608 bits is allowed at 64 kbps.\n *     The actual deviation is equal to the number of bytes [with the\n *     meaning of octets] denoted by the main_data_end offset pointer.\n *     The actual maximum deviation is (2^9-1)*8 bit = 4088 bits\n *     [for MPEG-1 and (2^8-1)*8 bit for MPEG-2, both are hard limits].\n *     ... The xchange of buffer bits between the left and right channel\n *     is allowed without restrictions [exception: dual channel].\n *     Because of the [constructed] constraint on the buffer size\n *     main_data_end is always set to 0 in the case of bit_rate_index==14,\n *     i.e. data rate 320 kbps per stereo signal [^W^W^W]. In this case\n *     all data are allocated between adjacent header [^W sync] words\n *     [, i.e. there is no buffering at all].\n * </PRE>\n */\n\nvar common = require('./common.js');\nvar assert = common.assert;\nfunction Reservoir() {\n  var bs;\n  this.setModules = function (_bs) {\n    bs = _bs;\n  };\n  this.ResvFrameBegin = function (gfp, mean_bits) {\n    var gfc = gfp.internal_flags;\n    var maxmp3buf;\n    var l3_side = gfc.l3_side;\n    var frameLength = bs.getframebits(gfp);\n    mean_bits.bits = (frameLength - gfc.sideinfo_len * 8) / gfc.mode_gr;\n\n    /**\n     * <PRE>\n     *  Meaning of the variables:\n     *      resvLimit: (0, 8, ..., 8*255 (MPEG-2), 8*511 (MPEG-1))\n     *          Number of bits can be stored in previous frame(s) due to\n     *          counter size constaints\n     *      maxmp3buf: ( ??? ... 8*1951 (MPEG-1 and 2), 8*2047 (MPEG-2.5))\n     *          Number of bits allowed to encode one frame (you can take 8*511 bit\n     *          from the bit reservoir and at most 8*1440 bit from the current\n     *          frame (320 kbps, 32 kHz), so 8*1951 bit is the largest possible\n     *          value for MPEG-1 and -2)\n     * \n     *          maximum allowed granule/channel size times 4 = 8*2047 bits.,\n     *          so this is the absolute maximum supported by the format.\n     * \n     * \n     *      fullFrameBits:  maximum number of bits available for encoding\n     *                      the current frame.\n     * \n     *      mean_bits:      target number of bits per granule.\n     * \n     *      frameLength:\n     * \n     *      gfc.ResvMax:   maximum allowed reservoir\n     * \n     *      gfc.ResvSize:  current reservoir size\n     * \n     *      l3_side.resvDrain_pre:\n     *         ancillary data to be added to previous frame:\n     *         (only usefull in VBR modes if it is possible to have\n     *         maxmp3buf < fullFrameBits)).  Currently disabled,\n     *         see #define NEW_DRAIN\n     *         2010-02-13: RH now enabled, it seems to be needed for CBR too,\n     *                     as there exists one example, where the FhG decoder\n     *                     can't decode a -b320 CBR file anymore.\n     * \n     *      l3_side.resvDrain_post:\n     *         ancillary data to be added to this frame:\n     * \n     * </PRE>\n     */\n\n    /* main_data_begin has 9 bits in MPEG-1, 8 bits MPEG-2 */\n    var resvLimit = 8 * 256 * gfc.mode_gr - 8;\n\n    /*\n     * maximum allowed frame size. dont use more than this number of bits,\n     * even if the frame has the space for them:\n     */\n    if (gfp.brate > 320) {\n      /* in freeformat the buffer is constant */\n      maxmp3buf = 8 * int(gfp.brate * 1000 / (gfp.out_samplerate / 1152) / 8 + .5);\n    } else {\n      /*\n       * all mp3 decoders should have enough buffer to handle this value:\n       * size of a 320kbps 32kHz frame\n       */\n      maxmp3buf = 8 * 1440;\n\n      /*\n       * Bouvigne suggests this more lax interpretation of the ISO doc\n       * instead of using 8*960.\n       */\n\n      if (gfp.strict_ISO) {\n        maxmp3buf = 8 * int(320000 / (gfp.out_samplerate / 1152) / 8 + .5);\n      }\n    }\n    gfc.ResvMax = maxmp3buf - frameLength;\n    if (gfc.ResvMax > resvLimit) gfc.ResvMax = resvLimit;\n    if (gfc.ResvMax < 0 || gfp.disable_reservoir) gfc.ResvMax = 0;\n    var fullFrameBits = mean_bits.bits * gfc.mode_gr + Math.min(gfc.ResvSize, gfc.ResvMax);\n    if (fullFrameBits > maxmp3buf) fullFrameBits = maxmp3buf;\n    assert(0 == gfc.ResvMax % 8);\n    assert(gfc.ResvMax >= 0);\n    l3_side.resvDrain_pre = 0;\n\n    // frame analyzer code\n    if (gfc.pinfo != null) {\n      /*\n       * expected bits per channel per granule [is this also right for\n       * mono/stereo, MPEG-1/2 ?]\n       */\n      gfc.pinfo.mean_bits = mean_bits.bits / 2;\n      gfc.pinfo.resvsize = gfc.ResvSize;\n    }\n    return fullFrameBits;\n  };\n\n  /**\n   * returns targ_bits: target number of bits to use for 1 granule<BR>\n   * extra_bits: amount extra available from reservoir<BR>\n   * Mark Taylor 4/99\n   */\n  this.ResvMaxBits = function (gfp, mean_bits, targ_bits, cbr) {\n    var gfc = gfp.internal_flags;\n    var add_bits;\n    var ResvSize = gfc.ResvSize,\n      ResvMax = gfc.ResvMax;\n\n    /* compensate the saved bits used in the 1st granule */\n    if (cbr != 0) ResvSize += mean_bits;\n    if ((gfc.substep_shaping & 1) != 0) ResvMax *= 0.9;\n    targ_bits.bits = mean_bits;\n\n    /* extra bits if the reservoir is almost full */\n    if (ResvSize * 10 > ResvMax * 9) {\n      add_bits = ResvSize - ResvMax * 9 / 10;\n      targ_bits.bits += add_bits;\n      gfc.substep_shaping |= 0x80;\n    } else {\n      add_bits = 0;\n      gfc.substep_shaping &= 0x7f;\n      /*\n       * build up reservoir. this builds the reservoir a little slower\n       * than FhG. It could simple be mean_bits/15, but this was rigged to\n       * always produce 100 (the old value) at 128kbs\n       */\n      if (!gfp.disable_reservoir && 0 == (gfc.substep_shaping & 1)) targ_bits.bits -= .1 * mean_bits;\n    }\n\n    /* amount from the reservoir we are allowed to use. ISO says 6/10 */\n    var extra_bits = ResvSize < gfc.ResvMax * 6 / 10 ? ResvSize : gfc.ResvMax * 6 / 10;\n    extra_bits -= add_bits;\n    if (extra_bits < 0) extra_bits = 0;\n    return extra_bits;\n  };\n\n  /**\n   * Called after a granule's bit allocation. Readjusts the size of the\n   * reservoir to reflect the granule's usage.\n   */\n  this.ResvAdjust = function (gfc, gi) {\n    gfc.ResvSize -= gi.part2_3_length + gi.part2_length;\n  };\n\n  /**\n   * Called after all granules in a frame have been allocated. Makes sure that\n   * the reservoir size is within limits, possibly by adding stuffing bits.\n   */\n  this.ResvFrameEnd = function (gfc, mean_bits) {\n    var over_bits;\n    var l3_side = gfc.l3_side;\n    gfc.ResvSize += mean_bits * gfc.mode_gr;\n    var stuffingBits = 0;\n    l3_side.resvDrain_post = 0;\n    l3_side.resvDrain_pre = 0;\n\n    /* we must be byte aligned */\n    if ((over_bits = gfc.ResvSize % 8) != 0) stuffingBits += over_bits;\n    over_bits = gfc.ResvSize - stuffingBits - gfc.ResvMax;\n    if (over_bits > 0) {\n      assert(0 == over_bits % 8);\n      assert(over_bits >= 0);\n      stuffingBits += over_bits;\n    }\n\n    /*\n     * NOTE: enabling the NEW_DRAIN code fixes some problems with FhG\n     * decoder shipped with MS Windows operating systems. Using this, it is\n     * even possible to use Gabriel's lax buffer consideration again, which\n     * assumes, any decoder should have a buffer large enough for a 320 kbps\n     * frame at 32 kHz sample rate.\n     * \n     * old drain code: lame -b320 BlackBird.wav --. does not play with\n     * GraphEdit.exe using FhG decoder V1.5 Build 50\n     * \n     * new drain code: lame -b320 BlackBird.wav --. plays fine with\n     * GraphEdit.exe using FhG decoder V1.5 Build 50\n     * \n     * Robert Hegemann, 2010-02-13.\n     */\n    /*\n     * drain as many bits as possible into previous frame ancillary data In\n     * particular, in VBR mode ResvMax may have changed, and we have to make\n     * sure main_data_begin does not create a reservoir bigger than ResvMax\n     * mt 4/00\n     */\n    {\n      var mdb_bytes = Math.min(l3_side.main_data_begin * 8, stuffingBits) / 8;\n      l3_side.resvDrain_pre += 8 * mdb_bytes;\n      stuffingBits -= 8 * mdb_bytes;\n      gfc.ResvSize -= 8 * mdb_bytes;\n      l3_side.main_data_begin -= mdb_bytes;\n    }\n    /* drain the rest into this frames ancillary data */\n    l3_side.resvDrain_post += stuffingBits;\n    gfc.ResvSize -= stuffingBits;\n  };\n}\nmodule.exports = Reservoir;","map":{"version":3,"names":["common","require","assert","Reservoir","bs","setModules","_bs","ResvFrameBegin","gfp","mean_bits","gfc","internal_flags","maxmp3buf","l3_side","frameLength","getframebits","bits","sideinfo_len","mode_gr","resvLimit","brate","int","out_samplerate","strict_ISO","ResvMax","disable_reservoir","fullFrameBits","Math","min","ResvSize","resvDrain_pre","pinfo","resvsize","ResvMaxBits","targ_bits","cbr","add_bits","substep_shaping","extra_bits","ResvAdjust","gi","part2_3_length","part2_length","ResvFrameEnd","over_bits","stuffingBits","resvDrain_post","mdb_bytes","main_data_begin","module","exports"],"sources":["D:/代码/vscodeProjects/AiEducation/vue_aieducation/node_modules/lamejs/src/js/Reservoir.js"],"sourcesContent":["/*\n *      bit reservoir source file\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Reservoir.java,v 1.9 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n/**\n * ResvFrameBegin:<BR>\n * Called (repeatedly) at the beginning of a frame. Updates the maximum size of\n * the reservoir, and checks to make sure main_data_begin was set properly by\n * the formatter<BR>\n * Background information:\n * \n * This is the original text from the ISO standard. Because of sooo many bugs\n * and irritations correcting comments are added in brackets []. A '^W' means\n * you should remove the last word.\n * \n * <PRE>\n *  1. The following rule can be used to calculate the maximum\n *     number of bits used for one granule [^W frame]:<BR>\n *     At the highest possible bitrate of Layer III (320 kbps\n *     per stereo signal [^W^W^W], 48 kHz) the frames must be of\n *     [^W^W^W are designed to have] constant length, i.e.\n *     one buffer [^W^W the frame] length is:<BR>\n * \n *         320 kbps * 1152/48 kHz = 7680 bit = 960 byte\n * \n *     This value is used as the maximum buffer per channel [^W^W] at\n *     lower bitrates [than 320 kbps]. At 64 kbps mono or 128 kbps\n *     stereo the main granule length is 64 kbps * 576/48 kHz = 768 bit\n *     [per granule and channel] at 48 kHz sampling frequency.\n *     This means that there is a maximum deviation (short time buffer\n *     [= reservoir]) of 7680 - 2*2*768 = 4608 bits is allowed at 64 kbps.\n *     The actual deviation is equal to the number of bytes [with the\n *     meaning of octets] denoted by the main_data_end offset pointer.\n *     The actual maximum deviation is (2^9-1)*8 bit = 4088 bits\n *     [for MPEG-1 and (2^8-1)*8 bit for MPEG-2, both are hard limits].\n *     ... The xchange of buffer bits between the left and right channel\n *     is allowed without restrictions [exception: dual channel].\n *     Because of the [constructed] constraint on the buffer size\n *     main_data_end is always set to 0 in the case of bit_rate_index==14,\n *     i.e. data rate 320 kbps per stereo signal [^W^W^W]. In this case\n *     all data are allocated between adjacent header [^W sync] words\n *     [, i.e. there is no buffering at all].\n * </PRE>\n */\n\nvar common = require('./common.js');\nvar assert = common.assert;\n\nfunction Reservoir() {\n\tvar bs;\n\n\tthis.setModules  = function(_bs) {\n\t\tbs = _bs;\n\t}\n\n\tthis.ResvFrameBegin = function(gfp, mean_bits) {\n\t\tvar gfc = gfp.internal_flags;\n\t\tvar maxmp3buf;\n\t\tvar l3_side = gfc.l3_side;\n\n\t\tvar frameLength = bs.getframebits(gfp);\n\t\tmean_bits.bits = (frameLength - gfc.sideinfo_len * 8) / gfc.mode_gr;\n\n\t\t/**\n\t\t * <PRE>\n\t\t *  Meaning of the variables:\n\t\t *      resvLimit: (0, 8, ..., 8*255 (MPEG-2), 8*511 (MPEG-1))\n\t\t *          Number of bits can be stored in previous frame(s) due to\n\t\t *          counter size constaints\n\t\t *      maxmp3buf: ( ??? ... 8*1951 (MPEG-1 and 2), 8*2047 (MPEG-2.5))\n\t\t *          Number of bits allowed to encode one frame (you can take 8*511 bit\n\t\t *          from the bit reservoir and at most 8*1440 bit from the current\n\t\t *          frame (320 kbps, 32 kHz), so 8*1951 bit is the largest possible\n\t\t *          value for MPEG-1 and -2)\n\t\t * \n\t\t *          maximum allowed granule/channel size times 4 = 8*2047 bits.,\n\t\t *          so this is the absolute maximum supported by the format.\n\t\t * \n\t\t * \n\t\t *      fullFrameBits:  maximum number of bits available for encoding\n\t\t *                      the current frame.\n\t\t * \n\t\t *      mean_bits:      target number of bits per granule.\n\t\t * \n\t\t *      frameLength:\n\t\t * \n\t\t *      gfc.ResvMax:   maximum allowed reservoir\n\t\t * \n\t\t *      gfc.ResvSize:  current reservoir size\n\t\t * \n\t\t *      l3_side.resvDrain_pre:\n\t\t *         ancillary data to be added to previous frame:\n\t\t *         (only usefull in VBR modes if it is possible to have\n\t\t *         maxmp3buf < fullFrameBits)).  Currently disabled,\n\t\t *         see #define NEW_DRAIN\n\t\t *         2010-02-13: RH now enabled, it seems to be needed for CBR too,\n\t\t *                     as there exists one example, where the FhG decoder\n\t\t *                     can't decode a -b320 CBR file anymore.\n\t\t * \n\t\t *      l3_side.resvDrain_post:\n\t\t *         ancillary data to be added to this frame:\n\t\t * \n\t\t * </PRE>\n\t\t */\n\n\t\t/* main_data_begin has 9 bits in MPEG-1, 8 bits MPEG-2 */\n\t\tvar resvLimit = (8 * 256) * gfc.mode_gr - 8;\n\n\t\t/*\n\t\t * maximum allowed frame size. dont use more than this number of bits,\n\t\t * even if the frame has the space for them:\n\t\t */\n\t\tif (gfp.brate > 320) {\n\t\t\t/* in freeformat the buffer is constant */\n\t\t\tmaxmp3buf = 8 * ((int) ((gfp.brate * 1000)\n\t\t\t\t\t/ (gfp.out_samplerate / 1152) / 8 + .5));\n\t\t} else {\n\t\t\t/*\n\t\t\t * all mp3 decoders should have enough buffer to handle this value:\n\t\t\t * size of a 320kbps 32kHz frame\n\t\t\t */\n\t\t\tmaxmp3buf = 8 * 1440;\n\n\t\t\t/*\n\t\t\t * Bouvigne suggests this more lax interpretation of the ISO doc\n\t\t\t * instead of using 8*960.\n\t\t\t */\n\n\t\t\tif (gfp.strict_ISO) {\n\t\t\t\tmaxmp3buf = 8 * ((int) (320000 / (gfp.out_samplerate / 1152) / 8 + .5));\n\t\t\t}\n\t\t}\n\n\t\tgfc.ResvMax = maxmp3buf - frameLength;\n\t\tif (gfc.ResvMax > resvLimit)\n\t\t\tgfc.ResvMax = resvLimit;\n\t\tif (gfc.ResvMax < 0 || gfp.disable_reservoir)\n\t\t\tgfc.ResvMax = 0;\n\n\t\tvar fullFrameBits = mean_bits.bits * gfc.mode_gr\n\t\t\t\t+ Math.min(gfc.ResvSize, gfc.ResvMax);\n\n\t\tif (fullFrameBits > maxmp3buf)\n\t\t\tfullFrameBits = maxmp3buf;\n\n\t\tassert (0 == gfc.ResvMax % 8);\n\t\tassert (gfc.ResvMax >= 0);\n\n\t\tl3_side.resvDrain_pre = 0;\n\n\t\t// frame analyzer code\n\t\tif (gfc.pinfo != null) {\n\t\t\t/*\n\t\t\t * expected bits per channel per granule [is this also right for\n\t\t\t * mono/stereo, MPEG-1/2 ?]\n\t\t\t */\n\t\t\tgfc.pinfo.mean_bits = mean_bits.bits / 2;\n\t\t\tgfc.pinfo.resvsize = gfc.ResvSize;\n\t\t}\n\n\t\treturn fullFrameBits;\n\t}\n\n\t/**\n\t * returns targ_bits: target number of bits to use for 1 granule<BR>\n\t * extra_bits: amount extra available from reservoir<BR>\n\t * Mark Taylor 4/99\n\t */\n\tthis.ResvMaxBits = function(gfp, mean_bits, targ_bits, cbr) {\n\t\tvar gfc = gfp.internal_flags;\n\t\tvar add_bits;\n        var ResvSize = gfc.ResvSize, ResvMax = gfc.ResvMax;\n\n\t\t/* compensate the saved bits used in the 1st granule */\n\t\tif (cbr != 0)\n\t\t\tResvSize += mean_bits;\n\n\t\tif ((gfc.substep_shaping & 1) != 0)\n\t\t\tResvMax *= 0.9;\n\n\t\ttarg_bits.bits = mean_bits;\n\n\t\t/* extra bits if the reservoir is almost full */\n\t\tif (ResvSize * 10 > ResvMax * 9) {\n\t\t\tadd_bits = ResvSize - (ResvMax * 9) / 10;\n\t\t\ttarg_bits.bits += add_bits;\n\t\t\tgfc.substep_shaping |= 0x80;\n\t\t} else {\n\t\t\tadd_bits = 0;\n\t\t\tgfc.substep_shaping &= 0x7f;\n\t\t\t/*\n\t\t\t * build up reservoir. this builds the reservoir a little slower\n\t\t\t * than FhG. It could simple be mean_bits/15, but this was rigged to\n\t\t\t * always produce 100 (the old value) at 128kbs\n\t\t\t */\n\t\t\tif (!gfp.disable_reservoir && 0 == (gfc.substep_shaping & 1))\n\t\t\t\ttarg_bits.bits -= .1 * mean_bits;\n\t\t}\n\n\t\t/* amount from the reservoir we are allowed to use. ISO says 6/10 */\n\t\tvar extra_bits = (ResvSize < (gfc.ResvMax * 6) / 10 ? ResvSize\n\t\t\t\t: (gfc.ResvMax * 6) / 10);\n\t\textra_bits -= add_bits;\n\n\t\tif (extra_bits < 0)\n\t\t\textra_bits = 0;\n\t\treturn extra_bits;\n\t}\n\n\t/**\n\t * Called after a granule's bit allocation. Readjusts the size of the\n\t * reservoir to reflect the granule's usage.\n\t */\n\tthis.ResvAdjust = function(gfc, gi) {\n\t\tgfc.ResvSize -= gi.part2_3_length + gi.part2_length;\n\t}\n\n\t/**\n\t * Called after all granules in a frame have been allocated. Makes sure that\n\t * the reservoir size is within limits, possibly by adding stuffing bits.\n\t */\n\tthis.ResvFrameEnd = function(gfc, mean_bits) {\n\t\tvar over_bits;\n\t\tvar l3_side = gfc.l3_side;\n\n\t\tgfc.ResvSize += mean_bits * gfc.mode_gr;\n\t\tvar stuffingBits = 0;\n\t\tl3_side.resvDrain_post = 0;\n\t\tl3_side.resvDrain_pre = 0;\n\n\t\t/* we must be byte aligned */\n\t\tif ((over_bits = gfc.ResvSize % 8) != 0)\n\t\t\tstuffingBits += over_bits;\n\n\t\tover_bits = (gfc.ResvSize - stuffingBits) - gfc.ResvMax;\n\t\tif (over_bits > 0) {\n\t\t\tassert (0 == over_bits % 8);\n\t\t\tassert (over_bits >= 0);\n\t\t\tstuffingBits += over_bits;\n\t\t}\n\n\t\t/*\n\t\t * NOTE: enabling the NEW_DRAIN code fixes some problems with FhG\n\t\t * decoder shipped with MS Windows operating systems. Using this, it is\n\t\t * even possible to use Gabriel's lax buffer consideration again, which\n\t\t * assumes, any decoder should have a buffer large enough for a 320 kbps\n\t\t * frame at 32 kHz sample rate.\n\t\t * \n\t\t * old drain code: lame -b320 BlackBird.wav --. does not play with\n\t\t * GraphEdit.exe using FhG decoder V1.5 Build 50\n\t\t * \n\t\t * new drain code: lame -b320 BlackBird.wav --. plays fine with\n\t\t * GraphEdit.exe using FhG decoder V1.5 Build 50\n\t\t * \n\t\t * Robert Hegemann, 2010-02-13.\n\t\t */\n\t\t/*\n\t\t * drain as many bits as possible into previous frame ancillary data In\n\t\t * particular, in VBR mode ResvMax may have changed, and we have to make\n\t\t * sure main_data_begin does not create a reservoir bigger than ResvMax\n\t\t * mt 4/00\n\t\t */\n\t\t{\n\t\t\tvar mdb_bytes = Math.min(l3_side.main_data_begin * 8, stuffingBits) / 8;\n\t\t\tl3_side.resvDrain_pre += 8 * mdb_bytes;\n\t\t\tstuffingBits -= 8 * mdb_bytes;\n\t\t\tgfc.ResvSize -= 8 * mdb_bytes;\n\t\t\tl3_side.main_data_begin -= mdb_bytes;\n\t\t}\n\t\t/* drain the rest into this frames ancillary data */\n\t\tl3_side.resvDrain_post += stuffingBits;\n\t\tgfc.ResvSize -= stuffingBits;\n\t}\n}\n\nmodule.exports = Reservoir;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,aAAa,CAAC;AACnC,IAAIC,MAAM,GAAGF,MAAM,CAACE,MAAM;AAE1B,SAASC,SAASA,CAAA,EAAG;EACpB,IAAIC,EAAE;EAEN,IAAI,CAACC,UAAU,GAAI,UAASC,GAAG,EAAE;IAChCF,EAAE,GAAGE,GAAG;EACT,CAAC;EAED,IAAI,CAACC,cAAc,GAAG,UAASC,GAAG,EAAEC,SAAS,EAAE;IAC9C,IAAIC,GAAG,GAAGF,GAAG,CAACG,cAAc;IAC5B,IAAIC,SAAS;IACb,IAAIC,OAAO,GAAGH,GAAG,CAACG,OAAO;IAEzB,IAAIC,WAAW,GAAGV,EAAE,CAACW,YAAY,CAACP,GAAG,CAAC;IACtCC,SAAS,CAACO,IAAI,GAAG,CAACF,WAAW,GAAGJ,GAAG,CAACO,YAAY,GAAG,CAAC,IAAIP,GAAG,CAACQ,OAAO;;IAEnE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IAEE;IACA,IAAIC,SAAS,GAAI,CAAC,GAAG,GAAG,GAAIT,GAAG,CAACQ,OAAO,GAAG,CAAC;;IAE3C;AACF;AACA;AACA;IACE,IAAIV,GAAG,CAACY,KAAK,GAAG,GAAG,EAAE;MACpB;MACAR,SAAS,GAAG,CAAC,GAAKS,GAAG,CAAIb,G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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}