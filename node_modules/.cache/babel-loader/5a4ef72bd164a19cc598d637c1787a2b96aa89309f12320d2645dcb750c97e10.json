{"ast":null,"code":"/*\n * MP3 quantization\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *      Copyright (c) 1999-2003 Takehiro Tominaga\n *      Copyright (c) 2000-2007 Robert Hegemann\n *      Copyright (c) 2001-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Quantize.java,v 1.24 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n//import java.util.Arrays;\nvar common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\nvar VBRQuantize = require('./VBRQuantize.js');\nvar CalcNoiseResult = require('./CalcNoiseResult.js');\nvar CalcNoiseData = require('./CalcNoiseData.js');\nvar Encoder = require('./Encoder.js');\nvar GrInfo = require('./GrInfo.js');\nvar L3Side = require('./L3Side.js');\nfunction Quantize() {\n  var bs;\n  this.rv = null;\n  var rv;\n  this.qupvt = null;\n  var qupvt;\n  var vbr = new VBRQuantize();\n  var tk;\n  this.setModules = function (_bs, _rv, _qupvt, _tk) {\n    bs = _bs;\n    rv = _rv;\n    this.rv = _rv;\n    qupvt = _qupvt;\n    this.qupvt = _qupvt;\n    tk = _tk;\n    vbr.setModules(qupvt, tk);\n  };\n\n  /**\n   * convert from L/R <. Mid/Side\n   */\n  this.ms_convert = function (l3_side, gr) {\n    for (var i = 0; i < 576; ++i) {\n      var l = l3_side.tt[gr][0].xr[i];\n      var r = l3_side.tt[gr][1].xr[i];\n      l3_side.tt[gr][0].xr[i] = (l + r) * (Util.SQRT2 * 0.5);\n      l3_side.tt[gr][1].xr[i] = (l - r) * (Util.SQRT2 * 0.5);\n    }\n  };\n\n  /**\n   * mt 6/99\n   *\n   * initializes cod_info, scalefac and xrpow\n   *\n   * returns 0 if all energies in xr are zero, else 1\n   */\n  function init_xrpow_core(cod_info, xrpow, upper, sum) {\n    sum = 0;\n    for (var i = 0; i <= upper; ++i) {\n      var tmp = Math.abs(cod_info.xr[i]);\n      sum += tmp;\n      xrpow[i] = Math.sqrt(tmp * Math.sqrt(tmp));\n      if (xrpow[i] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[i];\n    }\n    return sum;\n  }\n  this.init_xrpow = function (gfc, cod_info, xrpow) {\n    var sum = 0;\n    var upper = 0 | cod_info.max_nonzero_coeff;\n    assert(xrpow != null);\n    cod_info.xrpow_max = 0;\n\n    /*\n     * check if there is some energy we have to quantize and calculate xrpow\n     * matching our fresh scalefactors\n     */\n    assert(0 <= upper && upper <= 575);\n    Arrays.fill(xrpow, upper, 576, 0);\n    sum = init_xrpow_core(cod_info, xrpow, upper, sum);\n\n    /*\n     * return 1 if we have something to quantize, else 0\n     */\n    if (sum > 1E-20) {\n      var j = 0;\n      if ((gfc.substep_shaping & 2) != 0) j = 1;\n      for (var i = 0; i < cod_info.psymax; i++) gfc.pseudohalf[i] = j;\n      return true;\n    }\n    Arrays.fill(cod_info.l3_enc, 0, 576, 0);\n    return false;\n  };\n\n  /**\n   * Gabriel Bouvigne feb/apr 2003<BR>\n   * Analog silence detection in partitionned sfb21 or sfb12 for short blocks\n   *\n   * From top to bottom of sfb, changes to 0 coeffs which are below ath. It\n   * stops on the first coeff higher than ath.\n   */\n  function psfb21_analogsilence(gfc, cod_info) {\n    var ath = gfc.ATH;\n    var xr = cod_info.xr;\n    if (cod_info.block_type != Encoder.SHORT_TYPE) {\n      /* NORM, START or STOP type, but not SHORT blocks */\n      var stop = false;\n      for (var gsfb = Encoder.PSFB21 - 1; gsfb >= 0 && !stop; gsfb--) {\n        var start = gfc.scalefac_band.psfb21[gsfb];\n        var end = gfc.scalefac_band.psfb21[gsfb + 1];\n        var ath21 = qupvt.athAdjust(ath.adjust, ath.psfb21[gsfb], ath.floor);\n        if (gfc.nsPsy.longfact[21] > 1e-12) ath21 *= gfc.nsPsy.longfact[21];\n        for (var j = end - 1; j >= start; j--) {\n          if (Math.abs(xr[j]) < ath21) xr[j] = 0;else {\n            stop = true;\n            break;\n          }\n        }\n      }\n    } else {\n      /* note: short blocks coeffs are reordered */\n      for (var block = 0; block < 3; block++) {\n        var stop = false;\n        for (var gsfb = Encoder.PSFB12 - 1; gsfb >= 0 && !stop; gsfb--) {\n          var start = gfc.scalefac_band.s[12] * 3 + (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12]) * block + (gfc.scalefac_band.psfb12[gsfb] - gfc.scalefac_band.psfb12[0]);\n          var end = start + (gfc.scalefac_band.psfb12[gsfb + 1] - gfc.scalefac_band.psfb12[gsfb]);\n          var ath12 = qupvt.athAdjust(ath.adjust, ath.psfb12[gsfb], ath.floor);\n          if (gfc.nsPsy.shortfact[12] > 1e-12) ath12 *= gfc.nsPsy.shortfact[12];\n          for (var j = end - 1; j >= start; j--) {\n            if (Math.abs(xr[j]) < ath12) xr[j] = 0;else {\n              stop = true;\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n  this.init_outer_loop = function (gfc, cod_info) {\n    /*\n     * initialize fresh cod_info\n     */\n    cod_info.part2_3_length = 0;\n    cod_info.big_values = 0;\n    cod_info.count1 = 0;\n    cod_info.global_gain = 210;\n    cod_info.scalefac_compress = 0;\n    /* mixed_block_flag, block_type was set in psymodel.c */\n    cod_info.table_select[0] = 0;\n    cod_info.table_select[1] = 0;\n    cod_info.table_select[2] = 0;\n    cod_info.subblock_gain[0] = 0;\n    cod_info.subblock_gain[1] = 0;\n    cod_info.subblock_gain[2] = 0;\n    cod_info.subblock_gain[3] = 0;\n    /* this one is always 0 */\n    cod_info.region0_count = 0;\n    cod_info.region1_count = 0;\n    cod_info.preflag = 0;\n    cod_info.scalefac_scale = 0;\n    cod_info.count1table_select = 0;\n    cod_info.part2_length = 0;\n    cod_info.sfb_lmax = Encoder.SBPSY_l;\n    cod_info.sfb_smin = Encoder.SBPSY_s;\n    cod_info.psy_lmax = gfc.sfb21_extra ? Encoder.SBMAX_l : Encoder.SBPSY_l;\n    cod_info.psymax = cod_info.psy_lmax;\n    cod_info.sfbmax = cod_info.sfb_lmax;\n    cod_info.sfbdivide = 11;\n    for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n      cod_info.width[sfb] = gfc.scalefac_band.l[sfb + 1] - gfc.scalefac_band.l[sfb];\n      /* which is always 0. */\n      cod_info.window[sfb] = 3;\n    }\n    if (cod_info.block_type == Encoder.SHORT_TYPE) {\n      var ixwork = new_float(576);\n      cod_info.sfb_smin = 0;\n      cod_info.sfb_lmax = 0;\n      if (cod_info.mixed_block_flag != 0) {\n        /*\n         * MPEG-1: sfbs 0-7 long block, 3-12 short blocks MPEG-2(.5):\n         * sfbs 0-5 long block, 3-12 short blocks\n         */\n        cod_info.sfb_smin = 3;\n        cod_info.sfb_lmax = gfc.mode_gr * 2 + 4;\n      }\n      cod_info.psymax = cod_info.sfb_lmax + 3 * ((gfc.sfb21_extra ? Encoder.SBMAX_s : Encoder.SBPSY_s) - cod_info.sfb_smin);\n      cod_info.sfbmax = cod_info.sfb_lmax + 3 * (Encoder.SBPSY_s - cod_info.sfb_smin);\n      cod_info.sfbdivide = cod_info.sfbmax - 18;\n      cod_info.psy_lmax = cod_info.sfb_lmax;\n      /* re-order the short blocks, for more efficient encoding below */\n      /* By Takehiro TOMINAGA */\n      /*\n       * Within each scalefactor band, data is given for successive time\n       * windows, beginning with window 0 and ending with window 2. Within\n       * each window, the quantized values are then arranged in order of\n       * increasing frequency...\n       */\n      var ix = gfc.scalefac_band.l[cod_info.sfb_lmax];\n      System.arraycopy(cod_info.xr, 0, ixwork, 0, 576);\n      for (var sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n        var start = gfc.scalefac_band.s[sfb];\n        var end = gfc.scalefac_band.s[sfb + 1];\n        for (var window = 0; window < 3; window++) {\n          for (var l = start; l < end; l++) {\n            cod_info.xr[ix++] = ixwork[3 * l + window];\n          }\n        }\n      }\n      var j = cod_info.sfb_lmax;\n      for (var sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n        cod_info.width[j] = cod_info.width[j + 1] = cod_info.width[j + 2] = gfc.scalefac_band.s[sfb + 1] - gfc.scalefac_band.s[sfb];\n        cod_info.window[j] = 0;\n        cod_info.window[j + 1] = 1;\n        cod_info.window[j + 2] = 2;\n        j += 3;\n      }\n    }\n    cod_info.count1bits = 0;\n    cod_info.sfb_partition_table = qupvt.nr_of_sfb_block[0][0];\n    cod_info.slen[0] = 0;\n    cod_info.slen[1] = 0;\n    cod_info.slen[2] = 0;\n    cod_info.slen[3] = 0;\n    cod_info.max_nonzero_coeff = 575;\n\n    /*\n     * fresh scalefactors are all zero\n     */\n    Arrays.fill(cod_info.scalefac, 0);\n    psfb21_analogsilence(gfc, cod_info);\n  };\n  function BinSearchDirection(ordinal) {\n    this.ordinal = ordinal;\n  }\n  BinSearchDirection.BINSEARCH_NONE = new BinSearchDirection(0);\n  BinSearchDirection.BINSEARCH_UP = new BinSearchDirection(1);\n  BinSearchDirection.BINSEARCH_DOWN = new BinSearchDirection(2);\n\n  /**\n   * author/date??\n   *\n   * binary step size search used by outer_loop to get a quantizer step size\n   * to start with\n   */\n  function bin_search_StepSize(gfc, cod_info, desired_rate, ch, xrpow) {\n    var nBits;\n    var CurrentStep = gfc.CurrentStep[ch];\n    var flagGoneOver = false;\n    var start = gfc.OldValue[ch];\n    var Direction = BinSearchDirection.BINSEARCH_NONE;\n    cod_info.global_gain = start;\n    desired_rate -= cod_info.part2_length;\n    assert(CurrentStep != 0);\n    for (;;) {\n      var step;\n      nBits = tk.count_bits(gfc, xrpow, cod_info, null);\n      if (CurrentStep == 1 || nBits == desired_rate) break;\n      /* nothing to adjust anymore */\n\n      if (nBits > desired_rate) {\n        /* increase Quantize_StepSize */\n        if (Direction == BinSearchDirection.BINSEARCH_DOWN) flagGoneOver = true;\n        if (flagGoneOver) CurrentStep /= 2;\n        Direction = BinSearchDirection.BINSEARCH_UP;\n        step = CurrentStep;\n      } else {\n        /* decrease Quantize_StepSize */\n        if (Direction == BinSearchDirection.BINSEARCH_UP) flagGoneOver = true;\n        if (flagGoneOver) CurrentStep /= 2;\n        Direction = BinSearchDirection.BINSEARCH_DOWN;\n        step = -CurrentStep;\n      }\n      cod_info.global_gain += step;\n      if (cod_info.global_gain < 0) {\n        cod_info.global_gain = 0;\n        flagGoneOver = true;\n      }\n      if (cod_info.global_gain > 255) {\n        cod_info.global_gain = 255;\n        flagGoneOver = true;\n      }\n    }\n    assert(cod_info.global_gain >= 0);\n    assert(cod_info.global_gain < 256);\n    while (nBits > desired_rate && cod_info.global_gain < 255) {\n      cod_info.global_gain++;\n      nBits = tk.count_bits(gfc, xrpow, cod_info, null);\n    }\n    gfc.CurrentStep[ch] = start - cod_info.global_gain >= 4 ? 4 : 2;\n    gfc.OldValue[ch] = cod_info.global_gain;\n    cod_info.part2_3_length = nBits;\n    return nBits;\n  }\n  this.trancate_smallspectrums = function (gfc, gi, l3_xmin, work) {\n    var distort = new_float(L3Side.SFBMAX);\n    if (0 == (gfc.substep_shaping & 4) && gi.block_type == Encoder.SHORT_TYPE || (gfc.substep_shaping & 0x80) != 0) return;\n    qupvt.calc_noise(gi, l3_xmin, distort, new CalcNoiseResult(), null);\n    for (var j = 0; j < 576; j++) {\n      var xr = 0.0;\n      if (gi.l3_enc[j] != 0) xr = Math.abs(gi.xr[j]);\n      work[j] = xr;\n    }\n    var j = 0;\n    var sfb = 8;\n    if (gi.block_type == Encoder.SHORT_TYPE) sfb = 6;\n    do {\n      var allowedNoise, trancateThreshold;\n      var nsame, start;\n      var width = gi.width[sfb];\n      j += width;\n      if (distort[sfb] >= 1.0) continue;\n      Arrays.sort(work, j - width, width);\n      if (BitStream.EQ(work[j - 1], 0.0)) continue;\n      /* all zero sfb */\n\n      allowedNoise = (1.0 - distort[sfb]) * l3_xmin[sfb];\n      trancateThreshold = 0.0;\n      start = 0;\n      do {\n        var noise;\n        for (nsame = 1; start + nsame < width; nsame++) if (BitStream.NEQ(work[start + j - width], work[start + j + nsame - width])) break;\n        noise = work[start + j - width] * work[start + j - width] * nsame;\n        if (allowedNoise < noise) {\n          if (start != 0) trancateThreshold = work[start + j - width - 1];\n          break;\n        }\n        allowedNoise -= noise;\n        start += nsame;\n      } while (start < width);\n      if (BitStream.EQ(trancateThreshold, 0.0)) continue;\n      do {\n        if (Math.abs(gi.xr[j - width]) <= trancateThreshold) gi.l3_enc[j - width] = 0;\n      } while (--width > 0);\n    } while (++sfb < gi.psymax);\n    gi.part2_3_length = tk.noquant_count_bits(gfc, gi, null);\n  };\n\n  /**\n   * author/date??\n   *\n   * Function: Returns zero if there is a scalefac which has not been\n   * amplified. Otherwise it returns one.\n   */\n  function loop_break(cod_info) {\n    for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) if (cod_info.scalefac[sfb] + cod_info.subblock_gain[cod_info.window[sfb]] == 0) return false;\n    return true;\n  }\n\n  /* mt 5/99: Function: Improved calc_noise for a single channel */\n\n  function penalties(noise) {\n    return Util.FAST_LOG10(0.368 + 0.632 * noise * noise * noise);\n  }\n\n  /**\n   * author/date??\n   *\n   * several different codes to decide which quantization is better\n   */\n  function get_klemm_noise(distort, gi) {\n    var klemm_noise = 1E-37;\n    for (var sfb = 0; sfb < gi.psymax; sfb++) klemm_noise += penalties(distort[sfb]);\n    return Math.max(1e-20, klemm_noise);\n  }\n  function quant_compare(quant_comp, best, calc, gi, distort) {\n    /**\n     * noise is given in decibels (dB) relative to masking thesholds.<BR>\n     *\n     * over_noise: ??? (the previous comment is fully wrong)<BR>\n     * tot_noise: ??? (the previous comment is fully wrong)<BR>\n     * max_noise: max quantization noise\n     */\n    var better;\n    switch (quant_comp) {\n      default:\n      case 9:\n        {\n          if (best.over_count > 0) {\n            /* there are distorted sfb */\n            better = calc.over_SSD <= best.over_SSD;\n            if (calc.over_SSD == best.over_SSD) better = calc.bits < best.bits;\n          } else {\n            /* no distorted sfb */\n            better = calc.max_noise < 0 && calc.max_noise * 10 + calc.bits <= best.max_noise * 10 + best.bits;\n          }\n          break;\n        }\n      case 0:\n        better = calc.over_count < best.over_count || calc.over_count == best.over_count && calc.over_noise < best.over_noise || calc.over_count == best.over_count && BitStream.EQ(calc.over_noise, best.over_noise) && calc.tot_noise < best.tot_noise;\n        break;\n      case 8:\n        calc.max_noise = get_klemm_noise(distort, gi);\n      //$FALL-THROUGH$\n      case 1:\n        better = calc.max_noise < best.max_noise;\n        break;\n      case 2:\n        better = calc.tot_noise < best.tot_noise;\n        break;\n      case 3:\n        better = calc.tot_noise < best.tot_noise && calc.max_noise < best.max_noise;\n        break;\n      case 4:\n        better = calc.max_noise <= 0.0 && best.max_noise > 0.2 || calc.max_noise <= 0.0 && best.max_noise < 0.0 && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise || calc.max_noise <= 0.0 && best.max_noise > 0.0 && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise + best.over_noise || calc.max_noise > 0.0 && best.max_noise > -0.05 && best.max_noise > calc.max_noise - 0.1 && calc.tot_noise + calc.over_noise < best.tot_noise + best.over_noise || calc.max_noise > 0.0 && best.max_noise > -0.1 && best.max_noise > calc.max_noise - 0.15 && calc.tot_noise + calc.over_noise + calc.over_noise < best.tot_noise + best.over_noise + best.over_noise;\n        break;\n      case 5:\n        better = calc.over_noise < best.over_noise || BitStream.EQ(calc.over_noise, best.over_noise) && calc.tot_noise < best.tot_noise;\n        break;\n      case 6:\n        better = calc.over_noise < best.over_noise || BitStream.EQ(calc.over_noise, best.over_noise) && (calc.max_noise < best.max_noise || BitStream.EQ(calc.max_noise, best.max_noise) && calc.tot_noise <= best.tot_noise);\n        break;\n      case 7:\n        better = calc.over_count < best.over_count || calc.over_noise < best.over_noise;\n        break;\n    }\n    if (best.over_count == 0) {\n      /*\n       * If no distorted bands, only use this quantization if it is\n       * better, and if it uses less bits. Unfortunately, part2_3_length\n       * is sometimes a poor estimator of the final size at low bitrates.\n       */\n      better = better && calc.bits < best.bits;\n    }\n    return better;\n  }\n\n  /**\n   * author/date??\n   *\n   * <PRE>\n   *  Amplify the scalefactor bands that violate the masking threshold.\n   *  See ISO 11172-3 Section C.1.5.4.3.5\n   *\n   *  distort[] = noise/masking\n   *  distort[] > 1   ==> noise is not masked\n   *  distort[] < 1   ==> noise is masked\n   *  max_dist = maximum value of distort[]\n   *\n   *  Three algorithms:\n   *  noise_shaping_amp\n   *        0             Amplify all bands with distort[]>1.\n   *\n   *        1             Amplify all bands with distort[] >= max_dist^(.5);\n   *                     ( 50% in the db scale)\n   *\n   *        2             Amplify first band with distort[] >= max_dist;\n   *\n   *\n   *  For algorithms 0 and 1, if max_dist < 1, then amplify all bands\n   *  with distort[] >= .95*max_dist.  This is to make sure we always\n   *  amplify at least one band.\n   * </PRE>\n   */\n  function amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine) {\n    var gfc = gfp.internal_flags;\n    var ifqstep34;\n    if (cod_info.scalefac_scale == 0) {\n      ifqstep34 = 1.29683955465100964055;\n      /* 2**(.75*.5) */\n    } else {\n      ifqstep34 = 1.68179283050742922612;\n      /* 2**(.75*1) */\n    }\n\n    /* compute maximum value of distort[] */\n    var trigger = 0;\n    for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n      if (trigger < distort[sfb]) trigger = distort[sfb];\n    }\n    var noise_shaping_amp = gfc.noise_shaping_amp;\n    if (noise_shaping_amp == 3) {\n      if (bRefine) noise_shaping_amp = 2;else noise_shaping_amp = 1;\n    }\n    switch (noise_shaping_amp) {\n      case 2:\n        /* amplify exactly 1 band */\n        break;\n      case 1:\n        /* amplify bands within 50% of max (on db scale) */\n        if (trigger > 1.0) trigger = Math.pow(trigger, .5);else trigger *= .95;\n        break;\n      case 0:\n      default:\n        /* ISO algorithm. amplify all bands with distort>1 */\n        if (trigger > 1.0) trigger = 1.0;else trigger *= .95;\n        break;\n    }\n    var j = 0;\n    for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n      var width = cod_info.width[sfb];\n      var l;\n      j += width;\n      if (distort[sfb] < trigger) continue;\n      if ((gfc.substep_shaping & 2) != 0) {\n        gfc.pseudohalf[sfb] = 0 == gfc.pseudohalf[sfb] ? 1 : 0;\n        if (0 == gfc.pseudohalf[sfb] && gfc.noise_shaping_amp == 2) return;\n      }\n      cod_info.scalefac[sfb]++;\n      for (l = -width; l < 0; l++) {\n        xrpow[j + l] *= ifqstep34;\n        if (xrpow[j + l] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[j + l];\n      }\n      if (gfc.noise_shaping_amp == 2) return;\n    }\n  }\n\n  /**\n   * Takehiro Tominaga 2000-xx-xx\n   *\n   * turns on scalefac scale and adjusts scalefactors\n   */\n  function inc_scalefac_scale(cod_info, xrpow) {\n    var ifqstep34 = 1.29683955465100964055;\n    var j = 0;\n    for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n      var width = cod_info.width[sfb];\n      var s = cod_info.scalefac[sfb];\n      if (cod_info.preflag != 0) s += qupvt.pretab[sfb];\n      j += width;\n      if ((s & 1) != 0) {\n        s++;\n        for (var l = -width; l < 0; l++) {\n          xrpow[j + l] *= ifqstep34;\n          if (xrpow[j + l] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[j + l];\n        }\n      }\n      cod_info.scalefac[sfb] = s >> 1;\n    }\n    cod_info.preflag = 0;\n    cod_info.scalefac_scale = 1;\n  }\n\n  /**\n   * Takehiro Tominaga 2000-xx-xx\n   *\n   * increases the subblock gain and adjusts scalefactors\n   */\n  function inc_subblock_gain(gfc, cod_info, xrpow) {\n    var sfb;\n    var scalefac = cod_info.scalefac;\n\n    /* subbloc_gain can't do anything in the long block region */\n    for (sfb = 0; sfb < cod_info.sfb_lmax; sfb++) {\n      if (scalefac[sfb] >= 16) return true;\n    }\n    for (var window = 0; window < 3; window++) {\n      var s1 = 0;\n      var s2 = 0;\n      for (sfb = cod_info.sfb_lmax + window; sfb < cod_info.sfbdivide; sfb += 3) {\n        if (s1 < scalefac[sfb]) s1 = scalefac[sfb];\n      }\n      for (; sfb < cod_info.sfbmax; sfb += 3) {\n        if (s2 < scalefac[sfb]) s2 = scalefac[sfb];\n      }\n      if (s1 < 16 && s2 < 8) continue;\n      if (cod_info.subblock_gain[window] >= 7) return true;\n\n      /*\n       * even though there is no scalefactor for sfb12 subblock gain\n       * affects upper frequencies too, that's why we have to go up to\n       * SBMAX_s\n       */\n      cod_info.subblock_gain[window]++;\n      var j = gfc.scalefac_band.l[cod_info.sfb_lmax];\n      for (sfb = cod_info.sfb_lmax + window; sfb < cod_info.sfbmax; sfb += 3) {\n        var amp;\n        var width = cod_info.width[sfb];\n        var s = scalefac[sfb];\n        assert(s >= 0);\n        s = s - (4 >> cod_info.scalefac_scale);\n        if (s >= 0) {\n          scalefac[sfb] = s;\n          j += width * 3;\n          continue;\n        }\n        scalefac[sfb] = 0;\n        {\n          var gain = 210 + (s << cod_info.scalefac_scale + 1);\n          amp = qupvt.IPOW20(gain);\n        }\n        j += width * (window + 1);\n        for (var l = -width; l < 0; l++) {\n          xrpow[j + l] *= amp;\n          if (xrpow[j + l] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[j + l];\n        }\n        j += width * (3 - window - 1);\n      }\n      {\n        var amp = qupvt.IPOW20(202);\n        j += cod_info.width[sfb] * (window + 1);\n        for (var l = -cod_info.width[sfb]; l < 0; l++) {\n          xrpow[j + l] *= amp;\n          if (xrpow[j + l] > cod_info.xrpow_max) cod_info.xrpow_max = xrpow[j + l];\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * <PRE>\n   *  Takehiro Tominaga /date??\n   *  Robert Hegemann 2000-09-06: made a function of it\n   *\n   *  amplifies scalefactor bands,\n   *   - if all are already amplified returns 0\n   *   - if some bands are amplified too much:\n   *      * try to increase scalefac_scale\n   *      * if already scalefac_scale was set\n   *          try on short blocks to increase subblock gain\n   * </PRE>\n   */\n  function balance_noise(gfp, cod_info, distort, xrpow, bRefine) {\n    var gfc = gfp.internal_flags;\n    amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine);\n\n    /*\n     * check to make sure we have not amplified too much loop_break returns\n     * 0 if there is an unamplified scalefac scale_bitcount returns 0 if no\n     * scalefactors are too large\n     */\n\n    var status = loop_break(cod_info);\n    if (status) return false;\n    /* all bands amplified */\n\n    /*\n     * not all scalefactors have been amplified. so these scalefacs are\n     * possibly valid. encode them:\n     */\n    if (gfc.mode_gr == 2) status = tk.scale_bitcount(cod_info);else status = tk.scale_bitcount_lsf(gfc, cod_info);\n    if (!status) return true;\n    /* amplified some bands not exceeding limits */\n\n    /*\n     * some scalefactors are too large. lets try setting scalefac_scale=1\n     */\n    if (gfc.noise_shaping > 1) {\n      Arrays.fill(gfc.pseudohalf, 0);\n      if (0 == cod_info.scalefac_scale) {\n        inc_scalefac_scale(cod_info, xrpow);\n        status = false;\n      } else {\n        if (cod_info.block_type == Encoder.SHORT_TYPE && gfc.subblock_gain > 0) {\n          status = inc_subblock_gain(gfc, cod_info, xrpow) || loop_break(cod_info);\n        }\n      }\n    }\n    if (!status) {\n      if (gfc.mode_gr == 2) status = tk.scale_bitcount(cod_info);else status = tk.scale_bitcount_lsf(gfc, cod_info);\n    }\n    return !status;\n  }\n\n  /**\n   * <PRE>\n   *  Function: The outer iteration loop controls the masking conditions\n   *  of all scalefactorbands. It computes the best scalefac and\n   *  global gain. This module calls the inner iteration loop\n   *\n   *  mt 5/99 completely rewritten to allow for bit reservoir control,\n   *  mid/side channels with L/R or mid/side masking thresholds,\n   *  and chooses best quantization instead of last quantization when\n   *  no distortion free quantization can be found.\n   *\n   *  added VBR support mt 5/99\n   *\n   *  some code shuffle rh 9/00\n   * </PRE>\n   *\n   * @param l3_xmin\n   *            allowed distortion\n   * @param xrpow\n   *            coloured magnitudes of spectral\n   * @param targ_bits\n   *            maximum allowed bits\n   */\n  this.outer_loop = function (gfp, cod_info, l3_xmin, xrpow, ch, targ_bits) {\n    var gfc = gfp.internal_flags;\n    var cod_info_w = new GrInfo();\n    var save_xrpow = new_float(576);\n    var distort = new_float(L3Side.SFBMAX);\n    var best_noise_info = new CalcNoiseResult();\n    var better;\n    var prev_noise = new CalcNoiseData();\n    var best_part2_3_length = 9999999;\n    var bEndOfSearch = false;\n    var bRefine = false;\n    var best_ggain_pass1 = 0;\n    bin_search_StepSize(gfc, cod_info, targ_bits, ch, xrpow);\n    if (0 == gfc.noise_shaping) /* fast mode, no noise shaping, we are ready */\n      return 100;\n    /* default noise_info.over_count */\n\n    /* compute the distortion in this quantization */\n    /* coefficients and thresholds both l/r (or both mid/side) */\n    qupvt.calc_noise(cod_info, l3_xmin, distort, best_noise_info, prev_noise);\n    best_noise_info.bits = cod_info.part2_3_length;\n    cod_info_w.assign(cod_info);\n    var age = 0;\n    System.arraycopy(xrpow, 0, save_xrpow, 0, 576);\n    while (!bEndOfSearch) {\n      /* BEGIN MAIN LOOP */\n      do {\n        var noise_info = new CalcNoiseResult();\n        var search_limit;\n        var maxggain = 255;\n\n        /*\n         * When quantization with no distorted bands is found, allow up\n         * to X new unsuccesful tries in serial. This gives us more\n         * possibilities for different quant_compare modes. Much more\n         * than 3 makes not a big difference, it is only slower.\n         */\n\n        if ((gfc.substep_shaping & 2) != 0) {\n          search_limit = 20;\n        } else {\n          search_limit = 3;\n        }\n\n        /*\n         * Check if the last scalefactor band is distorted. in VBR mode\n         * we can't get rid of the distortion, so quit now and VBR mode\n         * will try again with more bits. (makes a 10% speed increase,\n         * the files I tested were binary identical, 2000/05/20 Robert\n         * Hegemann) distort[] > 1 means noise > allowed noise\n         */\n        if (gfc.sfb21_extra) {\n          if (distort[cod_info_w.sfbmax] > 1.0) break;\n          if (cod_info_w.block_type == Encoder.SHORT_TYPE && (distort[cod_info_w.sfbmax + 1] > 1.0 || distort[cod_info_w.sfbmax + 2] > 1.0)) break;\n        }\n\n        /* try a new scalefactor conbination on cod_info_w */\n        if (!balance_noise(gfp, cod_info_w, distort, xrpow, bRefine)) break;\n        if (cod_info_w.scalefac_scale != 0) maxggain = 254;\n\n        /*\n         * inner_loop starts with the initial quantization step computed\n         * above and slowly increases until the bits < huff_bits. Thus\n         * it is important not to start with too large of an inital\n         * quantization step. Too small is ok, but inner_loop will take\n         * longer\n         */\n        var huff_bits = targ_bits - cod_info_w.part2_length;\n        if (huff_bits <= 0) break;\n\n        /*\n         * increase quantizer stepsize until needed bits are below\n         * maximum\n         */\n        while ((cod_info_w.part2_3_length = tk.count_bits(gfc, xrpow, cod_info_w, prev_noise)) > huff_bits && cod_info_w.global_gain <= maxggain) cod_info_w.global_gain++;\n        if (cod_info_w.global_gain > maxggain) break;\n        if (best_noise_info.over_count == 0) {\n          while ((cod_info_w.part2_3_length = tk.count_bits(gfc, xrpow, cod_info_w, prev_noise)) > best_part2_3_length && cod_info_w.global_gain <= maxggain) cod_info_w.global_gain++;\n          if (cod_info_w.global_gain > maxggain) break;\n        }\n\n        /* compute the distortion in this quantization */\n        qupvt.calc_noise(cod_info_w, l3_xmin, distort, noise_info, prev_noise);\n        noise_info.bits = cod_info_w.part2_3_length;\n\n        /*\n         * check if this quantization is better than our saved\n         * quantization\n         */\n        if (cod_info.block_type != Encoder.SHORT_TYPE) {\n          // NORM, START or STOP type\n          better = gfp.quant_comp;\n        } else better = gfp.quant_comp_short;\n        better = quant_compare(better, best_noise_info, noise_info, cod_info_w, distort) ? 1 : 0;\n\n        /* save data so we can restore this quantization later */\n        if (better != 0) {\n          best_part2_3_length = cod_info.part2_3_length;\n          best_noise_info = noise_info;\n          cod_info.assign(cod_info_w);\n          age = 0;\n          /* save data so we can restore this quantization later */\n          /* store for later reuse */\n          System.arraycopy(xrpow, 0, save_xrpow, 0, 576);\n        } else {\n          /* early stop? */\n          if (gfc.full_outer_loop == 0) {\n            if (++age > search_limit && best_noise_info.over_count == 0) break;\n            if (gfc.noise_shaping_amp == 3 && bRefine && age > 30) break;\n            if (gfc.noise_shaping_amp == 3 && bRefine && cod_info_w.global_gain - best_ggain_pass1 > 15) break;\n          }\n        }\n      } while (cod_info_w.global_gain + cod_info_w.scalefac_scale < 255);\n      if (gfc.noise_shaping_amp == 3) {\n        if (!bRefine) {\n          /* refine search */\n          cod_info_w.assign(cod_info);\n          System.arraycopy(save_xrpow, 0, xrpow, 0, 576);\n          age = 0;\n          best_ggain_pass1 = cod_info_w.global_gain;\n          bRefine = true;\n        } else {\n          /* search already refined, stop */\n          bEndOfSearch = true;\n        }\n      } else {\n        bEndOfSearch = true;\n      }\n    }\n    assert(cod_info.global_gain + cod_info.scalefac_scale <= 255);\n    /*\n     * finish up\n     */\n    if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh) /* restore for reuse on next try */\n      System.arraycopy(save_xrpow, 0, xrpow, 0, 576);\n      /*\n       * do the 'substep shaping'\n       */else if ((gfc.substep_shaping & 1) != 0) trancate_smallspectrums(gfc, cod_info, l3_xmin, xrpow);\n    return best_noise_info.over_count;\n  };\n\n  /**\n   * Robert Hegemann 2000-09-06\n   *\n   * update reservoir status after FINAL quantization/bitrate\n   */\n  this.iteration_finish_one = function (gfc, gr, ch) {\n    var l3_side = gfc.l3_side;\n    var cod_info = l3_side.tt[gr][ch];\n\n    /*\n     * try some better scalefac storage\n     */\n    tk.best_scalefac_store(gfc, gr, ch, l3_side);\n\n    /*\n     * best huffman_divide may save some bits too\n     */\n    if (gfc.use_best_huffman == 1) tk.best_huffman_divide(gfc, cod_info);\n\n    /*\n     * update reservoir status after FINAL quantization/bitrate\n     */\n    rv.ResvAdjust(gfc, cod_info);\n  };\n\n  /**\n   *\n   * 2000-09-04 Robert Hegemann\n   *\n   * @param l3_xmin\n   *            allowed distortion of the scalefactor\n   * @param xrpow\n   *            coloured magnitudes of spectral values\n   */\n  this.VBR_encode_granule = function (gfp, cod_info, l3_xmin, xrpow, ch, min_bits, max_bits) {\n    var gfc = gfp.internal_flags;\n    var bst_cod_info = new GrInfo();\n    var bst_xrpow = new_float(576);\n    var Max_bits = max_bits;\n    var real_bits = max_bits + 1;\n    var this_bits = (max_bits + min_bits) / 2;\n    var dbits,\n      over,\n      found = 0;\n    var sfb21_extra = gfc.sfb21_extra;\n    assert(Max_bits <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n    Arrays.fill(bst_cod_info.l3_enc, 0);\n\n    /*\n     * search within round about 40 bits of optimal\n     */\n    do {\n      assert(this_bits >= min_bits);\n      assert(this_bits <= max_bits);\n      assert(min_bits <= max_bits);\n      if (this_bits > Max_bits - 42) gfc.sfb21_extra = false;else gfc.sfb21_extra = sfb21_extra;\n      over = outer_loop(gfp, cod_info, l3_xmin, xrpow, ch, this_bits);\n\n      /*\n       * is quantization as good as we are looking for ? in this case: is\n       * no scalefactor band distorted?\n       */\n      if (over <= 0) {\n        found = 1;\n        /*\n         * now we know it can be done with \"real_bits\" and maybe we can\n         * skip some iterations\n         */\n        real_bits = cod_info.part2_3_length;\n\n        /*\n         * store best quantization so far\n         */\n        bst_cod_info.assign(cod_info);\n        System.arraycopy(xrpow, 0, bst_xrpow, 0, 576);\n\n        /*\n         * try with fewer bits\n         */\n        max_bits = real_bits - 32;\n        dbits = max_bits - min_bits;\n        this_bits = (max_bits + min_bits) / 2;\n      } else {\n        /*\n         * try with more bits\n         */\n        min_bits = this_bits + 32;\n        dbits = max_bits - min_bits;\n        this_bits = (max_bits + min_bits) / 2;\n        if (found != 0) {\n          found = 2;\n          /*\n           * start again with best quantization so far\n           */\n          cod_info.assign(bst_cod_info);\n          System.arraycopy(bst_xrpow, 0, xrpow, 0, 576);\n        }\n      }\n    } while (dbits > 12);\n    gfc.sfb21_extra = sfb21_extra;\n\n    /*\n     * found=0 => nothing found, use last one found=1 => we just found the\n     * best and left the loop found=2 => we restored a good one and have now\n     * l3_enc to restore too\n     */\n    if (found == 2) {\n      System.arraycopy(bst_cod_info.l3_enc, 0, cod_info.l3_enc, 0, 576);\n    }\n    assert(cod_info.part2_3_length <= Max_bits);\n  };\n\n  /**\n   * Robert Hegemann 2000-09-05\n   *\n   * calculates * how many bits are available for analog silent granules * how\n   * many bits to use for the lowest allowed bitrate * how many bits each\n   * bitrate would provide\n   */\n  this.get_framebits = function (gfp, frameBits) {\n    var gfc = gfp.internal_flags;\n\n    /*\n     * always use at least this many bits per granule per channel unless we\n     * detect analog silence, see below\n     */\n    gfc.bitrate_index = gfc.VBR_min_bitrate;\n    var bitsPerFrame = bs.getframebits(gfp);\n\n    /*\n     * bits for analog silence\n     */\n    gfc.bitrate_index = 1;\n    bitsPerFrame = bs.getframebits(gfp);\n    for (var i = 1; i <= gfc.VBR_max_bitrate; i++) {\n      gfc.bitrate_index = i;\n      var mb = new MeanBits(bitsPerFrame);\n      frameBits[i] = rv.ResvFrameBegin(gfp, mb);\n      bitsPerFrame = mb.bits;\n    }\n  };\n\n  /* RH: this one needs to be overhauled sometime */\n\n  /**\n   * <PRE>\n   *  2000-09-04 Robert Hegemann\n   *\n   *  * converts LR to MS coding when necessary\n   *  * calculates allowed/adjusted quantization noise amounts\n   *  * detects analog silent frames\n   *\n   *  some remarks:\n   *  - lower masking depending on Quality setting\n   *  - quality control together with adjusted ATH MDCT scaling\n   *    on lower quality setting allocate more noise from\n   *    ATH masking, and on higher quality setting allocate\n   *    less noise from ATH masking.\n   *  - experiments show that going more than 2dB over GPSYCHO's\n   *    limits ends up in very annoying artefacts\n   * </PRE>\n   */\n  this.VBR_old_prepare = function (gfp, pe, ms_ener_ratio, ratio, l3_xmin, frameBits, min_bits, max_bits, bands) {\n    var gfc = gfp.internal_flags;\n    var masking_lower_db,\n      adjust = 0.0;\n    var analog_silence = 1;\n    var bits = 0;\n    gfc.bitrate_index = gfc.VBR_max_bitrate;\n    var avg = rv.ResvFrameBegin(gfp, new MeanBits(0)) / gfc.mode_gr;\n    get_framebits(gfp, frameBits);\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      var mxb = qupvt.on_pe(gfp, pe, max_bits[gr], avg, gr, 0);\n      if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) {\n        ms_convert(gfc.l3_side, gr);\n        qupvt.reduce_side(max_bits[gr], ms_ener_ratio[gr], avg, mxb);\n      }\n      for (var ch = 0; ch < gfc.channels_out; ++ch) {\n        var cod_info = gfc.l3_side.tt[gr][ch];\n        if (cod_info.block_type != Encoder.SHORT_TYPE) {\n          // NORM, START or STOP type\n          adjust = 1.28 / (1 + Math.exp(3.5 - pe[gr][ch] / 300.)) - 0.05;\n          masking_lower_db = gfc.PSY.mask_adjust - adjust;\n        } else {\n          adjust = 2.56 / (1 + Math.exp(3.5 - pe[gr][ch] / 300.)) - 0.14;\n          masking_lower_db = gfc.PSY.mask_adjust_short - adjust;\n        }\n        gfc.masking_lower = Math.pow(10.0, masking_lower_db * 0.1);\n        init_outer_loop(gfc, cod_info);\n        bands[gr][ch] = qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info, l3_xmin[gr][ch]);\n        if (bands[gr][ch] != 0) analog_silence = 0;\n        min_bits[gr][ch] = 126;\n        bits += max_bits[gr][ch];\n      }\n    }\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      for (var ch = 0; ch < gfc.channels_out; ch++) {\n        if (bits > frameBits[gfc.VBR_max_bitrate]) {\n          max_bits[gr][ch] *= frameBits[gfc.VBR_max_bitrate];\n          max_bits[gr][ch] /= bits;\n        }\n        if (min_bits[gr][ch] > max_bits[gr][ch]) min_bits[gr][ch] = max_bits[gr][ch];\n      }\n      /* for ch */\n    }\n    /* for gr */\n\n    return analog_silence;\n  };\n  this.bitpressure_strategy = function (gfc, l3_xmin, min_bits, max_bits) {\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      for (var ch = 0; ch < gfc.channels_out; ch++) {\n        var gi = gfc.l3_side.tt[gr][ch];\n        var pxmin = l3_xmin[gr][ch];\n        var pxminPos = 0;\n        for (var sfb = 0; sfb < gi.psy_lmax; sfb++) pxmin[pxminPos++] *= 1. + .029 * sfb * sfb / Encoder.SBMAX_l / Encoder.SBMAX_l;\n        if (gi.block_type == Encoder.SHORT_TYPE) {\n          for (var sfb = gi.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n            pxmin[pxminPos++] *= 1. + .029 * sfb * sfb / Encoder.SBMAX_s / Encoder.SBMAX_s;\n            pxmin[pxminPos++] *= 1. + .029 * sfb * sfb / Encoder.SBMAX_s / Encoder.SBMAX_s;\n            pxmin[pxminPos++] *= 1. + .029 * sfb * sfb / Encoder.SBMAX_s / Encoder.SBMAX_s;\n          }\n        }\n        max_bits[gr][ch] = 0 | Math.max(min_bits[gr][ch], 0.9 * max_bits[gr][ch]);\n      }\n    }\n  };\n  this.VBR_new_prepare = function (gfp, pe, ratio, l3_xmin, frameBits, max_bits) {\n    var gfc = gfp.internal_flags;\n    var analog_silence = 1;\n    var avg = 0,\n      bits = 0;\n    var maximum_framebits;\n    if (!gfp.free_format) {\n      gfc.bitrate_index = gfc.VBR_max_bitrate;\n      var mb = new MeanBits(avg);\n      rv.ResvFrameBegin(gfp, mb);\n      avg = mb.bits;\n      get_framebits(gfp, frameBits);\n      maximum_framebits = frameBits[gfc.VBR_max_bitrate];\n    } else {\n      gfc.bitrate_index = 0;\n      var mb = new MeanBits(avg);\n      maximum_framebits = rv.ResvFrameBegin(gfp, mb);\n      avg = mb.bits;\n      frameBits[0] = maximum_framebits;\n    }\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      qupvt.on_pe(gfp, pe, max_bits[gr], avg, gr, 0);\n      if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) {\n        ms_convert(gfc.l3_side, gr);\n      }\n      for (var ch = 0; ch < gfc.channels_out; ++ch) {\n        var cod_info = gfc.l3_side.tt[gr][ch];\n        gfc.masking_lower = Math.pow(10.0, gfc.PSY.mask_adjust * 0.1);\n        init_outer_loop(gfc, cod_info);\n        if (0 != qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info, l3_xmin[gr][ch])) analog_silence = 0;\n        bits += max_bits[gr][ch];\n      }\n    }\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      for (var ch = 0; ch < gfc.channels_out; ch++) {\n        if (bits > maximum_framebits) {\n          max_bits[gr][ch] *= maximum_framebits;\n          max_bits[gr][ch] /= bits;\n        }\n      }\n      /* for ch */\n    }\n    /* for gr */\n\n    return analog_silence;\n  };\n\n  /**\n   * calculates target bits for ABR encoding\n   *\n   * mt 2000/05/31\n   */\n  this.calc_target_bits = function (gfp, pe, ms_ener_ratio, targ_bits, analog_silence_bits, max_frame_bits) {\n    var gfc = gfp.internal_flags;\n    var l3_side = gfc.l3_side;\n    var res_factor;\n    var gr,\n      ch,\n      totbits,\n      mean_bits = 0;\n    gfc.bitrate_index = gfc.VBR_max_bitrate;\n    var mb = new MeanBits(mean_bits);\n    max_frame_bits[0] = rv.ResvFrameBegin(gfp, mb);\n    mean_bits = mb.bits;\n    gfc.bitrate_index = 1;\n    mean_bits = bs.getframebits(gfp) - gfc.sideinfo_len * 8;\n    analog_silence_bits[0] = mean_bits / (gfc.mode_gr * gfc.channels_out);\n    mean_bits = gfp.VBR_mean_bitrate_kbps * gfp.framesize * 1000;\n    if ((gfc.substep_shaping & 1) != 0) mean_bits *= 1.09;\n    mean_bits /= gfp.out_samplerate;\n    mean_bits -= gfc.sideinfo_len * 8;\n    mean_bits /= gfc.mode_gr * gfc.channels_out;\n\n    /**\n     * <PRE>\n     *           res_factor is the percentage of the target bitrate that should\n     *           be used on average.  the remaining bits are added to the\n     *           bitreservoir and used for difficult to encode frames.\n     *\n     *           Since we are tracking the average bitrate, we should adjust\n     *           res_factor \"on the fly\", increasing it if the average bitrate\n     *           is greater than the requested bitrate, and decreasing it\n     *           otherwise.  Reasonable ranges are from .9 to 1.0\n     *\n     *           Until we get the above suggestion working, we use the following\n     *           tuning:\n     *           compression ratio    res_factor\n     *           5.5  (256kbps)         1.0      no need for bitreservoir\n     *           11   (128kbps)         .93      7% held for reservoir\n     *\n     *           with linear interpolation for other values.\n     * </PRE>\n     */\n    res_factor = .93 + .07 * (11.0 - gfp.compression_ratio) / (11.0 - 5.5);\n    if (res_factor < .90) res_factor = .90;\n    if (res_factor > 1.00) res_factor = 1.00;\n    for (gr = 0; gr < gfc.mode_gr; gr++) {\n      var sum = 0;\n      for (ch = 0; ch < gfc.channels_out; ch++) {\n        targ_bits[gr][ch] = int(res_factor * mean_bits);\n        if (pe[gr][ch] > 700) {\n          var add_bits = int((pe[gr][ch] - 700) / 1.4);\n          var cod_info = l3_side.tt[gr][ch];\n          targ_bits[gr][ch] = int(res_factor * mean_bits);\n\n          /* short blocks use a little extra, no matter what the pe */\n          if (cod_info.block_type == Encoder.SHORT_TYPE) {\n            if (add_bits < mean_bits / 2) add_bits = mean_bits / 2;\n          }\n          /* at most increase bits by 1.5*average */\n          if (add_bits > mean_bits * 3 / 2) add_bits = mean_bits * 3 / 2;else if (add_bits < 0) add_bits = 0;\n          targ_bits[gr][ch] += add_bits;\n        }\n        if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL) {\n          targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;\n        }\n        sum += targ_bits[gr][ch];\n      }\n      /* for ch */\n      if (sum > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n        for (ch = 0; ch < gfc.channels_out; ++ch) {\n          targ_bits[gr][ch] *= LameInternalFlags.MAX_BITS_PER_GRANULE;\n          targ_bits[gr][ch] /= sum;\n        }\n      }\n    }\n    /* for gr */\n\n    if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) for (gr = 0; gr < gfc.mode_gr; gr++) {\n      qupvt.reduce_side(targ_bits[gr], ms_ener_ratio[gr], mean_bits * gfc.channels_out, LameInternalFlags.MAX_BITS_PER_GRANULE);\n    }\n\n    /*\n     * sum target bits\n     */\n    totbits = 0;\n    for (gr = 0; gr < gfc.mode_gr; gr++) {\n      for (ch = 0; ch < gfc.channels_out; ch++) {\n        if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL) targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;\n        totbits += targ_bits[gr][ch];\n      }\n    }\n\n    /*\n     * repartion target bits if needed\n     */\n    if (totbits > max_frame_bits[0]) {\n      for (gr = 0; gr < gfc.mode_gr; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          targ_bits[gr][ch] *= max_frame_bits[0];\n          targ_bits[gr][ch] /= totbits;\n        }\n      }\n    }\n  };\n}\nmodule.exports = Quantize;","map":{"version":3,"names":["common","require","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","VBRQuantize","CalcNoiseResult","CalcNoiseData","Encoder","GrInfo","L3Side","Quantize","bs","rv","qupvt","vbr","tk","setModules","_bs","_rv","_qupvt","_tk","ms_convert","l3_side","gr","i","l","tt","xr","r","SQRT2","init_xrpow_core","cod_info","xrpow","upper","sum","tmp","Math","abs","sqrt","xrpow_max","init_xrpow","gfc","max_nonzero_coeff","fill","j","substep_shaping","psymax","pseudohalf","l3_enc","psfb21_analogsilence","ath","ATH","block_type","SHORT_TYPE","stop","gsfb","PSFB21","start","scalefac_band","psfb21","end","ath21","athAdjust","adjust","floor","nsPsy","longfact","block","PSFB12","s","psfb12","ath12","shortfact","init_outer_loop","part2_3_length","big_values","count1","global_gain","scalefac_compress","table_select","subblock_gain","region0_count","region1_count","preflag","scalefac_scale","count1table_select","part2_length","sfb_lmax","SBPSY_l","sfb_smin","SBPSY_s","psy_lmax","sfb21_extra","SBMAX_l","sfbmax","sfbdivide","sfb","width","window","ixwork","mixed_block_flag","mode_gr","SBMAX_s","ix","arraycopy","count1bits","sfb_partition_table","nr_of_sfb_block","slen","scalefac","BinSearchDirection","ordinal","BINSEARCH_NONE","BINSEARCH_UP","BINSEARCH_DOWN","bin_search_StepSize","desired_rate","ch","nBits","CurrentStep","flagGoneOver","OldValue","Direction","step","count_bits","trancate_smallspectrums","gi","l3_xmin","work","distort","SFBMAX","calc_noise","allowedNoise","trancateThreshold","nsame","sort","BitStream","EQ","noise","NEQ","noquant_count_bits","loop_break","penalties","FAST_LOG10","get_klemm_noise","klemm_noise","max","quant_compare","quant_comp","best","calc","better","over_count","over_SSD","bits","max_noise","over_noise","tot_noise","amp_scalefac_bands","gfp","bRefine","internal_flags","ifqstep34","trigger","noise_shaping_amp","pow","inc_scalefac_scale","pretab","inc_subblock_gain","s1","s2","amp","gain","IPOW20","balance_noise","status","scale_bitcount","scale_bitcount_lsf","noise_shaping","outer_loop","targ_bits","cod_info_w","save_xrpow","best_noise_info","prev_noise","best_part2_3_length","bEndOfSearch","best_ggain_pass1","assign","age","noise_info","search_limit","maxggain","huff_bits","quant_comp_short","full_outer_loop","VBR","vbr_rh","vbr_mtrh","iteration_finish_one","best_scalefac_store","use_best_huffman","best_huffman_divide","ResvAdjust","VBR_encode_granule","min_bits","max_bits","bst_cod_info","bst_xrpow","Max_bits","real_bits","this_bits","dbits","over","found","LameInternalFlags","MAX_BITS_PER_CHANNEL","get_framebits","frameBits","bitrate_index","VBR_min_bitrate","bitsPerFrame","getframebits","VBR_max_bitrate","mb","MeanBits","ResvFrameBegin","VBR_old_prepare","pe","ms_ener_ratio","ratio","bands","masking_lower_db","analog_silence","avg","mxb","on_pe","mode_ext","MPG_MD_MS_LR","reduce_side","channels_out","exp","PSY","mask_adjust","mask_adjust_short","masking_lower","calc_xmin","bitpressure_strategy","pxmin","pxminPos","VBR_new_prepare","maximum_framebits","free_format","calc_target_bits","analog_silence_bits","max_frame_bits","res_factor","totbits","mean_bits","sideinfo_len","VBR_mean_bitrate_kbps","framesize","out_samplerate","compression_ratio","int","add_bits","MAX_BITS_PER_GRANULE","module","exports"],"sources":["D:/代码/vscodeProjects/AiEducation/vue_aieducation/node_modules/lamejs/src/js/Quantize.js"],"sourcesContent":["/*\n * MP3 quantization\n *\n *      Copyright (c) 1999-2000 Mark Taylor\n *      Copyright (c) 1999-2003 Takehiro Tominaga\n *      Copyright (c) 2000-2007 Robert Hegemann\n *      Copyright (c) 2001-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.     See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Quantize.java,v 1.24 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n//import java.util.Arrays;\nvar common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar VBRQuantize = require('./VBRQuantize.js');\nvar CalcNoiseResult = require('./CalcNoiseResult.js');\nvar CalcNoiseData = require('./CalcNoiseData.js');\nvar Encoder = require('./Encoder.js');\nvar GrInfo = require('./GrInfo.js');\nvar L3Side = require('./L3Side.js');\n\nfunction Quantize() {\n    var bs;\n    this.rv = null;\n    var rv;\n    this.qupvt = null;\n    var qupvt;\n\n    var vbr = new VBRQuantize();\n    var tk;\n\n    this.setModules = function (_bs, _rv, _qupvt, _tk) {\n        bs = _bs;\n        rv = _rv;\n        this.rv = _rv;\n        qupvt = _qupvt;\n        this.qupvt = _qupvt;\n        tk = _tk;\n        vbr.setModules(qupvt, tk);\n    }\n\n    /**\n     * convert from L/R <. Mid/Side\n     */\n    this.ms_convert = function (l3_side, gr) {\n        for (var i = 0; i < 576; ++i) {\n            var l = l3_side.tt[gr][0].xr[i];\n            var r = l3_side.tt[gr][1].xr[i];\n            l3_side.tt[gr][0].xr[i] = (l + r) * (Util.SQRT2 * 0.5);\n            l3_side.tt[gr][1].xr[i] = (l - r) * (Util.SQRT2 * 0.5);\n        }\n    };\n\n    /**\n     * mt 6/99\n     *\n     * initializes cod_info, scalefac and xrpow\n     *\n     * returns 0 if all energies in xr are zero, else 1\n     */\n    function init_xrpow_core(cod_info, xrpow, upper, sum) {\n        sum = 0;\n        for (var i = 0; i <= upper; ++i) {\n            var tmp = Math.abs(cod_info.xr[i]);\n            sum += tmp;\n            xrpow[i] = Math.sqrt(tmp * Math.sqrt(tmp));\n\n            if (xrpow[i] > cod_info.xrpow_max)\n                cod_info.xrpow_max = xrpow[i];\n        }\n        return sum;\n    }\n\n    this.init_xrpow = function (gfc, cod_info, xrpow) {\n        var sum = 0;\n        var upper = 0 | cod_info.max_nonzero_coeff;\n\n        assert(xrpow != null);\n        cod_info.xrpow_max = 0;\n\n        /*\n         * check if there is some energy we have to quantize and calculate xrpow\n         * matching our fresh scalefactors\n         */\n        assert(0 <= upper && upper <= 575);\n\n        Arrays.fill(xrpow, upper, 576, 0);\n\n        sum = init_xrpow_core(cod_info, xrpow, upper, sum);\n\n        /*\n         * return 1 if we have something to quantize, else 0\n         */\n        if (sum > 1E-20) {\n            var j = 0;\n            if ((gfc.substep_shaping & 2) != 0)\n                j = 1;\n\n            for (var i = 0; i < cod_info.psymax; i++)\n                gfc.pseudohalf[i] = j;\n\n            return true;\n        }\n\n        Arrays.fill(cod_info.l3_enc, 0, 576, 0);\n        return false;\n    }\n\n    /**\n     * Gabriel Bouvigne feb/apr 2003<BR>\n     * Analog silence detection in partitionned sfb21 or sfb12 for short blocks\n     *\n     * From top to bottom of sfb, changes to 0 coeffs which are below ath. It\n     * stops on the first coeff higher than ath.\n     */\n    function psfb21_analogsilence(gfc, cod_info) {\n        var ath = gfc.ATH;\n        var xr = cod_info.xr;\n\n        if (cod_info.block_type != Encoder.SHORT_TYPE) {\n            /* NORM, START or STOP type, but not SHORT blocks */\n            var stop = false;\n            for (var gsfb = Encoder.PSFB21 - 1; gsfb >= 0 && !stop; gsfb--) {\n                var start = gfc.scalefac_band.psfb21[gsfb];\n                var end = gfc.scalefac_band.psfb21[gsfb + 1];\n                var ath21 = qupvt.athAdjust(ath.adjust, ath.psfb21[gsfb],\n                    ath.floor);\n\n                if (gfc.nsPsy.longfact[21] > 1e-12)\n                    ath21 *= gfc.nsPsy.longfact[21];\n\n                for (var j = end - 1; j >= start; j--) {\n                    if (Math.abs(xr[j]) < ath21)\n                        xr[j] = 0;\n                    else {\n                        stop = true;\n                        break;\n                    }\n                }\n            }\n        } else {\n            /* note: short blocks coeffs are reordered */\n            for (var block = 0; block < 3; block++) {\n                var stop = false;\n                for (var gsfb = Encoder.PSFB12 - 1; gsfb >= 0 && !stop; gsfb--) {\n                    var start = gfc.scalefac_band.s[12]\n                        * 3\n                        + (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12])\n                        * block\n                        + (gfc.scalefac_band.psfb12[gsfb] - gfc.scalefac_band.psfb12[0]);\n                    var end = start\n                        + (gfc.scalefac_band.psfb12[gsfb + 1] - gfc.scalefac_band.psfb12[gsfb]);\n                    var ath12 = qupvt.athAdjust(ath.adjust, ath.psfb12[gsfb],\n                        ath.floor);\n\n                    if (gfc.nsPsy.shortfact[12] > 1e-12)\n                        ath12 *= gfc.nsPsy.shortfact[12];\n\n                    for (var j = end - 1; j >= start; j--) {\n                        if (Math.abs(xr[j]) < ath12)\n                            xr[j] = 0;\n                        else {\n                            stop = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    this.init_outer_loop = function (gfc, cod_info) {\n        /*\n         * initialize fresh cod_info\n         */\n        cod_info.part2_3_length = 0;\n        cod_info.big_values = 0;\n        cod_info.count1 = 0;\n        cod_info.global_gain = 210;\n        cod_info.scalefac_compress = 0;\n        /* mixed_block_flag, block_type was set in psymodel.c */\n        cod_info.table_select[0] = 0;\n        cod_info.table_select[1] = 0;\n        cod_info.table_select[2] = 0;\n        cod_info.subblock_gain[0] = 0;\n        cod_info.subblock_gain[1] = 0;\n        cod_info.subblock_gain[2] = 0;\n        cod_info.subblock_gain[3] = 0;\n        /* this one is always 0 */\n        cod_info.region0_count = 0;\n        cod_info.region1_count = 0;\n        cod_info.preflag = 0;\n        cod_info.scalefac_scale = 0;\n        cod_info.count1table_select = 0;\n        cod_info.part2_length = 0;\n        cod_info.sfb_lmax = Encoder.SBPSY_l;\n        cod_info.sfb_smin = Encoder.SBPSY_s;\n        cod_info.psy_lmax = gfc.sfb21_extra ? Encoder.SBMAX_l : Encoder.SBPSY_l;\n        cod_info.psymax = cod_info.psy_lmax;\n        cod_info.sfbmax = cod_info.sfb_lmax;\n        cod_info.sfbdivide = 11;\n        for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n            cod_info.width[sfb] = gfc.scalefac_band.l[sfb + 1]\n                - gfc.scalefac_band.l[sfb];\n            /* which is always 0. */\n            cod_info.window[sfb] = 3;\n        }\n        if (cod_info.block_type == Encoder.SHORT_TYPE) {\n            var ixwork = new_float(576);\n\n            cod_info.sfb_smin = 0;\n            cod_info.sfb_lmax = 0;\n            if (cod_info.mixed_block_flag != 0) {\n                /*\n                 * MPEG-1: sfbs 0-7 long block, 3-12 short blocks MPEG-2(.5):\n                 * sfbs 0-5 long block, 3-12 short blocks\n                 */\n                cod_info.sfb_smin = 3;\n                cod_info.sfb_lmax = gfc.mode_gr * 2 + 4;\n            }\n            cod_info.psymax = cod_info.sfb_lmax\n                + 3\n                * ((gfc.sfb21_extra ? Encoder.SBMAX_s : Encoder.SBPSY_s) - cod_info.sfb_smin);\n            cod_info.sfbmax = cod_info.sfb_lmax + 3\n                * (Encoder.SBPSY_s - cod_info.sfb_smin);\n            cod_info.sfbdivide = cod_info.sfbmax - 18;\n            cod_info.psy_lmax = cod_info.sfb_lmax;\n            /* re-order the short blocks, for more efficient encoding below */\n            /* By Takehiro TOMINAGA */\n            /*\n             * Within each scalefactor band, data is given for successive time\n             * windows, beginning with window 0 and ending with window 2. Within\n             * each window, the quantized values are then arranged in order of\n             * increasing frequency...\n             */\n            var ix = gfc.scalefac_band.l[cod_info.sfb_lmax];\n            System.arraycopy(cod_info.xr, 0, ixwork, 0, 576);\n            for (var sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n                var start = gfc.scalefac_band.s[sfb];\n                var end = gfc.scalefac_band.s[sfb + 1];\n                for (var window = 0; window < 3; window++) {\n                    for (var l = start; l < end; l++) {\n                        cod_info.xr[ix++] = ixwork[3 * l + window];\n                    }\n                }\n            }\n\n            var j = cod_info.sfb_lmax;\n            for (var sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n                cod_info.width[j] = cod_info.width[j + 1] = cod_info.width[j + 2] = gfc.scalefac_band.s[sfb + 1]\n                    - gfc.scalefac_band.s[sfb];\n                cod_info.window[j] = 0;\n                cod_info.window[j + 1] = 1;\n                cod_info.window[j + 2] = 2;\n                j += 3;\n            }\n        }\n\n        cod_info.count1bits = 0;\n        cod_info.sfb_partition_table = qupvt.nr_of_sfb_block[0][0];\n        cod_info.slen[0] = 0;\n        cod_info.slen[1] = 0;\n        cod_info.slen[2] = 0;\n        cod_info.slen[3] = 0;\n\n        cod_info.max_nonzero_coeff = 575;\n\n        /*\n         * fresh scalefactors are all zero\n         */\n        Arrays.fill(cod_info.scalefac, 0);\n\n        psfb21_analogsilence(gfc, cod_info);\n    };\n\n    function BinSearchDirection(ordinal) {\n        this.ordinal = ordinal;\n    }\n\n    BinSearchDirection.BINSEARCH_NONE = new BinSearchDirection(0);\n    BinSearchDirection.BINSEARCH_UP = new BinSearchDirection(1);\n    BinSearchDirection.BINSEARCH_DOWN = new BinSearchDirection(2);\n\n    /**\n     * author/date??\n     *\n     * binary step size search used by outer_loop to get a quantizer step size\n     * to start with\n     */\n    function bin_search_StepSize(gfc, cod_info, desired_rate, ch, xrpow) {\n        var nBits;\n        var CurrentStep = gfc.CurrentStep[ch];\n        var flagGoneOver = false;\n        var start = gfc.OldValue[ch];\n        var Direction = BinSearchDirection.BINSEARCH_NONE;\n        cod_info.global_gain = start;\n        desired_rate -= cod_info.part2_length;\n\n        assert(CurrentStep != 0);\n        for (; ;) {\n            var step;\n            nBits = tk.count_bits(gfc, xrpow, cod_info, null);\n\n            if (CurrentStep == 1 || nBits == desired_rate)\n                break;\n            /* nothing to adjust anymore */\n\n            if (nBits > desired_rate) {\n                /* increase Quantize_StepSize */\n                if (Direction == BinSearchDirection.BINSEARCH_DOWN)\n                    flagGoneOver = true;\n\n                if (flagGoneOver)\n                    CurrentStep /= 2;\n                Direction = BinSearchDirection.BINSEARCH_UP;\n                step = CurrentStep;\n            } else {\n                /* decrease Quantize_StepSize */\n                if (Direction == BinSearchDirection.BINSEARCH_UP)\n                    flagGoneOver = true;\n\n                if (flagGoneOver)\n                    CurrentStep /= 2;\n                Direction = BinSearchDirection.BINSEARCH_DOWN;\n                step = -CurrentStep;\n            }\n            cod_info.global_gain += step;\n            if (cod_info.global_gain < 0) {\n                cod_info.global_gain = 0;\n                flagGoneOver = true;\n            }\n            if (cod_info.global_gain > 255) {\n                cod_info.global_gain = 255;\n                flagGoneOver = true;\n            }\n        }\n\n        assert(cod_info.global_gain >= 0);\n        assert(cod_info.global_gain < 256);\n\n        while (nBits > desired_rate && cod_info.global_gain < 255) {\n            cod_info.global_gain++;\n            nBits = tk.count_bits(gfc, xrpow, cod_info, null);\n        }\n        gfc.CurrentStep[ch] = (start - cod_info.global_gain >= 4) ? 4 : 2;\n        gfc.OldValue[ch] = cod_info.global_gain;\n        cod_info.part2_3_length = nBits;\n        return nBits;\n    }\n\n    this.trancate_smallspectrums = function (gfc, gi, l3_xmin, work) {\n        var distort = new_float(L3Side.SFBMAX);\n\n        if ((0 == (gfc.substep_shaping & 4) && gi.block_type == Encoder.SHORT_TYPE)\n            || (gfc.substep_shaping & 0x80) != 0)\n            return;\n        qupvt.calc_noise(gi, l3_xmin, distort, new CalcNoiseResult(), null);\n        for (var j = 0; j < 576; j++) {\n            var xr = 0.0;\n            if (gi.l3_enc[j] != 0)\n                xr = Math.abs(gi.xr[j]);\n            work[j] = xr;\n        }\n\n        var j = 0;\n        var sfb = 8;\n        if (gi.block_type == Encoder.SHORT_TYPE)\n            sfb = 6;\n        do {\n            var allowedNoise, trancateThreshold;\n            var nsame, start;\n\n            var width = gi.width[sfb];\n            j += width;\n            if (distort[sfb] >= 1.0)\n                continue;\n\n            Arrays.sort(work, j - width, width);\n            if (BitStream.EQ(work[j - 1], 0.0))\n                continue;\n            /* all zero sfb */\n\n            allowedNoise = (1.0 - distort[sfb]) * l3_xmin[sfb];\n            trancateThreshold = 0.0;\n            start = 0;\n            do {\n                var noise;\n                for (nsame = 1; start + nsame < width; nsame++)\n                    if (BitStream.NEQ(work[start + j - width], work[start + j\n                        + nsame - width]))\n                        break;\n\n                noise = work[start + j - width] * work[start + j - width]\n                    * nsame;\n                if (allowedNoise < noise) {\n                    if (start != 0)\n                        trancateThreshold = work[start + j - width - 1];\n                    break;\n                }\n                allowedNoise -= noise;\n                start += nsame;\n            } while (start < width);\n            if (BitStream.EQ(trancateThreshold, 0.0))\n                continue;\n\n            do {\n                if (Math.abs(gi.xr[j - width]) <= trancateThreshold)\n                    gi.l3_enc[j - width] = 0;\n            } while (--width > 0);\n        } while (++sfb < gi.psymax);\n\n        gi.part2_3_length = tk.noquant_count_bits(gfc, gi, null);\n    };\n\n    /**\n     * author/date??\n     *\n     * Function: Returns zero if there is a scalefac which has not been\n     * amplified. Otherwise it returns one.\n     */\n    function loop_break(cod_info) {\n        for (var sfb = 0; sfb < cod_info.sfbmax; sfb++)\n            if (cod_info.scalefac[sfb]\n                + cod_info.subblock_gain[cod_info.window[sfb]] == 0)\n                return false;\n\n        return true;\n    }\n\n    /* mt 5/99: Function: Improved calc_noise for a single channel */\n\n    function penalties(noise) {\n        return Util.FAST_LOG10((0.368 + 0.632 * noise * noise * noise));\n    }\n\n    /**\n     * author/date??\n     *\n     * several different codes to decide which quantization is better\n     */\n    function get_klemm_noise(distort, gi) {\n        var klemm_noise = 1E-37;\n        for (var sfb = 0; sfb < gi.psymax; sfb++)\n            klemm_noise += penalties(distort[sfb]);\n\n        return Math.max(1e-20, klemm_noise);\n    }\n\n    function quant_compare(quant_comp, best, calc, gi, distort) {\n        /**\n         * noise is given in decibels (dB) relative to masking thesholds.<BR>\n         *\n         * over_noise: ??? (the previous comment is fully wrong)<BR>\n         * tot_noise: ??? (the previous comment is fully wrong)<BR>\n         * max_noise: max quantization noise\n         */\n        var better;\n\n        switch (quant_comp) {\n            default:\n            case 9:\n            {\n                if (best.over_count > 0) {\n                    /* there are distorted sfb */\n                    better = calc.over_SSD <= best.over_SSD;\n                    if (calc.over_SSD == best.over_SSD)\n                        better = calc.bits < best.bits;\n                } else {\n                    /* no distorted sfb */\n                    better = ((calc.max_noise < 0) && ((calc.max_noise * 10 + calc.bits) <= (best.max_noise * 10 + best.bits)));\n                }\n                break;\n            }\n\n            case 0:\n                better = calc.over_count < best.over_count\n                    || (calc.over_count == best.over_count && calc.over_noise < best.over_noise)\n                    || (calc.over_count == best.over_count\n                    && BitStream.EQ(calc.over_noise, best.over_noise) && calc.tot_noise < best.tot_noise);\n                break;\n\n            case 8:\n                calc.max_noise = get_klemm_noise(distort, gi);\n            //$FALL-THROUGH$\n            case 1:\n                better = calc.max_noise < best.max_noise;\n                break;\n            case 2:\n                better = calc.tot_noise < best.tot_noise;\n                break;\n            case 3:\n                better = (calc.tot_noise < best.tot_noise)\n                    && (calc.max_noise < best.max_noise);\n                break;\n            case 4:\n                better = (calc.max_noise <= 0.0 && best.max_noise > 0.2)\n                    || (calc.max_noise <= 0.0 && best.max_noise < 0.0\n                    && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise)\n                    || (calc.max_noise <= 0.0 && best.max_noise > 0.0\n                    && best.max_noise > calc.max_noise - 0.2 && calc.tot_noise < best.tot_noise\n                    + best.over_noise)\n                    || (calc.max_noise > 0.0 && best.max_noise > -0.05\n                    && best.max_noise > calc.max_noise - 0.1 && calc.tot_noise\n                    + calc.over_noise < best.tot_noise\n                    + best.over_noise)\n                    || (calc.max_noise > 0.0 && best.max_noise > -0.1\n                    && best.max_noise > calc.max_noise - 0.15 && calc.tot_noise\n                    + calc.over_noise + calc.over_noise < best.tot_noise\n                    + best.over_noise + best.over_noise);\n                break;\n            case 5:\n                better = calc.over_noise < best.over_noise\n                    || (BitStream.EQ(calc.over_noise, best.over_noise) && calc.tot_noise < best.tot_noise);\n                break;\n            case 6:\n                better = calc.over_noise < best.over_noise\n                    || (BitStream.EQ(calc.over_noise, best.over_noise) && (calc.max_noise < best.max_noise || (BitStream\n                        .EQ(calc.max_noise, best.max_noise) && calc.tot_noise <= best.tot_noise)));\n                break;\n            case 7:\n                better = calc.over_count < best.over_count\n                    || calc.over_noise < best.over_noise;\n                break;\n        }\n\n        if (best.over_count == 0) {\n            /*\n             * If no distorted bands, only use this quantization if it is\n             * better, and if it uses less bits. Unfortunately, part2_3_length\n             * is sometimes a poor estimator of the final size at low bitrates.\n             */\n            better = better && calc.bits < best.bits;\n        }\n\n        return better;\n    }\n\n    /**\n     * author/date??\n     *\n     * <PRE>\n     *  Amplify the scalefactor bands that violate the masking threshold.\n     *  See ISO 11172-3 Section C.1.5.4.3.5\n     *\n     *  distort[] = noise/masking\n     *  distort[] > 1   ==> noise is not masked\n     *  distort[] < 1   ==> noise is masked\n     *  max_dist = maximum value of distort[]\n     *\n     *  Three algorithms:\n     *  noise_shaping_amp\n     *        0             Amplify all bands with distort[]>1.\n     *\n     *        1             Amplify all bands with distort[] >= max_dist^(.5);\n     *                     ( 50% in the db scale)\n     *\n     *        2             Amplify first band with distort[] >= max_dist;\n     *\n     *\n     *  For algorithms 0 and 1, if max_dist < 1, then amplify all bands\n     *  with distort[] >= .95*max_dist.  This is to make sure we always\n     *  amplify at least one band.\n     * </PRE>\n     */\n    function amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine) {\n        var gfc = gfp.internal_flags;\n        var ifqstep34;\n\n        if (cod_info.scalefac_scale == 0) {\n            ifqstep34 = 1.29683955465100964055;\n            /* 2**(.75*.5) */\n        } else {\n            ifqstep34 = 1.68179283050742922612;\n            /* 2**(.75*1) */\n        }\n\n        /* compute maximum value of distort[] */\n        var trigger = 0;\n        for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            if (trigger < distort[sfb])\n                trigger = distort[sfb];\n        }\n\n        var noise_shaping_amp = gfc.noise_shaping_amp;\n        if (noise_shaping_amp == 3) {\n            if (bRefine)\n                noise_shaping_amp = 2;\n            else\n                noise_shaping_amp = 1;\n        }\n        switch (noise_shaping_amp) {\n            case 2:\n                /* amplify exactly 1 band */\n                break;\n\n            case 1:\n                /* amplify bands within 50% of max (on db scale) */\n                if (trigger > 1.0)\n                    trigger = Math.pow(trigger, .5);\n                else\n                    trigger *= .95;\n                break;\n\n            case 0:\n            default:\n                /* ISO algorithm. amplify all bands with distort>1 */\n                if (trigger > 1.0)\n                    trigger = 1.0;\n                else\n                    trigger *= .95;\n                break;\n        }\n\n        var j = 0;\n        for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            var width = cod_info.width[sfb];\n            var l;\n            j += width;\n            if (distort[sfb] < trigger)\n                continue;\n\n            if ((gfc.substep_shaping & 2) != 0) {\n                gfc.pseudohalf[sfb] = (0 == gfc.pseudohalf[sfb]) ? 1 : 0;\n                if (0 == gfc.pseudohalf[sfb] && gfc.noise_shaping_amp == 2)\n                    return;\n            }\n            cod_info.scalefac[sfb]++;\n            for (l = -width; l < 0; l++) {\n                xrpow[j + l] *= ifqstep34;\n                if (xrpow[j + l] > cod_info.xrpow_max)\n                    cod_info.xrpow_max = xrpow[j + l];\n            }\n\n            if (gfc.noise_shaping_amp == 2)\n                return;\n        }\n    }\n\n    /**\n     * Takehiro Tominaga 2000-xx-xx\n     *\n     * turns on scalefac scale and adjusts scalefactors\n     */\n    function inc_scalefac_scale(cod_info, xrpow) {\n        var ifqstep34 = 1.29683955465100964055;\n\n        var j = 0;\n        for (var sfb = 0; sfb < cod_info.sfbmax; sfb++) {\n            var width = cod_info.width[sfb];\n            var s = cod_info.scalefac[sfb];\n            if (cod_info.preflag != 0)\n                s += qupvt.pretab[sfb];\n            j += width;\n            if ((s & 1) != 0) {\n                s++;\n                for (var l = -width; l < 0; l++) {\n                    xrpow[j + l] *= ifqstep34;\n                    if (xrpow[j + l] > cod_info.xrpow_max)\n                        cod_info.xrpow_max = xrpow[j + l];\n                }\n            }\n            cod_info.scalefac[sfb] = s >> 1;\n        }\n        cod_info.preflag = 0;\n        cod_info.scalefac_scale = 1;\n    }\n\n    /**\n     * Takehiro Tominaga 2000-xx-xx\n     *\n     * increases the subblock gain and adjusts scalefactors\n     */\n    function inc_subblock_gain(gfc, cod_info, xrpow) {\n        var sfb;\n        var scalefac = cod_info.scalefac;\n\n        /* subbloc_gain can't do anything in the long block region */\n        for (sfb = 0; sfb < cod_info.sfb_lmax; sfb++) {\n            if (scalefac[sfb] >= 16)\n                return true;\n        }\n\n        for (var window = 0; window < 3; window++) {\n            var s1 = 0;\n            var s2 = 0;\n\n            for (sfb = cod_info.sfb_lmax + window; sfb < cod_info.sfbdivide; sfb += 3) {\n                if (s1 < scalefac[sfb])\n                    s1 = scalefac[sfb];\n            }\n            for (; sfb < cod_info.sfbmax; sfb += 3) {\n                if (s2 < scalefac[sfb])\n                    s2 = scalefac[sfb];\n            }\n\n            if (s1 < 16 && s2 < 8)\n                continue;\n\n            if (cod_info.subblock_gain[window] >= 7)\n                return true;\n\n            /*\n             * even though there is no scalefactor for sfb12 subblock gain\n             * affects upper frequencies too, that's why we have to go up to\n             * SBMAX_s\n             */\n            cod_info.subblock_gain[window]++;\n            var j = gfc.scalefac_band.l[cod_info.sfb_lmax];\n            for (sfb = cod_info.sfb_lmax + window; sfb < cod_info.sfbmax; sfb += 3) {\n                var amp;\n                var width = cod_info.width[sfb];\n                var s = scalefac[sfb];\n                assert(s >= 0);\n                s = s - (4 >> cod_info.scalefac_scale);\n                if (s >= 0) {\n                    scalefac[sfb] = s;\n                    j += width * 3;\n                    continue;\n                }\n\n                scalefac[sfb] = 0;\n                {\n                    var gain = 210 + (s << (cod_info.scalefac_scale + 1));\n                    amp = qupvt.IPOW20(gain);\n                }\n                j += width * (window + 1);\n                for (var l = -width; l < 0; l++) {\n                    xrpow[j + l] *= amp;\n                    if (xrpow[j + l] > cod_info.xrpow_max)\n                        cod_info.xrpow_max = xrpow[j + l];\n                }\n                j += width * (3 - window - 1);\n            }\n\n            {\n                var amp = qupvt.IPOW20(202);\n                j += cod_info.width[sfb] * (window + 1);\n                for (var l = -cod_info.width[sfb]; l < 0; l++) {\n                    xrpow[j + l] *= amp;\n                    if (xrpow[j + l] > cod_info.xrpow_max)\n                        cod_info.xrpow_max = xrpow[j + l];\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * <PRE>\n     *  Takehiro Tominaga /date??\n     *  Robert Hegemann 2000-09-06: made a function of it\n     *\n     *  amplifies scalefactor bands,\n     *   - if all are already amplified returns 0\n     *   - if some bands are amplified too much:\n     *      * try to increase scalefac_scale\n     *      * if already scalefac_scale was set\n     *          try on short blocks to increase subblock gain\n     * </PRE>\n     */\n    function balance_noise(gfp, cod_info, distort, xrpow, bRefine) {\n        var gfc = gfp.internal_flags;\n\n        amp_scalefac_bands(gfp, cod_info, distort, xrpow, bRefine);\n\n        /*\n         * check to make sure we have not amplified too much loop_break returns\n         * 0 if there is an unamplified scalefac scale_bitcount returns 0 if no\n         * scalefactors are too large\n         */\n\n        var status = loop_break(cod_info);\n\n        if (status)\n            return false;\n        /* all bands amplified */\n\n        /*\n         * not all scalefactors have been amplified. so these scalefacs are\n         * possibly valid. encode them:\n         */\n        if (gfc.mode_gr == 2)\n            status = tk.scale_bitcount(cod_info);\n        else\n            status = tk.scale_bitcount_lsf(gfc, cod_info);\n\n        if (!status)\n            return true;\n        /* amplified some bands not exceeding limits */\n\n        /*\n         * some scalefactors are too large. lets try setting scalefac_scale=1\n         */\n        if (gfc.noise_shaping > 1) {\n            Arrays.fill(gfc.pseudohalf, 0);\n            if (0 == cod_info.scalefac_scale) {\n                inc_scalefac_scale(cod_info, xrpow);\n                status = false;\n            } else {\n                if (cod_info.block_type == Encoder.SHORT_TYPE\n                    && gfc.subblock_gain > 0) {\n                    status = (inc_subblock_gain(gfc, cod_info, xrpow) || loop_break(cod_info));\n                }\n            }\n        }\n\n        if (!status) {\n            if (gfc.mode_gr == 2)\n                status = tk.scale_bitcount(cod_info);\n            else\n                status = tk.scale_bitcount_lsf(gfc, cod_info);\n        }\n        return !status;\n    }\n\n    /**\n     * <PRE>\n     *  Function: The outer iteration loop controls the masking conditions\n     *  of all scalefactorbands. It computes the best scalefac and\n     *  global gain. This module calls the inner iteration loop\n     *\n     *  mt 5/99 completely rewritten to allow for bit reservoir control,\n     *  mid/side channels with L/R or mid/side masking thresholds,\n     *  and chooses best quantization instead of last quantization when\n     *  no distortion free quantization can be found.\n     *\n     *  added VBR support mt 5/99\n     *\n     *  some code shuffle rh 9/00\n     * </PRE>\n     *\n     * @param l3_xmin\n     *            allowed distortion\n     * @param xrpow\n     *            coloured magnitudes of spectral\n     * @param targ_bits\n     *            maximum allowed bits\n     */\n    this.outer_loop = function (gfp, cod_info, l3_xmin, xrpow, ch, targ_bits) {\n        var gfc = gfp.internal_flags;\n        var cod_info_w = new GrInfo();\n        var save_xrpow = new_float(576);\n        var distort = new_float(L3Side.SFBMAX);\n        var best_noise_info = new CalcNoiseResult();\n        var better;\n        var prev_noise = new CalcNoiseData();\n        var best_part2_3_length = 9999999;\n        var bEndOfSearch = false;\n        var bRefine = false;\n        var best_ggain_pass1 = 0;\n\n        bin_search_StepSize(gfc, cod_info, targ_bits, ch, xrpow);\n\n        if (0 == gfc.noise_shaping)\n        /* fast mode, no noise shaping, we are ready */\n            return 100;\n        /* default noise_info.over_count */\n\n        /* compute the distortion in this quantization */\n        /* coefficients and thresholds both l/r (or both mid/side) */\n        qupvt.calc_noise(cod_info, l3_xmin, distort, best_noise_info,\n            prev_noise);\n        best_noise_info.bits = cod_info.part2_3_length;\n\n        cod_info_w.assign(cod_info);\n        var age = 0;\n        System.arraycopy(xrpow, 0, save_xrpow, 0, 576);\n\n        while (!bEndOfSearch) {\n            /* BEGIN MAIN LOOP */\n            do {\n                var noise_info = new CalcNoiseResult();\n                var search_limit;\n                var maxggain = 255;\n\n                /*\n                 * When quantization with no distorted bands is found, allow up\n                 * to X new unsuccesful tries in serial. This gives us more\n                 * possibilities for different quant_compare modes. Much more\n                 * than 3 makes not a big difference, it is only slower.\n                 */\n\n                if ((gfc.substep_shaping & 2) != 0) {\n                    search_limit = 20;\n                } else {\n                    search_limit = 3;\n                }\n\n                /*\n                 * Check if the last scalefactor band is distorted. in VBR mode\n                 * we can't get rid of the distortion, so quit now and VBR mode\n                 * will try again with more bits. (makes a 10% speed increase,\n                 * the files I tested were binary identical, 2000/05/20 Robert\n                 * Hegemann) distort[] > 1 means noise > allowed noise\n                 */\n                if (gfc.sfb21_extra) {\n                    if (distort[cod_info_w.sfbmax] > 1.0)\n                        break;\n                    if (cod_info_w.block_type == Encoder.SHORT_TYPE\n                        && (distort[cod_info_w.sfbmax + 1] > 1.0 || distort[cod_info_w.sfbmax + 2] > 1.0))\n                        break;\n                }\n\n                /* try a new scalefactor conbination on cod_info_w */\n                if (!balance_noise(gfp, cod_info_w, distort, xrpow, bRefine))\n                    break;\n                if (cod_info_w.scalefac_scale != 0)\n                    maxggain = 254;\n\n                /*\n                 * inner_loop starts with the initial quantization step computed\n                 * above and slowly increases until the bits < huff_bits. Thus\n                 * it is important not to start with too large of an inital\n                 * quantization step. Too small is ok, but inner_loop will take\n                 * longer\n                 */\n                var huff_bits = targ_bits - cod_info_w.part2_length;\n                if (huff_bits <= 0)\n                    break;\n\n                /*\n                 * increase quantizer stepsize until needed bits are below\n                 * maximum\n                 */\n                while ((cod_info_w.part2_3_length = tk.count_bits(gfc, xrpow,\n                    cod_info_w, prev_noise)) > huff_bits\n                && cod_info_w.global_gain <= maxggain)\n                    cod_info_w.global_gain++;\n\n                if (cod_info_w.global_gain > maxggain)\n                    break;\n\n                if (best_noise_info.over_count == 0) {\n\n                    while ((cod_info_w.part2_3_length = tk.count_bits(gfc,\n                        xrpow, cod_info_w, prev_noise)) > best_part2_3_length\n                    && cod_info_w.global_gain <= maxggain)\n                        cod_info_w.global_gain++;\n\n                    if (cod_info_w.global_gain > maxggain)\n                        break;\n                }\n\n                /* compute the distortion in this quantization */\n                qupvt.calc_noise(cod_info_w, l3_xmin, distort, noise_info,\n                    prev_noise);\n                noise_info.bits = cod_info_w.part2_3_length;\n\n                /*\n                 * check if this quantization is better than our saved\n                 * quantization\n                 */\n                if (cod_info.block_type != Encoder.SHORT_TYPE) {\n                    // NORM, START or STOP type\n                    better = gfp.quant_comp;\n                } else\n                    better = gfp.quant_comp_short;\n\n                better = quant_compare(better, best_noise_info, noise_info,\n                    cod_info_w, distort) ? 1 : 0;\n\n                /* save data so we can restore this quantization later */\n                if (better != 0) {\n                    best_part2_3_length = cod_info.part2_3_length;\n                    best_noise_info = noise_info;\n                    cod_info.assign(cod_info_w);\n                    age = 0;\n                    /* save data so we can restore this quantization later */\n                    /* store for later reuse */\n                    System.arraycopy(xrpow, 0, save_xrpow, 0, 576);\n                } else {\n                    /* early stop? */\n                    if (gfc.full_outer_loop == 0) {\n                        if (++age > search_limit\n                            && best_noise_info.over_count == 0)\n                            break;\n                        if ((gfc.noise_shaping_amp == 3) && bRefine && age > 30)\n                            break;\n                        if ((gfc.noise_shaping_amp == 3)\n                            && bRefine\n                            && (cod_info_w.global_gain - best_ggain_pass1) > 15)\n                            break;\n                    }\n                }\n            } while ((cod_info_w.global_gain + cod_info_w.scalefac_scale) < 255);\n\n            if (gfc.noise_shaping_amp == 3) {\n                if (!bRefine) {\n                    /* refine search */\n                    cod_info_w.assign(cod_info);\n                    System.arraycopy(save_xrpow, 0, xrpow, 0, 576);\n                    age = 0;\n                    best_ggain_pass1 = cod_info_w.global_gain;\n\n                    bRefine = true;\n                } else {\n                    /* search already refined, stop */\n                    bEndOfSearch = true;\n                }\n\n            } else {\n                bEndOfSearch = true;\n            }\n        }\n\n        assert((cod_info.global_gain + cod_info.scalefac_scale) <= 255);\n        /*\n         * finish up\n         */\n        if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh)\n        /* restore for reuse on next try */\n            System.arraycopy(save_xrpow, 0, xrpow, 0, 576);\n        /*\n         * do the 'substep shaping'\n         */\n        else if ((gfc.substep_shaping & 1) != 0)\n            trancate_smallspectrums(gfc, cod_info, l3_xmin, xrpow);\n\n        return best_noise_info.over_count;\n    }\n\n    /**\n     * Robert Hegemann 2000-09-06\n     *\n     * update reservoir status after FINAL quantization/bitrate\n     */\n    this.iteration_finish_one = function (gfc, gr, ch) {\n        var l3_side = gfc.l3_side;\n        var cod_info = l3_side.tt[gr][ch];\n\n        /*\n         * try some better scalefac storage\n         */\n        tk.best_scalefac_store(gfc, gr, ch, l3_side);\n\n        /*\n         * best huffman_divide may save some bits too\n         */\n        if (gfc.use_best_huffman == 1)\n            tk.best_huffman_divide(gfc, cod_info);\n\n        /*\n         * update reservoir status after FINAL quantization/bitrate\n         */\n        rv.ResvAdjust(gfc, cod_info);\n    };\n\n    /**\n     *\n     * 2000-09-04 Robert Hegemann\n     *\n     * @param l3_xmin\n     *            allowed distortion of the scalefactor\n     * @param xrpow\n     *            coloured magnitudes of spectral values\n     */\n    this.VBR_encode_granule = function (gfp, cod_info, l3_xmin, xrpow, ch, min_bits, max_bits) {\n        var gfc = gfp.internal_flags;\n        var bst_cod_info = new GrInfo();\n        var bst_xrpow = new_float(576);\n        var Max_bits = max_bits;\n        var real_bits = max_bits + 1;\n        var this_bits = (max_bits + min_bits) / 2;\n        var dbits, over, found = 0;\n        var sfb21_extra = gfc.sfb21_extra;\n\n        assert(Max_bits <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n        Arrays.fill(bst_cod_info.l3_enc, 0);\n\n        /*\n         * search within round about 40 bits of optimal\n         */\n        do {\n            assert(this_bits >= min_bits);\n            assert(this_bits <= max_bits);\n            assert(min_bits <= max_bits);\n\n            if (this_bits > Max_bits - 42)\n                gfc.sfb21_extra = false;\n            else\n                gfc.sfb21_extra = sfb21_extra;\n\n            over = outer_loop(gfp, cod_info, l3_xmin, xrpow, ch, this_bits);\n\n            /*\n             * is quantization as good as we are looking for ? in this case: is\n             * no scalefactor band distorted?\n             */\n            if (over <= 0) {\n                found = 1;\n                /*\n                 * now we know it can be done with \"real_bits\" and maybe we can\n                 * skip some iterations\n                 */\n                real_bits = cod_info.part2_3_length;\n\n                /*\n                 * store best quantization so far\n                 */\n                bst_cod_info.assign(cod_info);\n                System.arraycopy(xrpow, 0, bst_xrpow, 0, 576);\n\n                /*\n                 * try with fewer bits\n                 */\n                max_bits = real_bits - 32;\n                dbits = max_bits - min_bits;\n                this_bits = (max_bits + min_bits) / 2;\n            } else {\n                /*\n                 * try with more bits\n                 */\n                min_bits = this_bits + 32;\n                dbits = max_bits - min_bits;\n                this_bits = (max_bits + min_bits) / 2;\n\n                if (found != 0) {\n                    found = 2;\n                    /*\n                     * start again with best quantization so far\n                     */\n                    cod_info.assign(bst_cod_info);\n                    System.arraycopy(bst_xrpow, 0, xrpow, 0, 576);\n                }\n            }\n        } while (dbits > 12);\n\n        gfc.sfb21_extra = sfb21_extra;\n\n        /*\n         * found=0 => nothing found, use last one found=1 => we just found the\n         * best and left the loop found=2 => we restored a good one and have now\n         * l3_enc to restore too\n         */\n        if (found == 2) {\n            System.arraycopy(bst_cod_info.l3_enc, 0, cod_info.l3_enc, 0, 576);\n        }\n        assert(cod_info.part2_3_length <= Max_bits);\n    }\n\n    /**\n     * Robert Hegemann 2000-09-05\n     *\n     * calculates * how many bits are available for analog silent granules * how\n     * many bits to use for the lowest allowed bitrate * how many bits each\n     * bitrate would provide\n     */\n    this.get_framebits = function (gfp, frameBits) {\n        var gfc = gfp.internal_flags;\n\n        /*\n         * always use at least this many bits per granule per channel unless we\n         * detect analog silence, see below\n         */\n        gfc.bitrate_index = gfc.VBR_min_bitrate;\n        var bitsPerFrame = bs.getframebits(gfp);\n\n        /*\n         * bits for analog silence\n         */\n        gfc.bitrate_index = 1;\n        bitsPerFrame = bs.getframebits(gfp);\n\n        for (var i = 1; i <= gfc.VBR_max_bitrate; i++) {\n            gfc.bitrate_index = i;\n            var mb = new MeanBits(bitsPerFrame);\n            frameBits[i] = rv.ResvFrameBegin(gfp, mb);\n            bitsPerFrame = mb.bits;\n        }\n    };\n\n    /* RH: this one needs to be overhauled sometime */\n\n    /**\n     * <PRE>\n     *  2000-09-04 Robert Hegemann\n     *\n     *  * converts LR to MS coding when necessary\n     *  * calculates allowed/adjusted quantization noise amounts\n     *  * detects analog silent frames\n     *\n     *  some remarks:\n     *  - lower masking depending on Quality setting\n     *  - quality control together with adjusted ATH MDCT scaling\n     *    on lower quality setting allocate more noise from\n     *    ATH masking, and on higher quality setting allocate\n     *    less noise from ATH masking.\n     *  - experiments show that going more than 2dB over GPSYCHO's\n     *    limits ends up in very annoying artefacts\n     * </PRE>\n     */\n    this.VBR_old_prepare = function (gfp, pe, ms_ener_ratio, ratio, l3_xmin, frameBits, min_bits,\n                                     max_bits, bands) {\n        var gfc = gfp.internal_flags;\n\n        var masking_lower_db, adjust = 0.0;\n        var analog_silence = 1;\n        var bits = 0;\n\n        gfc.bitrate_index = gfc.VBR_max_bitrate;\n        var avg = rv.ResvFrameBegin(gfp, new MeanBits(0)) / gfc.mode_gr;\n\n        get_framebits(gfp, frameBits);\n\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            var mxb = qupvt.on_pe(gfp, pe, max_bits[gr], avg, gr, 0);\n            if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) {\n                ms_convert(gfc.l3_side, gr);\n                qupvt.reduce_side(max_bits[gr], ms_ener_ratio[gr], avg, mxb);\n            }\n            for (var ch = 0; ch < gfc.channels_out; ++ch) {\n                var cod_info = gfc.l3_side.tt[gr][ch];\n\n                if (cod_info.block_type != Encoder.SHORT_TYPE) {\n                    // NORM, START or STOP type\n                    adjust = 1.28 / (1 + Math\n                            .exp(3.5 - pe[gr][ch] / 300.)) - 0.05;\n                    masking_lower_db = gfc.PSY.mask_adjust - adjust;\n                } else {\n                    adjust = 2.56 / (1 + Math\n                            .exp(3.5 - pe[gr][ch] / 300.)) - 0.14;\n                    masking_lower_db = gfc.PSY.mask_adjust_short - adjust;\n                }\n                gfc.masking_lower = Math.pow(10.0,\n                    masking_lower_db * 0.1);\n\n                init_outer_loop(gfc, cod_info);\n                bands[gr][ch] = qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info,\n                    l3_xmin[gr][ch]);\n                if (bands[gr][ch] != 0)\n                    analog_silence = 0;\n\n                min_bits[gr][ch] = 126;\n\n                bits += max_bits[gr][ch];\n            }\n        }\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                if (bits > frameBits[gfc.VBR_max_bitrate]) {\n                    max_bits[gr][ch] *= frameBits[gfc.VBR_max_bitrate];\n                    max_bits[gr][ch] /= bits;\n                }\n                if (min_bits[gr][ch] > max_bits[gr][ch])\n                    min_bits[gr][ch] = max_bits[gr][ch];\n\n            }\n            /* for ch */\n        }\n        /* for gr */\n\n        return analog_silence;\n    };\n\n    this.bitpressure_strategy = function (gfc, l3_xmin, min_bits, max_bits) {\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                var gi = gfc.l3_side.tt[gr][ch];\n                var pxmin = l3_xmin[gr][ch];\n                var pxminPos = 0;\n                for (var sfb = 0; sfb < gi.psy_lmax; sfb++)\n                    pxmin[pxminPos++] *= 1. + .029 * sfb * sfb\n                        / Encoder.SBMAX_l / Encoder.SBMAX_l;\n\n                if (gi.block_type == Encoder.SHORT_TYPE) {\n                    for (var sfb = gi.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n                        pxmin[pxminPos++] *= 1. + .029 * sfb * sfb\n                            / Encoder.SBMAX_s / Encoder.SBMAX_s;\n                        pxmin[pxminPos++] *= 1. + .029 * sfb * sfb\n                            / Encoder.SBMAX_s / Encoder.SBMAX_s;\n                        pxmin[pxminPos++] *= 1. + .029 * sfb * sfb\n                            / Encoder.SBMAX_s / Encoder.SBMAX_s;\n                    }\n                }\n                max_bits[gr][ch] = 0 | Math.max(min_bits[gr][ch],\n                        0.9 * max_bits[gr][ch]);\n            }\n        }\n    };\n\n    this.VBR_new_prepare = function (gfp, pe, ratio, l3_xmin, frameBits, max_bits) {\n        var gfc = gfp.internal_flags;\n\n        var analog_silence = 1;\n        var avg = 0, bits = 0;\n        var maximum_framebits;\n\n        if (!gfp.free_format) {\n            gfc.bitrate_index = gfc.VBR_max_bitrate;\n\n            var mb = new MeanBits(avg);\n            rv.ResvFrameBegin(gfp, mb);\n            avg = mb.bits;\n\n            get_framebits(gfp, frameBits);\n            maximum_framebits = frameBits[gfc.VBR_max_bitrate];\n        } else {\n            gfc.bitrate_index = 0;\n            var mb = new MeanBits(avg);\n            maximum_framebits = rv.ResvFrameBegin(gfp, mb);\n            avg = mb.bits;\n            frameBits[0] = maximum_framebits;\n        }\n\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            qupvt.on_pe(gfp, pe, max_bits[gr], avg, gr, 0);\n            if (gfc.mode_ext == Encoder.MPG_MD_MS_LR) {\n                ms_convert(gfc.l3_side, gr);\n            }\n            for (var ch = 0; ch < gfc.channels_out; ++ch) {\n                var cod_info = gfc.l3_side.tt[gr][ch];\n\n                gfc.masking_lower = Math.pow(10.0,\n                    gfc.PSY.mask_adjust * 0.1);\n\n                init_outer_loop(gfc, cod_info);\n                if (0 != qupvt.calc_xmin(gfp, ratio[gr][ch], cod_info,\n                        l3_xmin[gr][ch]))\n                    analog_silence = 0;\n\n                bits += max_bits[gr][ch];\n            }\n        }\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                if (bits > maximum_framebits) {\n                    max_bits[gr][ch] *= maximum_framebits;\n                    max_bits[gr][ch] /= bits;\n                }\n\n            }\n            /* for ch */\n        }\n        /* for gr */\n\n        return analog_silence;\n    };\n\n    /**\n     * calculates target bits for ABR encoding\n     *\n     * mt 2000/05/31\n     */\n    this.calc_target_bits = function (gfp, pe, ms_ener_ratio, targ_bits, analog_silence_bits, max_frame_bits) {\n        var gfc = gfp.internal_flags;\n        var l3_side = gfc.l3_side;\n        var res_factor;\n        var gr, ch, totbits, mean_bits = 0;\n\n        gfc.bitrate_index = gfc.VBR_max_bitrate;\n        var mb = new MeanBits(mean_bits);\n        max_frame_bits[0] = rv.ResvFrameBegin(gfp, mb);\n        mean_bits = mb.bits;\n\n        gfc.bitrate_index = 1;\n        mean_bits = bs.getframebits(gfp) - gfc.sideinfo_len * 8;\n        analog_silence_bits[0] = mean_bits / (gfc.mode_gr * gfc.channels_out);\n\n        mean_bits = gfp.VBR_mean_bitrate_kbps * gfp.framesize * 1000;\n        if ((gfc.substep_shaping & 1) != 0)\n            mean_bits *= 1.09;\n        mean_bits /= gfp.out_samplerate;\n        mean_bits -= gfc.sideinfo_len * 8;\n        mean_bits /= (gfc.mode_gr * gfc.channels_out);\n\n        /**\n         * <PRE>\n         *           res_factor is the percentage of the target bitrate that should\n         *           be used on average.  the remaining bits are added to the\n         *           bitreservoir and used for difficult to encode frames.\n         *\n         *           Since we are tracking the average bitrate, we should adjust\n         *           res_factor \"on the fly\", increasing it if the average bitrate\n         *           is greater than the requested bitrate, and decreasing it\n         *           otherwise.  Reasonable ranges are from .9 to 1.0\n         *\n         *           Until we get the above suggestion working, we use the following\n         *           tuning:\n         *           compression ratio    res_factor\n         *           5.5  (256kbps)         1.0      no need for bitreservoir\n         *           11   (128kbps)         .93      7% held for reservoir\n         *\n         *           with linear interpolation for other values.\n         * </PRE>\n         */\n        res_factor = .93 + .07 * (11.0 - gfp.compression_ratio)\n            / (11.0 - 5.5);\n        if (res_factor < .90)\n            res_factor = .90;\n        if (res_factor > 1.00)\n            res_factor = 1.00;\n\n        for (gr = 0; gr < gfc.mode_gr; gr++) {\n            var sum = 0;\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                targ_bits[gr][ch] = (int)(res_factor * mean_bits);\n\n                if (pe[gr][ch] > 700) {\n                    var add_bits = (int)((pe[gr][ch] - 700) / 1.4);\n\n                    var cod_info = l3_side.tt[gr][ch];\n                    targ_bits[gr][ch] = (int)(res_factor * mean_bits);\n\n                    /* short blocks use a little extra, no matter what the pe */\n                    if (cod_info.block_type == Encoder.SHORT_TYPE) {\n                        if (add_bits < mean_bits / 2)\n                            add_bits = mean_bits / 2;\n                    }\n                    /* at most increase bits by 1.5*average */\n                    if (add_bits > mean_bits * 3 / 2)\n                        add_bits = mean_bits * 3 / 2;\n                    else if (add_bits < 0)\n                        add_bits = 0;\n\n                    targ_bits[gr][ch] += add_bits;\n                }\n                if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL) {\n                    targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;\n                }\n                sum += targ_bits[gr][ch];\n            }\n            /* for ch */\n            if (sum > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n                for (ch = 0; ch < gfc.channels_out; ++ch) {\n                    targ_bits[gr][ch] *= LameInternalFlags.MAX_BITS_PER_GRANULE;\n                    targ_bits[gr][ch] /= sum;\n                }\n            }\n        }\n        /* for gr */\n\n        if (gfc.mode_ext == Encoder.MPG_MD_MS_LR)\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                qupvt.reduce_side(targ_bits[gr], ms_ener_ratio[gr], mean_bits\n                    * gfc.channels_out,\n                    LameInternalFlags.MAX_BITS_PER_GRANULE);\n            }\n\n        /*\n         * sum target bits\n         */\n        totbits = 0;\n        for (gr = 0; gr < gfc.mode_gr; gr++) {\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                if (targ_bits[gr][ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL)\n                    targ_bits[gr][ch] = LameInternalFlags.MAX_BITS_PER_CHANNEL;\n                totbits += targ_bits[gr][ch];\n            }\n        }\n\n        /*\n         * repartion target bits if needed\n         */\n        if (totbits > max_frame_bits[0]) {\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    targ_bits[gr][ch] *= max_frame_bits[0];\n                    targ_bits[gr][ch] /= totbits;\n                }\n            }\n        }\n    }\n\n}\n\nmodule.exports = Quantize;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}