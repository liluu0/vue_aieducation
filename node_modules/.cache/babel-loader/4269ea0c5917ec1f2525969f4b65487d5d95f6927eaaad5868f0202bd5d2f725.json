{"ast":null,"code":"var common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\n/**\n * ENCDELAY The encoder delay.\n *\n * Minimum allowed is MDCTDELAY (see below)\n *\n * The first 96 samples will be attenuated, so using a value less than 96\n * will result in corrupt data for the first 96-ENCDELAY samples.\n *\n * suggested: 576 set to 1160 to sync with FhG.\n */\nEncoder.ENCDELAY = 576;\n/**\n * make sure there is at least one complete frame after the last frame\n * containing real data\n *\n * Using a value of 288 would be sufficient for a a very sophisticated\n * decoder that can decode granule-by-granule instead of frame by frame. But\n * lets not assume this, and assume the decoder will not decode frame N\n * unless it also has data for frame N+1\n */\nEncoder.POSTDELAY = 1152;\n\n/**\n * delay of the MDCT used in mdct.c original ISO routines had a delay of\n * 528! Takehiro's routines:\n */\nEncoder.MDCTDELAY = 48;\nEncoder.FFTOFFSET = 224 + Encoder.MDCTDELAY;\n\n/**\n * Most decoders, including the one we use, have a delay of 528 samples.\n */\nEncoder.DECDELAY = 528;\n\n/**\n * number of subbands\n */\nEncoder.SBLIMIT = 32;\n\n/**\n * parition bands bands\n */\nEncoder.CBANDS = 64;\n\n/**\n * number of critical bands/scale factor bands where masking is computed\n */\nEncoder.SBPSY_l = 21;\nEncoder.SBPSY_s = 12;\n\n/**\n * total number of scalefactor bands encoded\n */\nEncoder.SBMAX_l = 22;\nEncoder.SBMAX_s = 13;\nEncoder.PSFB21 = 6;\nEncoder.PSFB12 = 6;\n\n/**\n * FFT sizes\n */\nEncoder.BLKSIZE = 1024;\nEncoder.HBLKSIZE = Encoder.BLKSIZE / 2 + 1;\nEncoder.BLKSIZE_s = 256;\nEncoder.HBLKSIZE_s = Encoder.BLKSIZE_s / 2 + 1;\nEncoder.NORM_TYPE = 0;\nEncoder.START_TYPE = 1;\nEncoder.SHORT_TYPE = 2;\nEncoder.STOP_TYPE = 3;\n\n/**\n * <PRE>\n * Mode Extention:\n * When we are in stereo mode, there are 4 possible methods to store these\n * two channels. The stereo modes -m? are using a subset of them.\n *\n *  -ms: MPG_MD_LR_LR\n *  -mj: MPG_MD_LR_LR and MPG_MD_MS_LR\n *  -mf: MPG_MD_MS_LR\n *  -mi: all\n * </PRE>\n */\nEncoder.MPG_MD_LR_LR = 0;\nEncoder.MPG_MD_LR_I = 1;\nEncoder.MPG_MD_MS_LR = 2;\nEncoder.MPG_MD_MS_I = 3;\nEncoder.fircoef = [-0.0207887 * 5, -0.0378413 * 5, -0.0432472 * 5, -0.031183 * 5, 7.79609e-18 * 5, 0.0467745 * 5, 0.10091 * 5, 0.151365 * 5, 0.187098 * 5];\nfunction Encoder() {\n  var NewMDCT = require('./NewMDCT.js');\n  var III_psy_ratio = require('./III_psy_ratio.js');\n  var FFTOFFSET = Encoder.FFTOFFSET;\n  var MPG_MD_MS_LR = Encoder.MPG_MD_MS_LR;\n  //BitStream bs;\n  //PsyModel psy;\n  //VBRTag vbr;\n  //QuantizePVT qupvt;\n  var bs = null;\n  this.psy = null;\n  var psy = null;\n  var vbr = null;\n  var qupvt = null;\n\n  //public final void setModules(BitStream bs, PsyModel psy, QuantizePVT qupvt,\n  //    VBRTag vbr) {\n  this.setModules = function (_bs, _psy, _qupvt, _vbr) {\n    bs = _bs;\n    this.psy = _psy;\n    psy = _psy;\n    vbr = _vbr;\n    qupvt = _qupvt;\n  };\n  var newMDCT = new NewMDCT();\n\n  /***********************************************************************\n   *\n   * encoder and decoder delays\n   *\n   ***********************************************************************/\n\n  /**\n   * <PRE>\n   * layer III enc->dec delay:  1056 (1057?)   (observed)\n   * layer  II enc->dec delay:   480  (481?)   (observed)\n   *\n   * polyphase 256-16             (dec or enc)        = 240\n   * mdct      256+32  (9*32)     (dec or enc)        = 288\n   * total:    512+16\n   *\n   * My guess is that delay of polyphase filterbank is actualy 240.5\n   * (there are technical reasons for this, see postings in mp3encoder).\n   * So total Encode+Decode delay = ENCDELAY + 528 + 1\n   * </PRE>\n   */\n\n  /**\n   * auto-adjust of ATH, useful for low volume Gabriel Bouvigne 3 feb 2001\n   *\n   * modifies some values in gfp.internal_flags.ATH (gfc.ATH)\n   */\n  //private void adjust_ATH(final LameInternalFlags gfc) {\n  function adjust_ATH(gfc) {\n    var gr2_max, max_pow;\n    if (gfc.ATH.useAdjust == 0) {\n      gfc.ATH.adjust = 1.0;\n      /* no adjustment */\n      return;\n    }\n\n    /* jd - 2001 mar 12, 27, jun 30 */\n    /* loudness based on equal loudness curve; */\n    /* use granule with maximum combined loudness */\n    max_pow = gfc.loudness_sq[0][0];\n    gr2_max = gfc.loudness_sq[1][0];\n    if (gfc.channels_out == 2) {\n      max_pow += gfc.loudness_sq[0][1];\n      gr2_max += gfc.loudness_sq[1][1];\n    } else {\n      max_pow += max_pow;\n      gr2_max += gr2_max;\n    }\n    if (gfc.mode_gr == 2) {\n      max_pow = Math.max(max_pow, gr2_max);\n    }\n    max_pow *= 0.5;\n    /* max_pow approaches 1.0 for full band noise */\n\n    /* jd - 2001 mar 31, jun 30 */\n    /* user tuning of ATH adjustment region */\n    max_pow *= gfc.ATH.aaSensitivityP;\n\n    /*\n     * adjust ATH depending on range of maximum value\n     */\n\n    /* jd - 2001 feb27, mar12,20, jun30, jul22 */\n    /* continuous curves based on approximation */\n    /* to GB's original values. */\n    /* For an increase in approximate loudness, */\n    /* set ATH adjust to adjust_limit immediately */\n    /* after a delay of one frame. */\n    /* For a loudness decrease, reduce ATH adjust */\n    /* towards adjust_limit gradually. */\n    /* max_pow is a loudness squared or a power. */\n    if (max_pow > 0.03125) {\n      /* ((1 - 0.000625)/ 31.98) from curve below */\n      if (gfc.ATH.adjust >= 1.0) {\n        gfc.ATH.adjust = 1.0;\n      } else {\n        /* preceding frame has lower ATH adjust; */\n        /* ascend only to the preceding adjust_limit */\n        /* in case there is leading low volume */\n        if (gfc.ATH.adjust < gfc.ATH.adjustLimit) {\n          gfc.ATH.adjust = gfc.ATH.adjustLimit;\n        }\n      }\n      gfc.ATH.adjustLimit = 1.0;\n    } else {\n      /* adjustment curve */\n      /* about 32 dB maximum adjust (0.000625) */\n      var adj_lim_new = 31.98 * max_pow + 0.000625;\n      if (gfc.ATH.adjust >= adj_lim_new) {\n        /* descend gradually */\n        gfc.ATH.adjust *= adj_lim_new * 0.075 + 0.925;\n        if (gfc.ATH.adjust < adj_lim_new) {\n          /* stop descent */\n          gfc.ATH.adjust = adj_lim_new;\n        }\n      } else {\n        /* ascend */\n        if (gfc.ATH.adjustLimit >= adj_lim_new) {\n          gfc.ATH.adjust = adj_lim_new;\n        } else {\n          /* preceding frame has lower ATH adjust; */\n          /* ascend only to the preceding adjust_limit */\n          if (gfc.ATH.adjust < gfc.ATH.adjustLimit) {\n            gfc.ATH.adjust = gfc.ATH.adjustLimit;\n          }\n        }\n      }\n      gfc.ATH.adjustLimit = adj_lim_new;\n    }\n  }\n\n  /**\n   * <PRE>\n   *  some simple statistics\n   *\n   *  bitrate index 0: free bitrate . not allowed in VBR mode\n   *  : bitrates, kbps depending on MPEG version\n   *  bitrate index 15: forbidden\n   *\n   *  mode_ext:\n   *  0:  LR\n   *  1:  LR-i\n   *  2:  MS\n   *  3:  MS-i\n   * </PRE>\n   */\n  function updateStats(gfc) {\n    var gr, ch;\n    assert(0 <= gfc.bitrate_index && gfc.bitrate_index < 16);\n    assert(0 <= gfc.mode_ext && gfc.mode_ext < 4);\n\n    /* count bitrate indices */\n    gfc.bitrate_stereoMode_Hist[gfc.bitrate_index][4]++;\n    gfc.bitrate_stereoMode_Hist[15][4]++;\n\n    /* count 'em for every mode extension in case of 2 channel encoding */\n    if (gfc.channels_out == 2) {\n      gfc.bitrate_stereoMode_Hist[gfc.bitrate_index][gfc.mode_ext]++;\n      gfc.bitrate_stereoMode_Hist[15][gfc.mode_ext]++;\n    }\n    for (gr = 0; gr < gfc.mode_gr; ++gr) {\n      for (ch = 0; ch < gfc.channels_out; ++ch) {\n        var bt = gfc.l3_side.tt[gr][ch].block_type | 0;\n        if (gfc.l3_side.tt[gr][ch].mixed_block_flag != 0) bt = 4;\n        gfc.bitrate_blockType_Hist[gfc.bitrate_index][bt]++;\n        gfc.bitrate_blockType_Hist[gfc.bitrate_index][5]++;\n        gfc.bitrate_blockType_Hist[15][bt]++;\n        gfc.bitrate_blockType_Hist[15][5]++;\n      }\n    }\n  }\n  function lame_encode_frame_init(gfp, inbuf) {\n    var gfc = gfp.internal_flags;\n    var ch, gr;\n    if (gfc.lame_encode_frame_init == 0) {\n      /* prime the MDCT/polyphase filterbank with a short block */\n      var i, j;\n      var primebuff0 = new_float(286 + 1152 + 576);\n      var primebuff1 = new_float(286 + 1152 + 576);\n      gfc.lame_encode_frame_init = 1;\n      for (i = 0, j = 0; i < 286 + 576 * (1 + gfc.mode_gr); ++i) {\n        if (i < 576 * gfc.mode_gr) {\n          primebuff0[i] = 0;\n          if (gfc.channels_out == 2) primebuff1[i] = 0;\n        } else {\n          primebuff0[i] = inbuf[0][j];\n          if (gfc.channels_out == 2) primebuff1[i] = inbuf[1][j];\n          ++j;\n        }\n      }\n      /* polyphase filtering / mdct */\n      for (gr = 0; gr < gfc.mode_gr; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          gfc.l3_side.tt[gr][ch].block_type = Encoder.SHORT_TYPE;\n        }\n      }\n      newMDCT.mdct_sub48(gfc, primebuff0, primebuff1);\n\n      /* check FFT will not use a negative starting offset */\n      assert(576 >= Encoder.FFTOFFSET);\n      /* check if we have enough data for FFT */\n      assert(gfc.mf_size >= Encoder.BLKSIZE + gfp.framesize - Encoder.FFTOFFSET);\n      /* check if we have enough data for polyphase filterbank */\n      assert(gfc.mf_size >= 512 + gfp.framesize - 32);\n    }\n  }\n\n  /**\n   * <PRE>\n   * encodeframe()           Layer 3\n   *\n   * encode a single frame\n   *\n   *\n   *    lame_encode_frame()\n   *\n   *\n   *                           gr 0            gr 1\n   *    inbuf:           |--------------|--------------|--------------|\n   *\n   *\n   *    Polyphase (18 windows, each shifted 32)\n   *    gr 0:\n   *    window1          <----512---.\n   *    window18                 <----512---.\n   *\n   *    gr 1:\n   *    window1                         <----512---.\n   *    window18                                <----512---.\n   *\n   *\n   *\n   *    MDCT output:  |--------------|--------------|--------------|\n   *\n   *    FFT's                    <---------1024---------.\n   *                                             <---------1024-------.\n   *\n   *\n   *\n   *        inbuf = buffer of PCM data size=MP3 framesize\n   *        encoder acts on inbuf[ch][0], but output is delayed by MDCTDELAY\n   *        so the MDCT coefficints are from inbuf[ch][-MDCTDELAY]\n   *\n   *        psy-model FFT has a 1 granule delay, so we feed it data for the\n   *        next granule.\n   *        FFT is centered over granule:  224+576+224\n   *        So FFT starts at:   576-224-MDCTDELAY\n   *\n   *        MPEG2:  FFT ends at:  BLKSIZE+576-224-MDCTDELAY      (1328)\n   *        MPEG1:  FFT ends at:  BLKSIZE+2*576-224-MDCTDELAY    (1904)\n   *\n   *        MPEG2:  polyphase first window:  [0..511]\n   *                          18th window:   [544..1055]          (1056)\n   *        MPEG1:            36th window:   [1120..1631]         (1632)\n   *                data needed:  512+framesize-32\n   *\n   *        A close look newmdct.c shows that the polyphase filterbank\n   *        only uses data from [0..510] for each window.  Perhaps because the window\n   *        used by the filterbank is zero for the last point, so Takehiro's\n   *        code doesn't bother to compute with it.\n   *\n   *        FFT starts at 576-224-MDCTDELAY (304)  = 576-FFTOFFSET\n   *\n   * </PRE>\n   */\n\n  this.lame_encode_mp3_frame = function (gfp, inbuf_l, inbuf_r, mp3buf, mp3bufPos, mp3buf_size) {\n    var mp3count;\n    var masking_LR = new_array_n([2, 2]);\n    /*\n     * LR masking &\n     * energy\n     */\n    masking_LR[0][0] = new III_psy_ratio();\n    masking_LR[0][1] = new III_psy_ratio();\n    masking_LR[1][0] = new III_psy_ratio();\n    masking_LR[1][1] = new III_psy_ratio();\n    var masking_MS = new_array_n([2, 2]);\n    /* MS masking & energy */\n    masking_MS[0][0] = new III_psy_ratio();\n    masking_MS[0][1] = new III_psy_ratio();\n    masking_MS[1][0] = new III_psy_ratio();\n    masking_MS[1][1] = new III_psy_ratio();\n    //III_psy_ratio masking[][];\n    var masking;\n    /* pointer to selected maskings */\n    var inbuf = [null, null];\n    var gfc = gfp.internal_flags;\n    var tot_ener = new_float_n([2, 4]);\n    var ms_ener_ratio = [.5, .5];\n    var pe = [[0., 0.], [0., 0.]];\n    var pe_MS = [[0., 0.], [0., 0.]];\n\n    //float[][] pe_use;\n    var pe_use;\n    var ch, gr;\n    inbuf[0] = inbuf_l;\n    inbuf[1] = inbuf_r;\n    if (gfc.lame_encode_frame_init == 0) {\n      /* first run? */\n      lame_encode_frame_init(gfp, inbuf);\n    }\n\n    /********************** padding *****************************/\n    /**\n     * <PRE>\n     * padding method as described in\n     * \"MPEG-Layer3 / Bitstream Syntax and Decoding\"\n     * by Martin Sieler, Ralph Sperschneider\n     *\n     * note: there is no padding for the very first frame\n     *\n     * Robert Hegemann 2000-06-22\n     * </PRE>\n     */\n    gfc.padding = 0;\n    if ((gfc.slot_lag -= gfc.frac_SpF) < 0) {\n      gfc.slot_lag += gfp.out_samplerate;\n      gfc.padding = 1;\n    }\n\n    /****************************************\n     * Stage 1: psychoacoustic model *\n     ****************************************/\n\n    if (gfc.psymodel != 0) {\n      /*\n       * psychoacoustic model psy model has a 1 granule (576) delay that\n       * we must compensate for (mt 6/99).\n       */\n      var ret;\n      var bufp = [null, null];\n      /* address of beginning of left & right granule */\n      var bufpPos = 0;\n      /* address of beginning of left & right granule */\n      var blocktype = new_int(2);\n      for (gr = 0; gr < gfc.mode_gr; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          bufp[ch] = inbuf[ch];\n          bufpPos = 576 + gr * 576 - Encoder.FFTOFFSET;\n        }\n        if (gfp.VBR == VbrMode.vbr_mtrh || gfp.VBR == VbrMode.vbr_mt) {\n          ret = psy.L3psycho_anal_vbr(gfp, bufp, bufpPos, gr, masking_LR, masking_MS, pe[gr], pe_MS[gr], tot_ener[gr], blocktype);\n        } else {\n          ret = psy.L3psycho_anal_ns(gfp, bufp, bufpPos, gr, masking_LR, masking_MS, pe[gr], pe_MS[gr], tot_ener[gr], blocktype);\n        }\n        if (ret != 0) return -4;\n        if (gfp.mode == MPEGMode.JOINT_STEREO) {\n          ms_ener_ratio[gr] = tot_ener[gr][2] + tot_ener[gr][3];\n          if (ms_ener_ratio[gr] > 0) ms_ener_ratio[gr] = tot_ener[gr][3] / ms_ener_ratio[gr];\n        }\n\n        /* block type flags */\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          var cod_info = gfc.l3_side.tt[gr][ch];\n          cod_info.block_type = blocktype[ch];\n          cod_info.mixed_block_flag = 0;\n        }\n      }\n    } else {\n      /* no psy model */\n      for (gr = 0; gr < gfc.mode_gr; gr++) for (ch = 0; ch < gfc.channels_out; ch++) {\n        gfc.l3_side.tt[gr][ch].block_type = Encoder.NORM_TYPE;\n        gfc.l3_side.tt[gr][ch].mixed_block_flag = 0;\n        pe_MS[gr][ch] = pe[gr][ch] = 700;\n      }\n    }\n\n    /* auto-adjust of ATH, useful for low volume */\n    adjust_ATH(gfc);\n\n    /****************************************\n     * Stage 2: MDCT *\n     ****************************************/\n\n    /* polyphase filtering / mdct */\n    newMDCT.mdct_sub48(gfc, inbuf[0], inbuf[1]);\n\n    /****************************************\n     * Stage 3: MS/LR decision *\n     ****************************************/\n\n    /* Here will be selected MS or LR coding of the 2 stereo channels */\n    gfc.mode_ext = Encoder.MPG_MD_LR_LR;\n    if (gfp.force_ms) {\n      gfc.mode_ext = Encoder.MPG_MD_MS_LR;\n    } else if (gfp.mode == MPEGMode.JOINT_STEREO) {\n      /*\n       * ms_ratio = is scaled, for historical reasons, to look like a\n       * ratio of side_channel / total. 0 = signal is 100% mono .5 = L & R\n       * uncorrelated\n       */\n\n      /**\n       * <PRE>\n       * [0] and [1] are the results for the two granules in MPEG-1,\n       * in MPEG-2 it's only a faked averaging of the same value\n       * _prev is the value of the last granule of the previous frame\n       * _next is the value of the first granule of the next frame\n       * </PRE>\n       */\n\n      var sum_pe_MS = 0.;\n      var sum_pe_LR = 0.;\n      for (gr = 0; gr < gfc.mode_gr; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          sum_pe_MS += pe_MS[gr][ch];\n          sum_pe_LR += pe[gr][ch];\n        }\n      }\n\n      /* based on PE: M/S coding would not use much more bits than L/R */\n      if (sum_pe_MS <= 1.00 * sum_pe_LR) {\n        var gi0 = gfc.l3_side.tt[0];\n        var gi1 = gfc.l3_side.tt[gfc.mode_gr - 1];\n        if (gi0[0].block_type == gi0[1].block_type && gi1[0].block_type == gi1[1].block_type) {\n          gfc.mode_ext = Encoder.MPG_MD_MS_LR;\n        }\n      }\n    }\n\n    /* bit and noise allocation */\n    if (gfc.mode_ext == MPG_MD_MS_LR) {\n      masking = masking_MS;\n      /* use MS masking */\n      pe_use = pe_MS;\n    } else {\n      masking = masking_LR;\n      /* use LR masking */\n      pe_use = pe;\n    }\n\n    /* copy data for MP3 frame analyzer */\n    if (gfp.analysis && gfc.pinfo != null) {\n      for (gr = 0; gr < gfc.mode_gr; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          gfc.pinfo.ms_ratio[gr] = gfc.ms_ratio[gr];\n          gfc.pinfo.ms_ener_ratio[gr] = ms_ener_ratio[gr];\n          gfc.pinfo.blocktype[gr][ch] = gfc.l3_side.tt[gr][ch].block_type;\n          gfc.pinfo.pe[gr][ch] = pe_use[gr][ch];\n          System.arraycopy(gfc.l3_side.tt[gr][ch].xr, 0, gfc.pinfo.xr[gr][ch], 0, 576);\n          /*\n           * in psymodel, LR and MS data was stored in pinfo. switch\n           * to MS data:\n           */\n          if (gfc.mode_ext == MPG_MD_MS_LR) {\n            gfc.pinfo.ers[gr][ch] = gfc.pinfo.ers[gr][ch + 2];\n            System.arraycopy(gfc.pinfo.energy[gr][ch + 2], 0, gfc.pinfo.energy[gr][ch], 0, gfc.pinfo.energy[gr][ch].length);\n          }\n        }\n      }\n    }\n\n    /****************************************\n     * Stage 4: quantization loop *\n     ****************************************/\n\n    if (gfp.VBR == VbrMode.vbr_off || gfp.VBR == VbrMode.vbr_abr) {\n      var i;\n      var f;\n      for (i = 0; i < 18; i++) gfc.nsPsy.pefirbuf[i] = gfc.nsPsy.pefirbuf[i + 1];\n      f = 0.0;\n      for (gr = 0; gr < gfc.mode_gr; gr++) for (ch = 0; ch < gfc.channels_out; ch++) f += pe_use[gr][ch];\n      gfc.nsPsy.pefirbuf[18] = f;\n      f = gfc.nsPsy.pefirbuf[9];\n      for (i = 0; i < 9; i++) f += (gfc.nsPsy.pefirbuf[i] + gfc.nsPsy.pefirbuf[18 - i]) * Encoder.fircoef[i];\n      f = 670 * 5 * gfc.mode_gr * gfc.channels_out / f;\n      for (gr = 0; gr < gfc.mode_gr; gr++) {\n        for (ch = 0; ch < gfc.channels_out; ch++) {\n          pe_use[gr][ch] *= f;\n        }\n      }\n    }\n    gfc.iteration_loop.iteration_loop(gfp, pe_use, ms_ener_ratio, masking);\n\n    /****************************************\n     * Stage 5: bitstream formatting *\n     ****************************************/\n\n    /* write the frame to the bitstream */\n    bs.format_bitstream(gfp);\n\n    /* copy mp3 bit buffer into array */\n    mp3count = bs.copy_buffer(gfc, mp3buf, mp3bufPos, mp3buf_size, 1);\n    if (gfp.bWriteVbrTag) vbr.addVbrFrame(gfp);\n    if (gfp.analysis && gfc.pinfo != null) {\n      for (ch = 0; ch < gfc.channels_out; ch++) {\n        var j;\n        for (j = 0; j < FFTOFFSET; j++) gfc.pinfo.pcmdata[ch][j] = gfc.pinfo.pcmdata[ch][j + gfp.framesize];\n        for (j = FFTOFFSET; j < 1600; j++) {\n          gfc.pinfo.pcmdata[ch][j] = inbuf[ch][j - FFTOFFSET];\n        }\n      }\n      qupvt.set_frame_pinfo(gfp, masking);\n    }\n    updateStats(gfc);\n    return mp3count;\n  };\n}\nmodule.exports = Encoder;","map":{"version":3,"names":["common","require","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","Encoder","ENCDELAY","POSTDELAY","MDCTDELAY","FFTOFFSET","DECDELAY","SBLIMIT","CBANDS","SBPSY_l","SBPSY_s","SBMAX_l","SBMAX_s","PSFB21","PSFB12","BLKSIZE","HBLKSIZE","BLKSIZE_s","HBLKSIZE_s","NORM_TYPE","START_TYPE","SHORT_TYPE","STOP_TYPE","MPG_MD_LR_LR","MPG_MD_LR_I","MPG_MD_MS_LR","MPG_MD_MS_I","fircoef","NewMDCT","III_psy_ratio","bs","psy","vbr","qupvt","setModules","_bs","_psy","_qupvt","_vbr","newMDCT","adjust_ATH","gfc","gr2_max","max_pow","ATH","useAdjust","adjust","loudness_sq","channels_out","mode_gr","Math","max","aaSensitivityP","adjustLimit","adj_lim_new","updateStats","gr","ch","bitrate_index","mode_ext","bitrate_stereoMode_Hist","bt","l3_side","tt","block_type","mixed_block_flag","bitrate_blockType_Hist","lame_encode_frame_init","gfp","inbuf","internal_flags","i","j","primebuff0","primebuff1","mdct_sub48","mf_size","framesize","lame_encode_mp3_frame","inbuf_l","inbuf_r","mp3buf","mp3bufPos","mp3buf_size","mp3count","masking_LR","masking_MS","masking","tot_ener","ms_ener_ratio","pe","pe_MS","pe_use","padding","slot_lag","frac_SpF","out_samplerate","psymodel","ret","bufp","bufpPos","blocktype","VBR","vbr_mtrh","vbr_mt","L3psycho_anal_vbr","L3psycho_anal_ns","mode","MPEGMode","JOINT_STEREO","cod_info","force_ms","sum_pe_MS","sum_pe_LR","gi0","gi1","analysis","pinfo","ms_ratio","arraycopy","xr","ers","energy","length","vbr_off","vbr_abr","f","nsPsy","pefirbuf","iteration_loop","format_bitstream","copy_buffer","bWriteVbrTag","addVbrFrame","pcmdata","set_frame_pinfo","module","exports"],"sources":["D:/代码/vscodeProjects/AiEducation/vue_aieducation/node_modules/lamejs/src/js/Encoder.js"],"sourcesContent":["var common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\n/**\n * ENCDELAY The encoder delay.\n *\n * Minimum allowed is MDCTDELAY (see below)\n *\n * The first 96 samples will be attenuated, so using a value less than 96\n * will result in corrupt data for the first 96-ENCDELAY samples.\n *\n * suggested: 576 set to 1160 to sync with FhG.\n */\nEncoder.ENCDELAY = 576;\n/**\n * make sure there is at least one complete frame after the last frame\n * containing real data\n *\n * Using a value of 288 would be sufficient for a a very sophisticated\n * decoder that can decode granule-by-granule instead of frame by frame. But\n * lets not assume this, and assume the decoder will not decode frame N\n * unless it also has data for frame N+1\n */\nEncoder.POSTDELAY = 1152;\n\n/**\n * delay of the MDCT used in mdct.c original ISO routines had a delay of\n * 528! Takehiro's routines:\n */\nEncoder.MDCTDELAY = 48;\nEncoder.FFTOFFSET = (224 + Encoder.MDCTDELAY);\n\n/**\n * Most decoders, including the one we use, have a delay of 528 samples.\n */\nEncoder.DECDELAY = 528;\n\n/**\n * number of subbands\n */\nEncoder.SBLIMIT = 32;\n\n/**\n * parition bands bands\n */\nEncoder.CBANDS = 64;\n\n/**\n * number of critical bands/scale factor bands where masking is computed\n */\nEncoder.SBPSY_l = 21;\nEncoder.SBPSY_s = 12;\n\n/**\n * total number of scalefactor bands encoded\n */\nEncoder.SBMAX_l = 22;\nEncoder.SBMAX_s = 13;\nEncoder.PSFB21 = 6;\nEncoder.PSFB12 = 6;\n\n/**\n * FFT sizes\n */\nEncoder.BLKSIZE = 1024;\nEncoder.HBLKSIZE = (Encoder.BLKSIZE / 2 + 1);\nEncoder.BLKSIZE_s = 256;\nEncoder.HBLKSIZE_s = (Encoder.BLKSIZE_s / 2 + 1);\n\nEncoder.NORM_TYPE = 0;\nEncoder.START_TYPE = 1;\nEncoder.SHORT_TYPE = 2;\nEncoder.STOP_TYPE = 3;\n\n/**\n * <PRE>\n * Mode Extention:\n * When we are in stereo mode, there are 4 possible methods to store these\n * two channels. The stereo modes -m? are using a subset of them.\n *\n *  -ms: MPG_MD_LR_LR\n *  -mj: MPG_MD_LR_LR and MPG_MD_MS_LR\n *  -mf: MPG_MD_MS_LR\n *  -mi: all\n * </PRE>\n */\nEncoder.MPG_MD_LR_LR = 0;\nEncoder.MPG_MD_LR_I = 1;\nEncoder.MPG_MD_MS_LR = 2;\nEncoder.MPG_MD_MS_I = 3;\n\nEncoder.fircoef = [-0.0207887 * 5, -0.0378413 * 5,\n    -0.0432472 * 5, -0.031183 * 5, 7.79609e-18 * 5, 0.0467745 * 5,\n    0.10091 * 5, 0.151365 * 5, 0.187098 * 5];\n\nfunction Encoder() {\n    var NewMDCT = require('./NewMDCT.js');\n    var III_psy_ratio = require('./III_psy_ratio.js');\n\n    var FFTOFFSET = Encoder.FFTOFFSET;\n    var MPG_MD_MS_LR = Encoder.MPG_MD_MS_LR;\n    //BitStream bs;\n    //PsyModel psy;\n    //VBRTag vbr;\n    //QuantizePVT qupvt;\n    var bs = null;\n    this.psy = null;\n    var psy = null;\n    var vbr = null;\n    var qupvt = null;\n\n    //public final void setModules(BitStream bs, PsyModel psy, QuantizePVT qupvt,\n    //    VBRTag vbr) {\n    this.setModules = function (_bs, _psy, _qupvt, _vbr) {\n        bs = _bs;\n        this.psy = _psy;\n        psy = _psy;\n        vbr = _vbr;\n        qupvt = _qupvt;\n    };\n\n    var newMDCT = new NewMDCT();\n\n    /***********************************************************************\n     *\n     * encoder and decoder delays\n     *\n     ***********************************************************************/\n\n    /**\n     * <PRE>\n     * layer III enc->dec delay:  1056 (1057?)   (observed)\n     * layer  II enc->dec delay:   480  (481?)   (observed)\n     *\n     * polyphase 256-16             (dec or enc)        = 240\n     * mdct      256+32  (9*32)     (dec or enc)        = 288\n     * total:    512+16\n     *\n     * My guess is that delay of polyphase filterbank is actualy 240.5\n     * (there are technical reasons for this, see postings in mp3encoder).\n     * So total Encode+Decode delay = ENCDELAY + 528 + 1\n     * </PRE>\n     */\n\n\n    /**\n     * auto-adjust of ATH, useful for low volume Gabriel Bouvigne 3 feb 2001\n     *\n     * modifies some values in gfp.internal_flags.ATH (gfc.ATH)\n     */\n//private void adjust_ATH(final LameInternalFlags gfc) {\n    function adjust_ATH(gfc) {\n        var gr2_max, max_pow;\n\n        if (gfc.ATH.useAdjust == 0) {\n            gfc.ATH.adjust = 1.0;\n            /* no adjustment */\n            return;\n        }\n\n        /* jd - 2001 mar 12, 27, jun 30 */\n        /* loudness based on equal loudness curve; */\n        /* use granule with maximum combined loudness */\n        max_pow = gfc.loudness_sq[0][0];\n        gr2_max = gfc.loudness_sq[1][0];\n        if (gfc.channels_out == 2) {\n            max_pow += gfc.loudness_sq[0][1];\n            gr2_max += gfc.loudness_sq[1][1];\n        } else {\n            max_pow += max_pow;\n            gr2_max += gr2_max;\n        }\n        if (gfc.mode_gr == 2) {\n            max_pow = Math.max(max_pow, gr2_max);\n        }\n        max_pow *= 0.5;\n        /* max_pow approaches 1.0 for full band noise */\n\n        /* jd - 2001 mar 31, jun 30 */\n        /* user tuning of ATH adjustment region */\n        max_pow *= gfc.ATH.aaSensitivityP;\n\n        /*\n         * adjust ATH depending on range of maximum value\n         */\n\n        /* jd - 2001 feb27, mar12,20, jun30, jul22 */\n        /* continuous curves based on approximation */\n        /* to GB's original values. */\n        /* For an increase in approximate loudness, */\n        /* set ATH adjust to adjust_limit immediately */\n        /* after a delay of one frame. */\n        /* For a loudness decrease, reduce ATH adjust */\n        /* towards adjust_limit gradually. */\n        /* max_pow is a loudness squared or a power. */\n        if (max_pow > 0.03125) { /* ((1 - 0.000625)/ 31.98) from curve below */\n            if (gfc.ATH.adjust >= 1.0) {\n                gfc.ATH.adjust = 1.0;\n            } else {\n                /* preceding frame has lower ATH adjust; */\n                /* ascend only to the preceding adjust_limit */\n                /* in case there is leading low volume */\n                if (gfc.ATH.adjust < gfc.ATH.adjustLimit) {\n                    gfc.ATH.adjust = gfc.ATH.adjustLimit;\n                }\n            }\n            gfc.ATH.adjustLimit = 1.0;\n        } else { /* adjustment curve */\n            /* about 32 dB maximum adjust (0.000625) */\n            var adj_lim_new = 31.98 * max_pow + 0.000625;\n            if (gfc.ATH.adjust >= adj_lim_new) { /* descend gradually */\n                gfc.ATH.adjust *= adj_lim_new * 0.075 + 0.925;\n                if (gfc.ATH.adjust < adj_lim_new) { /* stop descent */\n                    gfc.ATH.adjust = adj_lim_new;\n                }\n            } else { /* ascend */\n                if (gfc.ATH.adjustLimit >= adj_lim_new) {\n                    gfc.ATH.adjust = adj_lim_new;\n                } else {\n                    /* preceding frame has lower ATH adjust; */\n                    /* ascend only to the preceding adjust_limit */\n                    if (gfc.ATH.adjust < gfc.ATH.adjustLimit) {\n                        gfc.ATH.adjust = gfc.ATH.adjustLimit;\n                    }\n                }\n            }\n            gfc.ATH.adjustLimit = adj_lim_new;\n        }\n    }\n\n    /**\n     * <PRE>\n     *  some simple statistics\n     *\n     *  bitrate index 0: free bitrate . not allowed in VBR mode\n     *  : bitrates, kbps depending on MPEG version\n     *  bitrate index 15: forbidden\n     *\n     *  mode_ext:\n     *  0:  LR\n     *  1:  LR-i\n     *  2:  MS\n     *  3:  MS-i\n     * </PRE>\n     */\n    function updateStats(gfc) {\n        var gr, ch;\n        assert(0 <= gfc.bitrate_index && gfc.bitrate_index < 16);\n        assert(0 <= gfc.mode_ext && gfc.mode_ext < 4);\n\n        /* count bitrate indices */\n        gfc.bitrate_stereoMode_Hist[gfc.bitrate_index][4]++;\n        gfc.bitrate_stereoMode_Hist[15][4]++;\n\n        /* count 'em for every mode extension in case of 2 channel encoding */\n        if (gfc.channels_out == 2) {\n            gfc.bitrate_stereoMode_Hist[gfc.bitrate_index][gfc.mode_ext]++;\n            gfc.bitrate_stereoMode_Hist[15][gfc.mode_ext]++;\n        }\n        for (gr = 0; gr < gfc.mode_gr; ++gr) {\n            for (ch = 0; ch < gfc.channels_out; ++ch) {\n                var bt = gfc.l3_side.tt[gr][ch].block_type | 0;\n                if (gfc.l3_side.tt[gr][ch].mixed_block_flag != 0)\n                    bt = 4;\n                gfc.bitrate_blockType_Hist[gfc.bitrate_index][bt]++;\n                gfc.bitrate_blockType_Hist[gfc.bitrate_index][5]++;\n                gfc.bitrate_blockType_Hist[15][bt]++;\n                gfc.bitrate_blockType_Hist[15][5]++;\n            }\n        }\n    }\n\n    function lame_encode_frame_init(gfp, inbuf) {\n        var gfc = gfp.internal_flags;\n\n        var ch, gr;\n\n        if (gfc.lame_encode_frame_init == 0) {\n            /* prime the MDCT/polyphase filterbank with a short block */\n            var i, j;\n            var primebuff0 = new_float(286 + 1152 + 576);\n            var primebuff1 = new_float(286 + 1152 + 576);\n            gfc.lame_encode_frame_init = 1;\n            for (i = 0, j = 0; i < 286 + 576 * (1 + gfc.mode_gr); ++i) {\n                if (i < 576 * gfc.mode_gr) {\n                    primebuff0[i] = 0;\n                    if (gfc.channels_out == 2)\n                        primebuff1[i] = 0;\n                } else {\n                    primebuff0[i] = inbuf[0][j];\n                    if (gfc.channels_out == 2)\n                        primebuff1[i] = inbuf[1][j];\n                    ++j;\n                }\n            }\n            /* polyphase filtering / mdct */\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    gfc.l3_side.tt[gr][ch].block_type = Encoder.SHORT_TYPE;\n                }\n            }\n            newMDCT.mdct_sub48(gfc, primebuff0, primebuff1);\n\n            /* check FFT will not use a negative starting offset */\n            assert(576 >= Encoder.FFTOFFSET);\n            /* check if we have enough data for FFT */\n            assert(gfc.mf_size >= (Encoder.BLKSIZE + gfp.framesize - Encoder.FFTOFFSET));\n            /* check if we have enough data for polyphase filterbank */\n            assert(gfc.mf_size >= (512 + gfp.framesize - 32));\n        }\n\n    }\n\n    /**\n     * <PRE>\n     * encodeframe()           Layer 3\n     *\n     * encode a single frame\n     *\n     *\n     *    lame_encode_frame()\n     *\n     *\n     *                           gr 0            gr 1\n     *    inbuf:           |--------------|--------------|--------------|\n     *\n     *\n     *    Polyphase (18 windows, each shifted 32)\n     *    gr 0:\n     *    window1          <----512---.\n     *    window18                 <----512---.\n     *\n     *    gr 1:\n     *    window1                         <----512---.\n     *    window18                                <----512---.\n     *\n     *\n     *\n     *    MDCT output:  |--------------|--------------|--------------|\n     *\n     *    FFT's                    <---------1024---------.\n     *                                             <---------1024-------.\n     *\n     *\n     *\n     *        inbuf = buffer of PCM data size=MP3 framesize\n     *        encoder acts on inbuf[ch][0], but output is delayed by MDCTDELAY\n     *        so the MDCT coefficints are from inbuf[ch][-MDCTDELAY]\n     *\n     *        psy-model FFT has a 1 granule delay, so we feed it data for the\n     *        next granule.\n     *        FFT is centered over granule:  224+576+224\n     *        So FFT starts at:   576-224-MDCTDELAY\n     *\n     *        MPEG2:  FFT ends at:  BLKSIZE+576-224-MDCTDELAY      (1328)\n     *        MPEG1:  FFT ends at:  BLKSIZE+2*576-224-MDCTDELAY    (1904)\n     *\n     *        MPEG2:  polyphase first window:  [0..511]\n     *                          18th window:   [544..1055]          (1056)\n     *        MPEG1:            36th window:   [1120..1631]         (1632)\n     *                data needed:  512+framesize-32\n     *\n     *        A close look newmdct.c shows that the polyphase filterbank\n     *        only uses data from [0..510] for each window.  Perhaps because the window\n     *        used by the filterbank is zero for the last point, so Takehiro's\n     *        code doesn't bother to compute with it.\n     *\n     *        FFT starts at 576-224-MDCTDELAY (304)  = 576-FFTOFFSET\n     *\n     * </PRE>\n     */\n\n\n    this.lame_encode_mp3_frame = function (gfp, inbuf_l, inbuf_r, mp3buf, mp3bufPos, mp3buf_size) {\n        var mp3count;\n        var masking_LR = new_array_n([2, 2]);\n        /*\n         * LR masking &\n         * energy\n         */\n        masking_LR[0][0] = new III_psy_ratio();\n        masking_LR[0][1] = new III_psy_ratio();\n        masking_LR[1][0] = new III_psy_ratio();\n        masking_LR[1][1] = new III_psy_ratio();\n        var masking_MS = new_array_n([2, 2]);\n        /* MS masking & energy */\n        masking_MS[0][0] = new III_psy_ratio();\n        masking_MS[0][1] = new III_psy_ratio();\n        masking_MS[1][0] = new III_psy_ratio();\n        masking_MS[1][1] = new III_psy_ratio();\n        //III_psy_ratio masking[][];\n        var masking;\n        /* pointer to selected maskings */\n        var inbuf = [null, null];\n        var gfc = gfp.internal_flags;\n\n        var tot_ener = new_float_n([2, 4]);\n        var ms_ener_ratio = [.5, .5];\n        var pe = [[0., 0.], [0., 0.]];\n        var pe_MS = [[0., 0.], [0., 0.]];\n\n//float[][] pe_use;\n        var pe_use;\n\n        var ch, gr;\n\n        inbuf[0] = inbuf_l;\n        inbuf[1] = inbuf_r;\n\n        if (gfc.lame_encode_frame_init == 0) {\n            /* first run? */\n            lame_encode_frame_init(gfp, inbuf);\n\n        }\n\n        /********************** padding *****************************/\n        /**\n         * <PRE>\n         * padding method as described in\n         * \"MPEG-Layer3 / Bitstream Syntax and Decoding\"\n         * by Martin Sieler, Ralph Sperschneider\n         *\n         * note: there is no padding for the very first frame\n         *\n         * Robert Hegemann 2000-06-22\n         * </PRE>\n         */\n        gfc.padding = 0;\n        if ((gfc.slot_lag -= gfc.frac_SpF) < 0) {\n            gfc.slot_lag += gfp.out_samplerate;\n            gfc.padding = 1;\n        }\n\n        /****************************************\n         * Stage 1: psychoacoustic model *\n         ****************************************/\n\n        if (gfc.psymodel != 0) {\n            /*\n             * psychoacoustic model psy model has a 1 granule (576) delay that\n             * we must compensate for (mt 6/99).\n             */\n            var ret;\n            var bufp = [null, null];\n            /* address of beginning of left & right granule */\n            var bufpPos = 0;\n            /* address of beginning of left & right granule */\n            var blocktype = new_int(2);\n\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    bufp[ch] = inbuf[ch];\n                    bufpPos = 576 + gr * 576 - Encoder.FFTOFFSET;\n                }\n                if (gfp.VBR == VbrMode.vbr_mtrh || gfp.VBR == VbrMode.vbr_mt) {\n                    ret = psy.L3psycho_anal_vbr(gfp, bufp, bufpPos, gr,\n                        masking_LR, masking_MS, pe[gr], pe_MS[gr],\n                        tot_ener[gr], blocktype);\n                } else {\n                    ret = psy.L3psycho_anal_ns(gfp, bufp, bufpPos, gr,\n                        masking_LR, masking_MS, pe[gr], pe_MS[gr],\n                        tot_ener[gr], blocktype);\n                }\n                if (ret != 0)\n                    return -4;\n\n                if (gfp.mode == MPEGMode.JOINT_STEREO) {\n                    ms_ener_ratio[gr] = tot_ener[gr][2] + tot_ener[gr][3];\n                    if (ms_ener_ratio[gr] > 0)\n                        ms_ener_ratio[gr] = tot_ener[gr][3] / ms_ener_ratio[gr];\n                }\n\n                /* block type flags */\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    var cod_info = gfc.l3_side.tt[gr][ch];\n                    cod_info.block_type = blocktype[ch];\n                    cod_info.mixed_block_flag = 0;\n                }\n            }\n        } else {\n            /* no psy model */\n            for (gr = 0; gr < gfc.mode_gr; gr++)\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    gfc.l3_side.tt[gr][ch].block_type = Encoder.NORM_TYPE;\n                    gfc.l3_side.tt[gr][ch].mixed_block_flag = 0;\n                    pe_MS[gr][ch] = pe[gr][ch] = 700;\n                }\n        }\n\n        /* auto-adjust of ATH, useful for low volume */\n        adjust_ATH(gfc);\n\n        /****************************************\n         * Stage 2: MDCT *\n         ****************************************/\n\n        /* polyphase filtering / mdct */\n        newMDCT.mdct_sub48(gfc, inbuf[0], inbuf[1]);\n\n        /****************************************\n         * Stage 3: MS/LR decision *\n         ****************************************/\n\n        /* Here will be selected MS or LR coding of the 2 stereo channels */\n        gfc.mode_ext = Encoder.MPG_MD_LR_LR;\n\n        if (gfp.force_ms) {\n            gfc.mode_ext = Encoder.MPG_MD_MS_LR;\n        } else if (gfp.mode == MPEGMode.JOINT_STEREO) {\n            /*\n             * ms_ratio = is scaled, for historical reasons, to look like a\n             * ratio of side_channel / total. 0 = signal is 100% mono .5 = L & R\n             * uncorrelated\n             */\n\n            /**\n             * <PRE>\n             * [0] and [1] are the results for the two granules in MPEG-1,\n             * in MPEG-2 it's only a faked averaging of the same value\n             * _prev is the value of the last granule of the previous frame\n             * _next is the value of the first granule of the next frame\n             * </PRE>\n             */\n\n            var sum_pe_MS = 0.;\n            var sum_pe_LR = 0.;\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    sum_pe_MS += pe_MS[gr][ch];\n                    sum_pe_LR += pe[gr][ch];\n                }\n            }\n\n            /* based on PE: M/S coding would not use much more bits than L/R */\n            if (sum_pe_MS <= 1.00 * sum_pe_LR) {\n\n                var gi0 = gfc.l3_side.tt[0];\n                var gi1 = gfc.l3_side.tt[gfc.mode_gr - 1];\n\n                if (gi0[0].block_type == gi0[1].block_type\n                    && gi1[0].block_type == gi1[1].block_type) {\n\n                    gfc.mode_ext = Encoder.MPG_MD_MS_LR;\n                }\n            }\n        }\n\n        /* bit and noise allocation */\n        if (gfc.mode_ext == MPG_MD_MS_LR) {\n            masking = masking_MS;\n            /* use MS masking */\n            pe_use = pe_MS;\n        } else {\n            masking = masking_LR;\n            /* use LR masking */\n            pe_use = pe;\n        }\n\n        /* copy data for MP3 frame analyzer */\n        if (gfp.analysis && gfc.pinfo != null) {\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    gfc.pinfo.ms_ratio[gr] = gfc.ms_ratio[gr];\n                    gfc.pinfo.ms_ener_ratio[gr] = ms_ener_ratio[gr];\n                    gfc.pinfo.blocktype[gr][ch] = gfc.l3_side.tt[gr][ch].block_type;\n                    gfc.pinfo.pe[gr][ch] = pe_use[gr][ch];\n                    System.arraycopy(gfc.l3_side.tt[gr][ch].xr, 0,\n                        gfc.pinfo.xr[gr][ch], 0, 576);\n                    /*\n                     * in psymodel, LR and MS data was stored in pinfo. switch\n                     * to MS data:\n                     */\n                    if (gfc.mode_ext == MPG_MD_MS_LR) {\n                        gfc.pinfo.ers[gr][ch] = gfc.pinfo.ers[gr][ch + 2];\n                        System.arraycopy(gfc.pinfo.energy[gr][ch + 2], 0,\n                            gfc.pinfo.energy[gr][ch], 0,\n                            gfc.pinfo.energy[gr][ch].length);\n                    }\n                }\n            }\n        }\n\n        /****************************************\n         * Stage 4: quantization loop *\n         ****************************************/\n\n        if (gfp.VBR == VbrMode.vbr_off || gfp.VBR == VbrMode.vbr_abr) {\n\n            var i;\n            var f;\n\n            for (i = 0; i < 18; i++)\n                gfc.nsPsy.pefirbuf[i] = gfc.nsPsy.pefirbuf[i + 1];\n\n            f = 0.0;\n            for (gr = 0; gr < gfc.mode_gr; gr++)\n                for (ch = 0; ch < gfc.channels_out; ch++)\n                    f += pe_use[gr][ch];\n            gfc.nsPsy.pefirbuf[18] = f;\n\n            f = gfc.nsPsy.pefirbuf[9];\n            for (i = 0; i < 9; i++)\n                f += (gfc.nsPsy.pefirbuf[i] + gfc.nsPsy.pefirbuf[18 - i])\n                    * Encoder.fircoef[i];\n\n            f = (670 * 5 * gfc.mode_gr * gfc.channels_out) / f;\n            for (gr = 0; gr < gfc.mode_gr; gr++) {\n                for (ch = 0; ch < gfc.channels_out; ch++) {\n                    pe_use[gr][ch] *= f;\n                }\n            }\n        }\n        gfc.iteration_loop.iteration_loop(gfp, pe_use, ms_ener_ratio, masking);\n\n        /****************************************\n         * Stage 5: bitstream formatting *\n         ****************************************/\n\n        /* write the frame to the bitstream */\n        bs.format_bitstream(gfp);\n\n        /* copy mp3 bit buffer into array */\n        mp3count = bs.copy_buffer(gfc, mp3buf, mp3bufPos, mp3buf_size, 1);\n\n        if (gfp.bWriteVbrTag)\n            vbr.addVbrFrame(gfp);\n\n        if (gfp.analysis && gfc.pinfo != null) {\n            for (ch = 0; ch < gfc.channels_out; ch++) {\n                var j;\n                for (j = 0; j < FFTOFFSET; j++)\n                    gfc.pinfo.pcmdata[ch][j] = gfc.pinfo.pcmdata[ch][j\n                    + gfp.framesize];\n                for (j = FFTOFFSET; j < 1600; j++) {\n                    gfc.pinfo.pcmdata[ch][j] = inbuf[ch][j - FFTOFFSET];\n                }\n            }\n            qupvt.set_frame_pinfo(gfp, masking);\n        }\n\n        updateStats(gfc);\n\n        return mp3count;\n    }\n}\n\n\nmodule.exports = Encoder;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}