{"ast":null,"code":"/*\n *\tMP3 huffman table selecting and bit counting\n *\n *\tCopyright (c) 1999-2005 Takehiro TOMINAGA\n *\tCopyright (c) 2002-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Takehiro.java,v 1.26 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n//import java.util.Arrays;\nvar common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\nvar Encoder = require('./Encoder.js');\nvar Tables = require('./Tables.js');\nvar GrInfo = require('./GrInfo.js');\nvar QuantizePVT = require('./QuantizePVT.js');\nfunction Takehiro() {\n  var qupvt = null;\n  this.qupvt = null;\n  this.setModules = function (_qupvt) {\n    this.qupvt = _qupvt;\n    qupvt = _qupvt;\n  };\n  function Bits(b) {\n    this.bits = 0 | b;\n  }\n  var subdv_table = [[0, 0], /* 0 bands */\n  [0, 0], /* 1 bands */\n  [0, 0], /* 2 bands */\n  [0, 0], /* 3 bands */\n  [0, 0], /* 4 bands */\n  [0, 1], /* 5 bands */\n  [1, 1], /* 6 bands */\n  [1, 1], /* 7 bands */\n  [1, 2], /* 8 bands */\n  [2, 2], /* 9 bands */\n  [2, 3], /* 10 bands */\n  [2, 3], /* 11 bands */\n  [3, 4], /* 12 bands */\n  [3, 4], /* 13 bands */\n  [3, 4], /* 14 bands */\n  [4, 5], /* 15 bands */\n  [4, 5], /* 16 bands */\n  [4, 6], /* 17 bands */\n  [5, 6], /* 18 bands */\n  [5, 6], /* 19 bands */\n  [5, 7], /* 20 bands */\n  [6, 7], /* 21 bands */\n  [6, 7] /* 22 bands */];\n\n  /**\n   * nonlinear quantization of xr More accurate formula than the ISO formula.\n   * Takes into account the fact that we are quantizing xr . ix, but we want\n   * ix^4/3 to be as close as possible to x^4/3. (taking the nearest int would\n   * mean ix is as close as possible to xr, which is different.)\n   *\n   * From Segher Boessenkool <segher@eastsite.nl> 11/1999\n   *\n   * 09/2000: ASM code removed in favor of IEEE754 hack by Takehiro Tominaga.\n   * If you need the ASM code, check CVS circa Aug 2000.\n   *\n   * 01/2004: Optimizations by Gabriel Bouvigne\n   */\n  function quantize_lines_xrpow_01(l, istep, xr, xrPos, ix, ixPos) {\n    var compareval0 = (1.0 - 0.4054) / istep;\n    assert(l > 0);\n    l = l >> 1;\n    while (l-- != 0) {\n      ix[ixPos++] = compareval0 > xr[xrPos++] ? 0 : 1;\n      ix[ixPos++] = compareval0 > xr[xrPos++] ? 0 : 1;\n    }\n  }\n\n  /**\n   * XRPOW_FTOI is a macro to convert floats to ints.<BR>\n   * if XRPOW_FTOI(x) = nearest_int(x), then QUANTFAC(x)=adj43asm[x]<BR>\n   * ROUNDFAC= -0.0946<BR>\n   *\n   * if XRPOW_FTOI(x) = floor(x), then QUANTFAC(x)=asj43[x]<BR>\n   * ROUNDFAC=0.4054<BR>\n   *\n   * Note: using floor() or 0| is extremely slow. On machines where the\n   * TAKEHIRO_IEEE754_HACK code above does not work, it is worthwile to write\n   * some ASM for XRPOW_FTOI().\n   */\n  function quantize_lines_xrpow(l, istep, xr, xrPos, ix, ixPos) {\n    assert(l > 0);\n    l = l >> 1;\n    var remaining = l % 2;\n    l = l >> 1;\n    while (l-- != 0) {\n      var x0, x1, x2, x3;\n      var rx0, rx1, rx2, rx3;\n      x0 = xr[xrPos++] * istep;\n      x1 = xr[xrPos++] * istep;\n      rx0 = 0 | x0;\n      x2 = xr[xrPos++] * istep;\n      rx1 = 0 | x1;\n      x3 = xr[xrPos++] * istep;\n      rx2 = 0 | x2;\n      x0 += qupvt.adj43[rx0];\n      rx3 = 0 | x3;\n      x1 += qupvt.adj43[rx1];\n      ix[ixPos++] = 0 | x0;\n      x2 += qupvt.adj43[rx2];\n      ix[ixPos++] = 0 | x1;\n      x3 += qupvt.adj43[rx3];\n      ix[ixPos++] = 0 | x2;\n      ix[ixPos++] = 0 | x3;\n    }\n    if (remaining != 0) {\n      var x0, x1;\n      var rx0, rx1;\n      x0 = xr[xrPos++] * istep;\n      x1 = xr[xrPos++] * istep;\n      rx0 = 0 | x0;\n      rx1 = 0 | x1;\n      x0 += qupvt.adj43[rx0];\n      x1 += qupvt.adj43[rx1];\n      ix[ixPos++] = 0 | x0;\n      ix[ixPos++] = 0 | x1;\n    }\n  }\n\n  /**\n   * Quantization function This function will select which lines to quantize\n   * and call the proper quantization function\n   */\n  function quantize_xrpow(xp, pi, istep, codInfo, prevNoise) {\n    /* quantize on xr^(3/4) instead of xr */\n    var sfb;\n    var sfbmax;\n    var j = 0;\n    var prev_data_use;\n    var accumulate = 0;\n    var accumulate01 = 0;\n    var xpPos = 0;\n    var iData = pi;\n    var iDataPos = 0;\n    var acc_iData = iData;\n    var acc_iDataPos = 0;\n    var acc_xp = xp;\n    var acc_xpPos = 0;\n\n    /*\n     * Reusing previously computed data does not seems to work if global\n     * gain is changed. Finding why it behaves this way would allow to use a\n     * cache of previously computed values (let's 10 cached values per sfb)\n     * that would probably provide a noticeable speedup\n     */\n    prev_data_use = prevNoise != null && codInfo.global_gain == prevNoise.global_gain;\n    if (codInfo.block_type == Encoder.SHORT_TYPE) sfbmax = 38;else sfbmax = 21;\n    for (sfb = 0; sfb <= sfbmax; sfb++) {\n      var step = -1;\n      if (prev_data_use || codInfo.block_type == Encoder.NORM_TYPE) {\n        step = codInfo.global_gain - (codInfo.scalefac[sfb] + (codInfo.preflag != 0 ? qupvt.pretab[sfb] : 0) << codInfo.scalefac_scale + 1) - codInfo.subblock_gain[codInfo.window[sfb]] * 8;\n      }\n      assert(codInfo.width[sfb] >= 0);\n      if (prev_data_use && prevNoise.step[sfb] == step) {\n        /*\n         * do not recompute this part, but compute accumulated lines\n         */\n        if (accumulate != 0) {\n          quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n          accumulate = 0;\n        }\n        if (accumulate01 != 0) {\n          quantize_lines_xrpow_01(accumulate01, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n          accumulate01 = 0;\n        }\n      } else {\n        /* should compute this part */\n        var l = codInfo.width[sfb];\n        if (j + codInfo.width[sfb] > codInfo.max_nonzero_coeff) {\n          /* do not compute upper zero part */\n          var usefullsize;\n          usefullsize = codInfo.max_nonzero_coeff - j + 1;\n          Arrays.fill(pi, codInfo.max_nonzero_coeff, 576, 0);\n          l = usefullsize;\n          if (l < 0) {\n            l = 0;\n          }\n\n          /* no need to compute higher sfb values */\n          sfb = sfbmax + 1;\n        }\n\n        /* accumulate lines to quantize */\n        if (0 == accumulate && 0 == accumulate01) {\n          acc_iData = iData;\n          acc_iDataPos = iDataPos;\n          acc_xp = xp;\n          acc_xpPos = xpPos;\n        }\n        if (prevNoise != null && prevNoise.sfb_count1 > 0 && sfb >= prevNoise.sfb_count1 && prevNoise.step[sfb] > 0 && step >= prevNoise.step[sfb]) {\n          if (accumulate != 0) {\n            quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n            accumulate = 0;\n            acc_iData = iData;\n            acc_iDataPos = iDataPos;\n            acc_xp = xp;\n            acc_xpPos = xpPos;\n          }\n          accumulate01 += l;\n        } else {\n          if (accumulate01 != 0) {\n            quantize_lines_xrpow_01(accumulate01, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n            accumulate01 = 0;\n            acc_iData = iData;\n            acc_iDataPos = iDataPos;\n            acc_xp = xp;\n            acc_xpPos = xpPos;\n          }\n          accumulate += l;\n        }\n        if (l <= 0) {\n          /*\n           * rh: 20040215 may happen due to \"prev_data_use\"\n           * optimization\n           */\n          if (accumulate01 != 0) {\n            quantize_lines_xrpow_01(accumulate01, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n            accumulate01 = 0;\n          }\n          if (accumulate != 0) {\n            quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n            accumulate = 0;\n          }\n          break;\n          /* ends for-loop */\n        }\n      }\n      if (sfb <= sfbmax) {\n        iDataPos += codInfo.width[sfb];\n        xpPos += codInfo.width[sfb];\n        j += codInfo.width[sfb];\n      }\n    }\n    if (accumulate != 0) {\n      /* last data part */\n      quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n      accumulate = 0;\n    }\n    if (accumulate01 != 0) {\n      /* last data part */\n      quantize_lines_xrpow_01(accumulate01, istep, acc_xp, acc_xpPos, acc_iData, acc_iDataPos);\n      accumulate01 = 0;\n    }\n  }\n\n  /**\n   * ix_max\n   */\n  function ix_max(ix, ixPos, endPos) {\n    var max1 = 0,\n      max2 = 0;\n    do {\n      var x1 = ix[ixPos++];\n      var x2 = ix[ixPos++];\n      if (max1 < x1) max1 = x1;\n      if (max2 < x2) max2 = x2;\n    } while (ixPos < endPos);\n    if (max1 < max2) max1 = max2;\n    return max1;\n  }\n  function count_bit_ESC(ix, ixPos, end, t1, t2, s) {\n    /* ESC-table is used */\n    var linbits = Tables.ht[t1].xlen * 65536 + Tables.ht[t2].xlen;\n    var sum = 0,\n      sum2;\n    do {\n      var x = ix[ixPos++];\n      var y = ix[ixPos++];\n      if (x != 0) {\n        if (x > 14) {\n          x = 15;\n          sum += linbits;\n        }\n        x *= 16;\n      }\n      if (y != 0) {\n        if (y > 14) {\n          y = 15;\n          sum += linbits;\n        }\n        x += y;\n      }\n      sum += Tables.largetbl[x];\n    } while (ixPos < end);\n    sum2 = sum & 0xffff;\n    sum >>= 16;\n    if (sum > sum2) {\n      sum = sum2;\n      t1 = t2;\n    }\n    s.bits += sum;\n    return t1;\n  }\n  function count_bit_noESC(ix, ixPos, end, s) {\n    /* No ESC-words */\n    var sum1 = 0;\n    var hlen1 = Tables.ht[1].hlen;\n    do {\n      var x = ix[ixPos + 0] * 2 + ix[ixPos + 1];\n      ixPos += 2;\n      sum1 += hlen1[x];\n    } while (ixPos < end);\n    s.bits += sum1;\n    return 1;\n  }\n  function count_bit_noESC_from2(ix, ixPos, end, t1, s) {\n    /* No ESC-words */\n    var sum = 0,\n      sum2;\n    var xlen = Tables.ht[t1].xlen;\n    var hlen;\n    if (t1 == 2) hlen = Tables.table23;else hlen = Tables.table56;\n    do {\n      var x = ix[ixPos + 0] * xlen + ix[ixPos + 1];\n      ixPos += 2;\n      sum += hlen[x];\n    } while (ixPos < end);\n    sum2 = sum & 0xffff;\n    sum >>= 16;\n    if (sum > sum2) {\n      sum = sum2;\n      t1++;\n    }\n    s.bits += sum;\n    return t1;\n  }\n  function count_bit_noESC_from3(ix, ixPos, end, t1, s) {\n    /* No ESC-words */\n    var sum1 = 0;\n    var sum2 = 0;\n    var sum3 = 0;\n    var xlen = Tables.ht[t1].xlen;\n    var hlen1 = Tables.ht[t1].hlen;\n    var hlen2 = Tables.ht[t1 + 1].hlen;\n    var hlen3 = Tables.ht[t1 + 2].hlen;\n    do {\n      var x = ix[ixPos + 0] * xlen + ix[ixPos + 1];\n      ixPos += 2;\n      sum1 += hlen1[x];\n      sum2 += hlen2[x];\n      sum3 += hlen3[x];\n    } while (ixPos < end);\n    var t = t1;\n    if (sum1 > sum2) {\n      sum1 = sum2;\n      t++;\n    }\n    if (sum1 > sum3) {\n      sum1 = sum3;\n      t = t1 + 2;\n    }\n    s.bits += sum1;\n    return t;\n  }\n\n  /*************************************************************************/\n  /* choose table */\n  /*************************************************************************/\n\n  var huf_tbl_noESC = [1, 2, 5, 7, 7, 10, 10, 13, 13, 13, 13, 13, 13, 13, 13];\n\n  /**\n   * Choose the Huffman table that will encode ix[begin..end] with the fewest\n   * bits.\n   *\n   * Note: This code contains knowledge about the sizes and characteristics of\n   * the Huffman tables as defined in the IS (Table B.7), and will not work\n   * with any arbitrary tables.\n   */\n  function choose_table(ix, ixPos, endPos, s) {\n    var max = ix_max(ix, ixPos, endPos);\n    switch (max) {\n      case 0:\n        return max;\n      case 1:\n        return count_bit_noESC(ix, ixPos, endPos, s);\n      case 2:\n      case 3:\n        return count_bit_noESC_from2(ix, ixPos, endPos, huf_tbl_noESC[max - 1], s);\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n      case 8:\n      case 9:\n      case 10:\n      case 11:\n      case 12:\n      case 13:\n      case 14:\n      case 15:\n        return count_bit_noESC_from3(ix, ixPos, endPos, huf_tbl_noESC[max - 1], s);\n      default:\n        /* try tables with linbits */\n        if (max > QuantizePVT.IXMAX_VAL) {\n          s.bits = QuantizePVT.LARGE_BITS;\n          return -1;\n        }\n        max -= 15;\n        var choice2;\n        for (choice2 = 24; choice2 < 32; choice2++) {\n          if (Tables.ht[choice2].linmax >= max) {\n            break;\n          }\n        }\n        var choice;\n        for (choice = choice2 - 8; choice < 24; choice++) {\n          if (Tables.ht[choice].linmax >= max) {\n            break;\n          }\n        }\n        return count_bit_ESC(ix, ixPos, endPos, choice, choice2, s);\n    }\n  }\n\n  /**\n   * count_bit\n   */\n  this.noquant_count_bits = function (gfc, gi, prev_noise) {\n    var ix = gi.l3_enc;\n    var i = Math.min(576, gi.max_nonzero_coeff + 2 >> 1 << 1);\n    if (prev_noise != null) prev_noise.sfb_count1 = 0;\n\n    /* Determine count1 region */\n    for (; i > 1; i -= 2) if ((ix[i - 1] | ix[i - 2]) != 0) break;\n    gi.count1 = i;\n\n    /* Determines the number of bits to encode the quadruples. */\n    var a1 = 0;\n    var a2 = 0;\n    for (; i > 3; i -= 4) {\n      var p;\n      /* hack to check if all values <= 1 */\n      //throw \"TODO: HACK         if ((((long) ix[i - 1] | (long) ix[i - 2] | (long) ix[i - 3] | (long) ix[i - 4]) & 0xffffffffL) > 1L        \"\n      //if (true) {\n      if (((ix[i - 1] | ix[i - 2] | ix[i - 3] | ix[i - 4]) & 0x7fffffff) > 1) {\n        break;\n      }\n      p = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2 + ix[i - 1];\n      a1 += Tables.t32l[p];\n      a2 += Tables.t33l[p];\n    }\n    var bits = a1;\n    gi.count1table_select = 0;\n    if (a1 > a2) {\n      bits = a2;\n      gi.count1table_select = 1;\n    }\n    gi.count1bits = bits;\n    gi.big_values = i;\n    if (i == 0) return bits;\n    if (gi.block_type == Encoder.SHORT_TYPE) {\n      a1 = 3 * gfc.scalefac_band.s[3];\n      if (a1 > gi.big_values) a1 = gi.big_values;\n      a2 = gi.big_values;\n    } else if (gi.block_type == Encoder.NORM_TYPE) {\n      assert(i <= 576);\n      /* bv_scf has 576 entries (0..575) */\n      a1 = gi.region0_count = gfc.bv_scf[i - 2];\n      a2 = gi.region1_count = gfc.bv_scf[i - 1];\n      assert(a1 + a2 + 2 < Encoder.SBPSY_l);\n      a2 = gfc.scalefac_band.l[a1 + a2 + 2];\n      a1 = gfc.scalefac_band.l[a1 + 1];\n      if (a2 < i) {\n        var bi = new Bits(bits);\n        gi.table_select[2] = choose_table(ix, a2, i, bi);\n        bits = bi.bits;\n      }\n    } else {\n      gi.region0_count = 7;\n      /* gi.region1_count = SBPSY_l - 7 - 1; */\n      gi.region1_count = Encoder.SBMAX_l - 1 - 7 - 1;\n      a1 = gfc.scalefac_band.l[7 + 1];\n      a2 = i;\n      if (a1 > a2) {\n        a1 = a2;\n      }\n    }\n\n    /* have to allow for the case when bigvalues < region0 < region1 */\n    /* (and region0, region1 are ignored) */\n    a1 = Math.min(a1, i);\n    a2 = Math.min(a2, i);\n    assert(a1 >= 0);\n    assert(a2 >= 0);\n\n    /* Count the number of bits necessary to code the bigvalues region. */\n    if (0 < a1) {\n      var bi = new Bits(bits);\n      gi.table_select[0] = choose_table(ix, 0, a1, bi);\n      bits = bi.bits;\n    }\n    if (a1 < a2) {\n      var bi = new Bits(bits);\n      gi.table_select[1] = choose_table(ix, a1, a2, bi);\n      bits = bi.bits;\n    }\n    if (gfc.use_best_huffman == 2) {\n      gi.part2_3_length = bits;\n      best_huffman_divide(gfc, gi);\n      bits = gi.part2_3_length;\n    }\n    if (prev_noise != null) {\n      if (gi.block_type == Encoder.NORM_TYPE) {\n        var sfb = 0;\n        while (gfc.scalefac_band.l[sfb] < gi.big_values) {\n          sfb++;\n        }\n        prev_noise.sfb_count1 = sfb;\n      }\n    }\n    return bits;\n  };\n  this.count_bits = function (gfc, xr, gi, prev_noise) {\n    var ix = gi.l3_enc;\n\n    /* since quantize_xrpow uses table lookup, we need to check this first: */\n    var w = QuantizePVT.IXMAX_VAL / qupvt.IPOW20(gi.global_gain);\n    if (gi.xrpow_max > w) return QuantizePVT.LARGE_BITS;\n    quantize_xrpow(xr, ix, qupvt.IPOW20(gi.global_gain), gi, prev_noise);\n    if ((gfc.substep_shaping & 2) != 0) {\n      var j = 0;\n      /* 0.634521682242439 = 0.5946*2**(.5*0.1875) */\n      var gain = gi.global_gain + gi.scalefac_scale;\n      var roundfac = 0.634521682242439 / qupvt.IPOW20(gain);\n      for (var sfb = 0; sfb < gi.sfbmax; sfb++) {\n        var width = gi.width[sfb];\n        assert(width >= 0);\n        if (0 == gfc.pseudohalf[sfb]) {\n          j += width;\n        } else {\n          var k;\n          for (k = j, j += width; k < j; ++k) {\n            ix[k] = xr[k] >= roundfac ? ix[k] : 0;\n          }\n        }\n      }\n    }\n    return this.noquant_count_bits(gfc, gi, prev_noise);\n  };\n\n  /**\n   * re-calculate the best scalefac_compress using scfsi the saved bits are\n   * kept in the bit reservoir.\n   */\n  function recalc_divide_init(gfc, cod_info, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {\n    var bigv = cod_info.big_values;\n    for (var r0 = 0; r0 <= 7 + 15; r0++) {\n      r01_bits[r0] = QuantizePVT.LARGE_BITS;\n    }\n    for (var r0 = 0; r0 < 16; r0++) {\n      var a1 = gfc.scalefac_band.l[r0 + 1];\n      if (a1 >= bigv) break;\n      var r0bits = 0;\n      var bi = new Bits(r0bits);\n      var r0t = choose_table(ix, 0, a1, bi);\n      r0bits = bi.bits;\n      for (var r1 = 0; r1 < 8; r1++) {\n        var a2 = gfc.scalefac_band.l[r0 + r1 + 2];\n        if (a2 >= bigv) break;\n        var bits = r0bits;\n        bi = new Bits(bits);\n        var r1t = choose_table(ix, a1, a2, bi);\n        bits = bi.bits;\n        if (r01_bits[r0 + r1] > bits) {\n          r01_bits[r0 + r1] = bits;\n          r01_div[r0 + r1] = r0;\n          r0_tbl[r0 + r1] = r0t;\n          r1_tbl[r0 + r1] = r1t;\n        }\n      }\n    }\n  }\n  function recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {\n    var bigv = cod_info2.big_values;\n    for (var r2 = 2; r2 < Encoder.SBMAX_l + 1; r2++) {\n      var a2 = gfc.scalefac_band.l[r2];\n      if (a2 >= bigv) break;\n      var bits = r01_bits[r2 - 2] + cod_info2.count1bits;\n      if (gi.part2_3_length <= bits) break;\n      var bi = new Bits(bits);\n      var r2t = choose_table(ix, a2, bigv, bi);\n      bits = bi.bits;\n      if (gi.part2_3_length <= bits) continue;\n      gi.assign(cod_info2);\n      gi.part2_3_length = bits;\n      gi.region0_count = r01_div[r2 - 2];\n      gi.region1_count = r2 - 2 - r01_div[r2 - 2];\n      gi.table_select[0] = r0_tbl[r2 - 2];\n      gi.table_select[1] = r1_tbl[r2 - 2];\n      gi.table_select[2] = r2t;\n    }\n  }\n  this.best_huffman_divide = function (gfc, gi) {\n    var cod_info2 = new GrInfo();\n    var ix = gi.l3_enc;\n    var r01_bits = new_int(7 + 15 + 1);\n    var r01_div = new_int(7 + 15 + 1);\n    var r0_tbl = new_int(7 + 15 + 1);\n    var r1_tbl = new_int(7 + 15 + 1);\n\n    /* SHORT BLOCK stuff fails for MPEG2 */\n    if (gi.block_type == Encoder.SHORT_TYPE && gfc.mode_gr == 1) return;\n    cod_info2.assign(gi);\n    if (gi.block_type == Encoder.NORM_TYPE) {\n      recalc_divide_init(gfc, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl);\n      recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl);\n    }\n    var i = cod_info2.big_values;\n    if (i == 0 || (ix[i - 2] | ix[i - 1]) > 1) return;\n    i = gi.count1 + 2;\n    if (i > 576) return;\n\n    /* Determines the number of bits to encode the quadruples. */\n    cod_info2.assign(gi);\n    cod_info2.count1 = i;\n    var a1 = 0;\n    var a2 = 0;\n    assert(i <= 576);\n    for (; i > cod_info2.big_values; i -= 4) {\n      var p = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2 + ix[i - 1];\n      a1 += Tables.t32l[p];\n      a2 += Tables.t33l[p];\n    }\n    cod_info2.big_values = i;\n    cod_info2.count1table_select = 0;\n    if (a1 > a2) {\n      a1 = a2;\n      cod_info2.count1table_select = 1;\n    }\n    cod_info2.count1bits = a1;\n    if (cod_info2.block_type == Encoder.NORM_TYPE) recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl);else {\n      /* Count the number of bits necessary to code the bigvalues region. */\n      cod_info2.part2_3_length = a1;\n      a1 = gfc.scalefac_band.l[7 + 1];\n      if (a1 > i) {\n        a1 = i;\n      }\n      if (a1 > 0) {\n        var bi = new Bits(cod_info2.part2_3_length);\n        cod_info2.table_select[0] = choose_table(ix, 0, a1, bi);\n        cod_info2.part2_3_length = bi.bits;\n      }\n      if (i > a1) {\n        var bi = new Bits(cod_info2.part2_3_length);\n        cod_info2.table_select[1] = choose_table(ix, a1, i, bi);\n        cod_info2.part2_3_length = bi.bits;\n      }\n      if (gi.part2_3_length > cod_info2.part2_3_length) gi.assign(cod_info2);\n    }\n  };\n  var slen1_n = [1, 1, 1, 1, 8, 2, 2, 2, 4, 4, 4, 8, 8, 8, 16, 16];\n  var slen2_n = [1, 2, 4, 8, 1, 2, 4, 8, 2, 4, 8, 2, 4, 8, 4, 8];\n  var slen1_tab = [0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4];\n  var slen2_tab = [0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3];\n  Takehiro.slen1_tab = slen1_tab;\n  Takehiro.slen2_tab = slen2_tab;\n  function scfsi_calc(ch, l3_side) {\n    var sfb;\n    var gi = l3_side.tt[1][ch];\n    var g0 = l3_side.tt[0][ch];\n    for (var i = 0; i < Tables.scfsi_band.length - 1; i++) {\n      for (sfb = Tables.scfsi_band[i]; sfb < Tables.scfsi_band[i + 1]; sfb++) {\n        if (g0.scalefac[sfb] != gi.scalefac[sfb] && gi.scalefac[sfb] >= 0) break;\n      }\n      if (sfb == Tables.scfsi_band[i + 1]) {\n        for (sfb = Tables.scfsi_band[i]; sfb < Tables.scfsi_band[i + 1]; sfb++) {\n          gi.scalefac[sfb] = -1;\n        }\n        l3_side.scfsi[ch][i] = 1;\n      }\n    }\n    var s1 = 0;\n    var c1 = 0;\n    for (sfb = 0; sfb < 11; sfb++) {\n      if (gi.scalefac[sfb] == -1) continue;\n      c1++;\n      if (s1 < gi.scalefac[sfb]) s1 = gi.scalefac[sfb];\n    }\n    var s2 = 0;\n    var c2 = 0;\n    for (; sfb < Encoder.SBPSY_l; sfb++) {\n      if (gi.scalefac[sfb] == -1) continue;\n      c2++;\n      if (s2 < gi.scalefac[sfb]) s2 = gi.scalefac[sfb];\n    }\n    for (var i = 0; i < 16; i++) {\n      if (s1 < slen1_n[i] && s2 < slen2_n[i]) {\n        var c = slen1_tab[i] * c1 + slen2_tab[i] * c2;\n        if (gi.part2_length > c) {\n          gi.part2_length = c;\n          gi.scalefac_compress = i;\n        }\n      }\n    }\n  }\n\n  /**\n   * Find the optimal way to store the scalefactors. Only call this routine\n   * after final scalefactors have been chosen and the channel/granule will\n   * not be re-encoded.\n   */\n  this.best_scalefac_store = function (gfc, gr, ch, l3_side) {\n    /* use scalefac_scale if we can */\n    var gi = l3_side.tt[gr][ch];\n    var sfb, i, j, l;\n    var recalc = 0;\n\n    /*\n     * remove scalefacs from bands with ix=0. This idea comes from the AAC\n     * ISO docs. added mt 3/00\n     */\n    /* check if l3_enc=0 */\n    j = 0;\n    for (sfb = 0; sfb < gi.sfbmax; sfb++) {\n      var width = gi.width[sfb];\n      assert(width >= 0);\n      j += width;\n      for (l = -width; l < 0; l++) {\n        if (gi.l3_enc[l + j] != 0) break;\n      }\n      if (l == 0) gi.scalefac[sfb] = recalc = -2;\n      /* anything goes. */\n      /*\n       * only best_scalefac_store and calc_scfsi know--and only they\n       * should know--about the magic number -2.\n       */\n    }\n    if (0 == gi.scalefac_scale && 0 == gi.preflag) {\n      var s = 0;\n      for (sfb = 0; sfb < gi.sfbmax; sfb++) if (gi.scalefac[sfb] > 0) s |= gi.scalefac[sfb];\n      if (0 == (s & 1) && s != 0) {\n        for (sfb = 0; sfb < gi.sfbmax; sfb++) if (gi.scalefac[sfb] > 0) gi.scalefac[sfb] >>= 1;\n        gi.scalefac_scale = recalc = 1;\n      }\n    }\n    if (0 == gi.preflag && gi.block_type != Encoder.SHORT_TYPE && gfc.mode_gr == 2) {\n      for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++) if (gi.scalefac[sfb] < qupvt.pretab[sfb] && gi.scalefac[sfb] != -2) break;\n      if (sfb == Encoder.SBPSY_l) {\n        for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++) if (gi.scalefac[sfb] > 0) gi.scalefac[sfb] -= qupvt.pretab[sfb];\n        gi.preflag = recalc = 1;\n      }\n    }\n    for (i = 0; i < 4; i++) l3_side.scfsi[ch][i] = 0;\n    if (gfc.mode_gr == 2 && gr == 1 && l3_side.tt[0][ch].block_type != Encoder.SHORT_TYPE && l3_side.tt[1][ch].block_type != Encoder.SHORT_TYPE) {\n      scfsi_calc(ch, l3_side);\n      recalc = 0;\n    }\n    for (sfb = 0; sfb < gi.sfbmax; sfb++) {\n      if (gi.scalefac[sfb] == -2) {\n        gi.scalefac[sfb] = 0;\n        /* if anything goes, then 0 is a good choice */\n      }\n    }\n    if (recalc != 0) {\n      if (gfc.mode_gr == 2) {\n        this.scale_bitcount(gi);\n      } else {\n        this.scale_bitcount_lsf(gfc, gi);\n      }\n    }\n  };\n  function all_scalefactors_not_negative(scalefac, n) {\n    for (var i = 0; i < n; ++i) {\n      if (scalefac[i] < 0) return false;\n    }\n    return true;\n  }\n\n  /**\n   * number of bits used to encode scalefacs.\n   *\n   * 18*slen1_tab[i] + 18*slen2_tab[i]\n   */\n  var scale_short = [0, 18, 36, 54, 54, 36, 54, 72, 54, 72, 90, 72, 90, 108, 108, 126];\n\n  /**\n   * number of bits used to encode scalefacs.\n   *\n   * 17*slen1_tab[i] + 18*slen2_tab[i]\n   */\n  var scale_mixed = [0, 18, 36, 54, 51, 35, 53, 71, 52, 70, 88, 69, 87, 105, 104, 122];\n\n  /**\n   * number of bits used to encode scalefacs.\n   *\n   * 11*slen1_tab[i] + 10*slen2_tab[i]\n   */\n  var scale_long = [0, 10, 20, 30, 33, 21, 31, 41, 32, 42, 52, 43, 53, 63, 64, 74];\n\n  /**\n   * Also calculates the number of bits necessary to code the scalefactors.\n   */\n  this.scale_bitcount = function (cod_info) {\n    var k,\n      sfb,\n      max_slen1 = 0,\n      max_slen2 = 0;\n\n    /* maximum values */\n    var tab;\n    var scalefac = cod_info.scalefac;\n    assert(all_scalefactors_not_negative(scalefac, cod_info.sfbmax));\n    if (cod_info.block_type == Encoder.SHORT_TYPE) {\n      tab = scale_short;\n      if (cod_info.mixed_block_flag != 0) tab = scale_mixed;\n    } else {\n      /* block_type == 1,2,or 3 */\n      tab = scale_long;\n      if (0 == cod_info.preflag) {\n        for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++) if (scalefac[sfb] < qupvt.pretab[sfb]) break;\n        if (sfb == Encoder.SBPSY_l) {\n          cod_info.preflag = 1;\n          for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++) scalefac[sfb] -= qupvt.pretab[sfb];\n        }\n      }\n    }\n    for (sfb = 0; sfb < cod_info.sfbdivide; sfb++) if (max_slen1 < scalefac[sfb]) max_slen1 = scalefac[sfb];\n    for (; sfb < cod_info.sfbmax; sfb++) if (max_slen2 < scalefac[sfb]) max_slen2 = scalefac[sfb];\n\n    /*\n     * from Takehiro TOMINAGA <tominaga@isoternet.org> 10/99 loop over *all*\n     * posible values of scalefac_compress to find the one which uses the\n     * smallest number of bits. ISO would stop at first valid index\n     */\n    cod_info.part2_length = QuantizePVT.LARGE_BITS;\n    for (k = 0; k < 16; k++) {\n      if (max_slen1 < slen1_n[k] && max_slen2 < slen2_n[k] && cod_info.part2_length > tab[k]) {\n        cod_info.part2_length = tab[k];\n        cod_info.scalefac_compress = k;\n      }\n    }\n    return cod_info.part2_length == QuantizePVT.LARGE_BITS;\n  };\n\n  /**\n   * table of largest scalefactor values for MPEG2\n   */\n  var max_range_sfac_tab = [[15, 15, 7, 7], [15, 15, 7, 0], [7, 3, 0, 0], [15, 31, 31, 0], [7, 7, 7, 0], [3, 3, 0, 0]];\n\n  /**\n   * Also counts the number of bits to encode the scalefacs but for MPEG 2\n   * Lower sampling frequencies (24, 22.05 and 16 kHz.)\n   *\n   * This is reverse-engineered from section 2.4.3.2 of the MPEG2 IS,\n   * \"Audio Decoding Layer III\"\n   */\n  this.scale_bitcount_lsf = function (gfc, cod_info) {\n    var table_number, row_in_table, partition, nr_sfb, window;\n    var over;\n    var i, sfb;\n    var max_sfac = new_int(4);\n    //var partition_table;\n    var scalefac = cod_info.scalefac;\n\n    /*\n     * Set partition table. Note that should try to use table one, but do\n     * not yet...\n     */\n    if (cod_info.preflag != 0) table_number = 2;else table_number = 0;\n    for (i = 0; i < 4; i++) max_sfac[i] = 0;\n    if (cod_info.block_type == Encoder.SHORT_TYPE) {\n      row_in_table = 1;\n      var partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n      for (sfb = 0, partition = 0; partition < 4; partition++) {\n        nr_sfb = partition_table[partition] / 3;\n        for (i = 0; i < nr_sfb; i++, sfb++) for (window = 0; window < 3; window++) if (scalefac[sfb * 3 + window] > max_sfac[partition]) max_sfac[partition] = scalefac[sfb * 3 + window];\n      }\n    } else {\n      row_in_table = 0;\n      var partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n      for (sfb = 0, partition = 0; partition < 4; partition++) {\n        nr_sfb = partition_table[partition];\n        for (i = 0; i < nr_sfb; i++, sfb++) if (scalefac[sfb] > max_sfac[partition]) max_sfac[partition] = scalefac[sfb];\n      }\n    }\n    for (over = false, partition = 0; partition < 4; partition++) {\n      if (max_sfac[partition] > max_range_sfac_tab[table_number][partition]) over = true;\n    }\n    if (!over) {\n      var slen1, slen2, slen3, slen4;\n      cod_info.sfb_partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n      for (partition = 0; partition < 4; partition++) cod_info.slen[partition] = log2tab[max_sfac[partition]];\n\n      /* set scalefac_compress */\n      slen1 = cod_info.slen[0];\n      slen2 = cod_info.slen[1];\n      slen3 = cod_info.slen[2];\n      slen4 = cod_info.slen[3];\n      switch (table_number) {\n        case 0:\n          cod_info.scalefac_compress = (slen1 * 5 + slen2 << 4) + (slen3 << 2) + slen4;\n          break;\n        case 1:\n          cod_info.scalefac_compress = 400 + (slen1 * 5 + slen2 << 2) + slen3;\n          break;\n        case 2:\n          cod_info.scalefac_compress = 500 + slen1 * 3 + slen2;\n          break;\n        default:\n          System.err.printf(\"intensity stereo not implemented yet\\n\");\n          break;\n      }\n    }\n    if (!over) {\n      assert(cod_info.sfb_partition_table != null);\n      cod_info.part2_length = 0;\n      for (partition = 0; partition < 4; partition++) cod_info.part2_length += cod_info.slen[partition] * cod_info.sfb_partition_table[partition];\n    }\n    return over;\n  };\n\n  /*\n   * Since no bands have been over-amplified, we can set scalefac_compress and\n   * slen[] for the formatter\n   */\n  var log2tab = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4];\n  this.huffman_init = function (gfc) {\n    for (var i = 2; i <= 576; i += 2) {\n      var scfb_anz = 0,\n        bv_index;\n      while (gfc.scalefac_band.l[++scfb_anz] < i);\n      bv_index = subdv_table[scfb_anz][0]; // .region0_count\n      while (gfc.scalefac_band.l[bv_index + 1] > i) bv_index--;\n      if (bv_index < 0) {\n        /*\n         * this is an indication that everything is going to be encoded\n         * as region0: bigvalues < region0 < region1 so lets set\n         * region0, region1 to some value larger than bigvalues\n         */\n        bv_index = subdv_table[scfb_anz][0]; // .region0_count\n      }\n      gfc.bv_scf[i - 2] = bv_index;\n      bv_index = subdv_table[scfb_anz][1]; // .region1_count\n      while (gfc.scalefac_band.l[bv_index + gfc.bv_scf[i - 2] + 2] > i) bv_index--;\n      if (bv_index < 0) {\n        bv_index = subdv_table[scfb_anz][1]; // .region1_count\n      }\n      gfc.bv_scf[i - 1] = bv_index;\n    }\n  };\n}\nmodule.exports = Takehiro;","map":{"version":3,"names":["common","require","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","Encoder","Tables","GrInfo","QuantizePVT","Takehiro","qupvt","setModules","_qupvt","Bits","b","bits","subdv_table","quantize_lines_xrpow_01","l","istep","xr","xrPos","ix","ixPos","compareval0","quantize_lines_xrpow","remaining","x0","x1","x2","x3","rx0","rx1","rx2","rx3","adj43","quantize_xrpow","xp","pi","codInfo","prevNoise","sfb","sfbmax","j","prev_data_use","accumulate","accumulate01","xpPos","iData","iDataPos","acc_iData","acc_iDataPos","acc_xp","acc_xpPos","global_gain","block_type","SHORT_TYPE","step","NORM_TYPE","scalefac","preflag","pretab","scalefac_scale","subblock_gain","window","width","max_nonzero_coeff","usefullsize","fill","sfb_count1","ix_max","endPos","max1","max2","count_bit_ESC","end","t1","t2","s","linbits","ht","xlen","sum","sum2","x","y","largetbl","count_bit_noESC","sum1","hlen1","hlen","count_bit_noESC_from2","table23","table56","count_bit_noESC_from3","sum3","hlen2","hlen3","t","huf_tbl_noESC","choose_table","max","IXMAX_VAL","LARGE_BITS","choice2","linmax","choice","noquant_count_bits","gfc","gi","prev_noise","l3_enc","i","Math","min","count1","a1","a2","p","t32l","t33l","count1table_select","count1bits","big_values","scalefac_band","region0_count","bv_scf","region1_count","SBPSY_l","bi","table_select","SBMAX_l","use_best_huffman","part2_3_length","best_huffman_divide","count_bits","w","IPOW20","xrpow_max","substep_shaping","gain","roundfac","pseudohalf","k","recalc_divide_init","cod_info","r01_bits","r01_div","r0_tbl","r1_tbl","bigv","r0","r0bits","r0t","r1","r1t","recalc_divide_sub","cod_info2","r2","r2t","assign","mode_gr","slen1_n","slen2_n","slen1_tab","slen2_tab","scfsi_calc","ch","l3_side","tt","g0","scfsi_band","length","scfsi","s1","c1","s2","c2","c","part2_length","scalefac_compress","best_scalefac_store","gr","recalc","scale_bitcount","scale_bitcount_lsf","all_scalefactors_not_negative","n","scale_short","scale_mixed","scale_long","max_slen1","max_slen2","tab","mixed_block_flag","sfbdivide","max_range_sfac_tab","table_number","row_in_table","partition","nr_sfb","over","max_sfac","partition_table","nr_of_sfb_block","slen1","slen2","slen3","slen4","sfb_partition_table","slen","log2tab","err","printf","huffman_init","scfb_anz","bv_index","module","exports"],"sources":["D:/代码/vscodeProjects/AiEducation/vue_aieducation/node_modules/lamejs/src/js/Takehiro.js"],"sourcesContent":["/*\n *\tMP3 huffman table selecting and bit counting\n *\n *\tCopyright (c) 1999-2005 Takehiro TOMINAGA\n *\tCopyright (c) 2002-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: Takehiro.java,v 1.26 2011/05/24 20:48:06 kenchis Exp $ */\n\n//package mp3;\n\n//import java.util.Arrays;\nvar common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Encoder = require('./Encoder.js');\nvar Tables = require('./Tables.js');\nvar GrInfo = require('./GrInfo.js');\nvar QuantizePVT = require('./QuantizePVT.js');\n\n\nfunction Takehiro() {\n\n    var qupvt = null;\n    this.qupvt = null;\n\n    this.setModules = function (_qupvt) {\n        this.qupvt = _qupvt;\n        qupvt = _qupvt;\n    }\n\n    function Bits(b) {\n        this.bits = 0 | b;\n    }\n\n    var subdv_table = [[0, 0], /* 0 bands */\n        [0, 0], /* 1 bands */\n        [0, 0], /* 2 bands */\n        [0, 0], /* 3 bands */\n        [0, 0], /* 4 bands */\n        [0, 1], /* 5 bands */\n        [1, 1], /* 6 bands */\n        [1, 1], /* 7 bands */\n        [1, 2], /* 8 bands */\n        [2, 2], /* 9 bands */\n        [2, 3], /* 10 bands */\n        [2, 3], /* 11 bands */\n        [3, 4], /* 12 bands */\n        [3, 4], /* 13 bands */\n        [3, 4], /* 14 bands */\n        [4, 5], /* 15 bands */\n        [4, 5], /* 16 bands */\n        [4, 6], /* 17 bands */\n        [5, 6], /* 18 bands */\n        [5, 6], /* 19 bands */\n        [5, 7], /* 20 bands */\n        [6, 7], /* 21 bands */\n        [6, 7], /* 22 bands */\n    ];\n\n    /**\n     * nonlinear quantization of xr More accurate formula than the ISO formula.\n     * Takes into account the fact that we are quantizing xr . ix, but we want\n     * ix^4/3 to be as close as possible to x^4/3. (taking the nearest int would\n     * mean ix is as close as possible to xr, which is different.)\n     *\n     * From Segher Boessenkool <segher@eastsite.nl> 11/1999\n     *\n     * 09/2000: ASM code removed in favor of IEEE754 hack by Takehiro Tominaga.\n     * If you need the ASM code, check CVS circa Aug 2000.\n     *\n     * 01/2004: Optimizations by Gabriel Bouvigne\n     */\n    function quantize_lines_xrpow_01(l, istep, xr, xrPos, ix, ixPos) {\n        var compareval0 = (1.0 - 0.4054) / istep;\n\n        assert(l > 0);\n        l = l >> 1;\n        while ((l--) != 0) {\n            ix[ixPos++] = (compareval0 > xr[xrPos++]) ? 0 : 1;\n            ix[ixPos++] = (compareval0 > xr[xrPos++]) ? 0 : 1;\n        }\n    }\n\n    /**\n     * XRPOW_FTOI is a macro to convert floats to ints.<BR>\n     * if XRPOW_FTOI(x) = nearest_int(x), then QUANTFAC(x)=adj43asm[x]<BR>\n     * ROUNDFAC= -0.0946<BR>\n     *\n     * if XRPOW_FTOI(x) = floor(x), then QUANTFAC(x)=asj43[x]<BR>\n     * ROUNDFAC=0.4054<BR>\n     *\n     * Note: using floor() or 0| is extremely slow. On machines where the\n     * TAKEHIRO_IEEE754_HACK code above does not work, it is worthwile to write\n     * some ASM for XRPOW_FTOI().\n     */\n    function quantize_lines_xrpow(l, istep, xr, xrPos, ix, ixPos) {\n        assert(l > 0);\n\n        l = l >> 1;\n        var remaining = l % 2;\n        l = l >> 1;\n        while (l-- != 0) {\n            var x0, x1, x2, x3;\n            var rx0, rx1, rx2, rx3;\n\n            x0 = xr[xrPos++] * istep;\n            x1 = xr[xrPos++] * istep;\n            rx0 = 0 | x0;\n            x2 = xr[xrPos++] * istep;\n            rx1 = 0 | x1;\n            x3 = xr[xrPos++] * istep;\n            rx2 = 0 | x2;\n            x0 += qupvt.adj43[rx0];\n            rx3 = 0 | x3;\n            x1 += qupvt.adj43[rx1];\n            ix[ixPos++] = 0 | x0;\n            x2 += qupvt.adj43[rx2];\n            ix[ixPos++] = 0 | x1;\n            x3 += qupvt.adj43[rx3];\n            ix[ixPos++] = 0 | x2;\n            ix[ixPos++] = 0 | x3;\n        }\n        if (remaining != 0) {\n            var x0, x1;\n            var rx0, rx1;\n\n            x0 = xr[xrPos++] * istep;\n            x1 = xr[xrPos++] * istep;\n            rx0 = 0 | x0;\n            rx1 = 0 | x1;\n            x0 += qupvt.adj43[rx0];\n            x1 += qupvt.adj43[rx1];\n            ix[ixPos++] = 0 | x0;\n            ix[ixPos++] = 0 | x1;\n        }\n    }\n\n    /**\n     * Quantization function This function will select which lines to quantize\n     * and call the proper quantization function\n     */\n    function quantize_xrpow(xp, pi, istep, codInfo, prevNoise) {\n        /* quantize on xr^(3/4) instead of xr */\n        var sfb;\n        var sfbmax;\n        var j = 0;\n        var prev_data_use;\n        var accumulate = 0;\n        var accumulate01 = 0;\n        var xpPos = 0;\n        var iData = pi;\n        var iDataPos = 0;\n        var acc_iData = iData;\n        var acc_iDataPos = 0;\n        var acc_xp = xp;\n        var acc_xpPos = 0;\n\n        /*\n         * Reusing previously computed data does not seems to work if global\n         * gain is changed. Finding why it behaves this way would allow to use a\n         * cache of previously computed values (let's 10 cached values per sfb)\n         * that would probably provide a noticeable speedup\n         */\n        prev_data_use = (prevNoise != null && (codInfo.global_gain == prevNoise.global_gain));\n\n        if (codInfo.block_type == Encoder.SHORT_TYPE)\n            sfbmax = 38;\n        else\n            sfbmax = 21;\n\n        for (sfb = 0; sfb <= sfbmax; sfb++) {\n            var step = -1;\n\n            if (prev_data_use || codInfo.block_type == Encoder.NORM_TYPE) {\n                step = codInfo.global_gain\n                    - ((codInfo.scalefac[sfb] + (codInfo.preflag != 0 ? qupvt.pretab[sfb]\n                        : 0)) << (codInfo.scalefac_scale + 1))\n                    - codInfo.subblock_gain[codInfo.window[sfb]] * 8;\n            }\n            assert(codInfo.width[sfb] >= 0);\n            if (prev_data_use && (prevNoise.step[sfb] == step)) {\n                /*\n                 * do not recompute this part, but compute accumulated lines\n                 */\n                if (accumulate != 0) {\n                    quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos,\n                        acc_iData, acc_iDataPos);\n                    accumulate = 0;\n                }\n                if (accumulate01 != 0) {\n                    quantize_lines_xrpow_01(accumulate01, istep, acc_xp,\n                        acc_xpPos, acc_iData, acc_iDataPos);\n                    accumulate01 = 0;\n                }\n            } else { /* should compute this part */\n                var l = codInfo.width[sfb];\n\n                if ((j + codInfo.width[sfb]) > codInfo.max_nonzero_coeff) {\n                    /* do not compute upper zero part */\n                    var usefullsize;\n                    usefullsize = codInfo.max_nonzero_coeff - j + 1;\n                    Arrays.fill(pi, codInfo.max_nonzero_coeff, 576, 0);\n                    l = usefullsize;\n\n                    if (l < 0) {\n                        l = 0;\n                    }\n\n                    /* no need to compute higher sfb values */\n                    sfb = sfbmax + 1;\n                }\n\n                /* accumulate lines to quantize */\n                if (0 == accumulate && 0 == accumulate01) {\n                    acc_iData = iData;\n                    acc_iDataPos = iDataPos;\n                    acc_xp = xp;\n                    acc_xpPos = xpPos;\n                }\n                if (prevNoise != null && prevNoise.sfb_count1 > 0\n                    && sfb >= prevNoise.sfb_count1\n                    && prevNoise.step[sfb] > 0\n                    && step >= prevNoise.step[sfb]) {\n\n                    if (accumulate != 0) {\n                        quantize_lines_xrpow(accumulate, istep, acc_xp,\n                            acc_xpPos, acc_iData, acc_iDataPos);\n                        accumulate = 0;\n                        acc_iData = iData;\n                        acc_iDataPos = iDataPos;\n                        acc_xp = xp;\n                        acc_xpPos = xpPos;\n                    }\n                    accumulate01 += l;\n                } else {\n                    if (accumulate01 != 0) {\n                        quantize_lines_xrpow_01(accumulate01, istep, acc_xp,\n                            acc_xpPos, acc_iData, acc_iDataPos);\n                        accumulate01 = 0;\n                        acc_iData = iData;\n                        acc_iDataPos = iDataPos;\n                        acc_xp = xp;\n                        acc_xpPos = xpPos;\n                    }\n                    accumulate += l;\n                }\n\n                if (l <= 0) {\n                    /*\n                     * rh: 20040215 may happen due to \"prev_data_use\"\n                     * optimization\n                     */\n                    if (accumulate01 != 0) {\n                        quantize_lines_xrpow_01(accumulate01, istep, acc_xp,\n                            acc_xpPos, acc_iData, acc_iDataPos);\n                        accumulate01 = 0;\n                    }\n                    if (accumulate != 0) {\n                        quantize_lines_xrpow(accumulate, istep, acc_xp,\n                            acc_xpPos, acc_iData, acc_iDataPos);\n                        accumulate = 0;\n                    }\n\n                    break;\n                    /* ends for-loop */\n                }\n            }\n            if (sfb <= sfbmax) {\n                iDataPos += codInfo.width[sfb];\n                xpPos += codInfo.width[sfb];\n                j += codInfo.width[sfb];\n            }\n        }\n        if (accumulate != 0) { /* last data part */\n            quantize_lines_xrpow(accumulate, istep, acc_xp, acc_xpPos,\n                acc_iData, acc_iDataPos);\n            accumulate = 0;\n        }\n        if (accumulate01 != 0) { /* last data part */\n            quantize_lines_xrpow_01(accumulate01, istep, acc_xp, acc_xpPos,\n                acc_iData, acc_iDataPos);\n            accumulate01 = 0;\n        }\n\n    }\n\n    /**\n     * ix_max\n     */\n    function ix_max(ix, ixPos, endPos) {\n        var max1 = 0, max2 = 0;\n\n        do {\n            var x1 = ix[ixPos++];\n            var x2 = ix[ixPos++];\n            if (max1 < x1)\n                max1 = x1;\n\n            if (max2 < x2)\n                max2 = x2;\n        } while (ixPos < endPos);\n        if (max1 < max2)\n            max1 = max2;\n        return max1;\n    }\n\n    function count_bit_ESC(ix, ixPos, end, t1, t2, s) {\n        /* ESC-table is used */\n        var linbits = Tables.ht[t1].xlen * 65536 + Tables.ht[t2].xlen;\n        var sum = 0, sum2;\n\n        do {\n            var x = ix[ixPos++];\n            var y = ix[ixPos++];\n\n            if (x != 0) {\n                if (x > 14) {\n                    x = 15;\n                    sum += linbits;\n                }\n                x *= 16;\n            }\n\n            if (y != 0) {\n                if (y > 14) {\n                    y = 15;\n                    sum += linbits;\n                }\n                x += y;\n            }\n\n            sum += Tables.largetbl[x];\n        } while (ixPos < end);\n\n        sum2 = sum & 0xffff;\n        sum >>= 16;\n\n        if (sum > sum2) {\n            sum = sum2;\n            t1 = t2;\n        }\n\n        s.bits += sum;\n        return t1;\n    }\n\n    function count_bit_noESC(ix, ixPos, end, s) {\n        /* No ESC-words */\n        var sum1 = 0;\n        var hlen1 = Tables.ht[1].hlen;\n\n        do {\n            var x = ix[ixPos + 0] * 2 + ix[ixPos + 1];\n            ixPos += 2;\n            sum1 += hlen1[x];\n        } while (ixPos < end);\n\n        s.bits += sum1;\n        return 1;\n    }\n\n    function count_bit_noESC_from2(ix, ixPos, end, t1, s) {\n        /* No ESC-words */\n        var sum = 0, sum2;\n        var xlen = Tables.ht[t1].xlen;\n        var hlen;\n        if (t1 == 2)\n            hlen = Tables.table23;\n        else\n            hlen = Tables.table56;\n\n        do {\n            var x = ix[ixPos + 0] * xlen + ix[ixPos + 1];\n            ixPos += 2;\n            sum += hlen[x];\n        } while (ixPos < end);\n\n        sum2 = sum & 0xffff;\n        sum >>= 16;\n\n        if (sum > sum2) {\n            sum = sum2;\n            t1++;\n        }\n\n        s.bits += sum;\n        return t1;\n    }\n\n    function count_bit_noESC_from3(ix, ixPos, end, t1, s) {\n        /* No ESC-words */\n        var sum1 = 0;\n        var sum2 = 0;\n        var sum3 = 0;\n        var xlen = Tables.ht[t1].xlen;\n        var hlen1 = Tables.ht[t1].hlen;\n        var hlen2 = Tables.ht[t1 + 1].hlen;\n        var hlen3 = Tables.ht[t1 + 2].hlen;\n\n        do {\n            var x = ix[ixPos + 0] * xlen + ix[ixPos + 1];\n            ixPos += 2;\n            sum1 += hlen1[x];\n            sum2 += hlen2[x];\n            sum3 += hlen3[x];\n        } while (ixPos < end);\n        var t = t1;\n        if (sum1 > sum2) {\n            sum1 = sum2;\n            t++;\n        }\n        if (sum1 > sum3) {\n            sum1 = sum3;\n            t = t1 + 2;\n        }\n        s.bits += sum1;\n\n        return t;\n    }\n\n    /*************************************************************************/\n    /* choose table */\n    /*************************************************************************/\n\n    var huf_tbl_noESC = [1, 2, 5, 7, 7, 10, 10, 13, 13,\n        13, 13, 13, 13, 13, 13];\n\n    /**\n     * Choose the Huffman table that will encode ix[begin..end] with the fewest\n     * bits.\n     *\n     * Note: This code contains knowledge about the sizes and characteristics of\n     * the Huffman tables as defined in the IS (Table B.7), and will not work\n     * with any arbitrary tables.\n     */\n    function choose_table(ix, ixPos, endPos, s) {\n        var max = ix_max(ix, ixPos, endPos);\n\n        switch (max) {\n            case 0:\n                return max;\n\n            case 1:\n                return count_bit_noESC(ix, ixPos, endPos, s);\n\n            case 2:\n            case 3:\n                return count_bit_noESC_from2(ix, ixPos, endPos,\n                    huf_tbl_noESC[max - 1], s);\n\n            case 4:\n            case 5:\n            case 6:\n            case 7:\n            case 8:\n            case 9:\n            case 10:\n            case 11:\n            case 12:\n            case 13:\n            case 14:\n            case 15:\n                return count_bit_noESC_from3(ix, ixPos, endPos,\n                    huf_tbl_noESC[max - 1], s);\n\n            default:\n                /* try tables with linbits */\n                if (max > QuantizePVT.IXMAX_VAL) {\n                    s.bits = QuantizePVT.LARGE_BITS;\n                    return -1;\n                }\n                max -= 15;\n                var choice2;\n                for (choice2 = 24; choice2 < 32; choice2++) {\n                    if (Tables.ht[choice2].linmax >= max) {\n                        break;\n                    }\n                }\n                var choice;\n                for (choice = choice2 - 8; choice < 24; choice++) {\n                    if (Tables.ht[choice].linmax >= max) {\n                        break;\n                    }\n                }\n                return count_bit_ESC(ix, ixPos, endPos, choice, choice2, s);\n        }\n    }\n\n    /**\n     * count_bit\n     */\n    this.noquant_count_bits = function (gfc, gi, prev_noise) {\n        var ix = gi.l3_enc;\n        var i = Math.min(576, ((gi.max_nonzero_coeff + 2) >> 1) << 1);\n\n        if (prev_noise != null)\n            prev_noise.sfb_count1 = 0;\n\n        /* Determine count1 region */\n        for (; i > 1; i -= 2)\n            if ((ix[i - 1] | ix[i - 2]) != 0)\n                break;\n        gi.count1 = i;\n\n        /* Determines the number of bits to encode the quadruples. */\n        var a1 = 0;\n        var a2 = 0;\n        for (; i > 3; i -= 4) {\n            var p;\n            /* hack to check if all values <= 1 */\n            //throw \"TODO: HACK         if ((((long) ix[i - 1] | (long) ix[i - 2] | (long) ix[i - 3] | (long) ix[i - 4]) & 0xffffffffL) > 1L        \"\n            //if (true) {\n            if (((ix[i - 1] | ix[i - 2] | ix[i - 3] | ix[i - 4]) & 0x7fffffff) > 1) {\n                break;\n            }\n            p = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2 + ix[i - 1];\n            a1 += Tables.t32l[p];\n            a2 += Tables.t33l[p];\n        }\n        var bits = a1;\n        gi.count1table_select = 0;\n        if (a1 > a2) {\n            bits = a2;\n            gi.count1table_select = 1;\n        }\n\n        gi.count1bits = bits;\n        gi.big_values = i;\n        if (i == 0)\n            return bits;\n\n        if (gi.block_type == Encoder.SHORT_TYPE) {\n            a1 = 3 * gfc.scalefac_band.s[3];\n            if (a1 > gi.big_values)\n                a1 = gi.big_values;\n            a2 = gi.big_values;\n\n        } else if (gi.block_type == Encoder.NORM_TYPE) {\n            assert(i <= 576);\n            /* bv_scf has 576 entries (0..575) */\n            a1 = gi.region0_count = gfc.bv_scf[i - 2];\n            a2 = gi.region1_count = gfc.bv_scf[i - 1];\n\n            assert(a1 + a2 + 2 < Encoder.SBPSY_l);\n            a2 = gfc.scalefac_band.l[a1 + a2 + 2];\n            a1 = gfc.scalefac_band.l[a1 + 1];\n            if (a2 < i) {\n                var bi = new Bits(bits);\n                gi.table_select[2] = choose_table(ix, a2, i, bi);\n                bits = bi.bits;\n            }\n        } else {\n            gi.region0_count = 7;\n            /* gi.region1_count = SBPSY_l - 7 - 1; */\n            gi.region1_count = Encoder.SBMAX_l - 1 - 7 - 1;\n            a1 = gfc.scalefac_band.l[7 + 1];\n            a2 = i;\n            if (a1 > a2) {\n                a1 = a2;\n            }\n        }\n\n        /* have to allow for the case when bigvalues < region0 < region1 */\n        /* (and region0, region1 are ignored) */\n        a1 = Math.min(a1, i);\n        a2 = Math.min(a2, i);\n\n        assert(a1 >= 0);\n        assert(a2 >= 0);\n\n        /* Count the number of bits necessary to code the bigvalues region. */\n        if (0 < a1) {\n            var bi = new Bits(bits);\n            gi.table_select[0] = choose_table(ix, 0, a1, bi);\n            bits = bi.bits;\n        }\n        if (a1 < a2) {\n            var bi = new Bits(bits);\n            gi.table_select[1] = choose_table(ix, a1, a2, bi);\n            bits = bi.bits;\n        }\n        if (gfc.use_best_huffman == 2) {\n            gi.part2_3_length = bits;\n            best_huffman_divide(gfc, gi);\n            bits = gi.part2_3_length;\n        }\n\n        if (prev_noise != null) {\n            if (gi.block_type == Encoder.NORM_TYPE) {\n                var sfb = 0;\n                while (gfc.scalefac_band.l[sfb] < gi.big_values) {\n                    sfb++;\n                }\n                prev_noise.sfb_count1 = sfb;\n            }\n        }\n\n        return bits;\n    }\n\n    this.count_bits = function (gfc, xr, gi, prev_noise) {\n        var ix = gi.l3_enc;\n\n        /* since quantize_xrpow uses table lookup, we need to check this first: */\n        var w = (QuantizePVT.IXMAX_VAL) / qupvt.IPOW20(gi.global_gain);\n\n        if (gi.xrpow_max > w)\n            return QuantizePVT.LARGE_BITS;\n\n        quantize_xrpow(xr, ix, qupvt.IPOW20(gi.global_gain), gi, prev_noise);\n\n        if ((gfc.substep_shaping & 2) != 0) {\n            var j = 0;\n            /* 0.634521682242439 = 0.5946*2**(.5*0.1875) */\n            var gain = gi.global_gain + gi.scalefac_scale;\n            var roundfac = 0.634521682242439 / qupvt.IPOW20(gain);\n            for (var sfb = 0; sfb < gi.sfbmax; sfb++) {\n                var width = gi.width[sfb];\n                assert(width >= 0);\n                if (0 == gfc.pseudohalf[sfb]) {\n                    j += width;\n                } else {\n                    var k;\n                    for (k = j, j += width; k < j; ++k) {\n                        ix[k] = (xr[k] >= roundfac) ? ix[k] : 0;\n                    }\n                }\n            }\n        }\n        return this.noquant_count_bits(gfc, gi, prev_noise);\n    }\n\n    /**\n     * re-calculate the best scalefac_compress using scfsi the saved bits are\n     * kept in the bit reservoir.\n     */\n    function recalc_divide_init(gfc, cod_info, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {\n        var bigv = cod_info.big_values;\n\n        for (var r0 = 0; r0 <= 7 + 15; r0++) {\n            r01_bits[r0] = QuantizePVT.LARGE_BITS;\n        }\n\n        for (var r0 = 0; r0 < 16; r0++) {\n            var a1 = gfc.scalefac_band.l[r0 + 1];\n            if (a1 >= bigv)\n                break;\n            var r0bits = 0;\n            var bi = new Bits(r0bits);\n            var r0t = choose_table(ix, 0, a1, bi);\n            r0bits = bi.bits;\n\n            for (var r1 = 0; r1 < 8; r1++) {\n                var a2 = gfc.scalefac_band.l[r0 + r1 + 2];\n                if (a2 >= bigv)\n                    break;\n                var bits = r0bits;\n                bi = new Bits(bits);\n                var r1t = choose_table(ix, a1, a2, bi);\n                bits = bi.bits;\n                if (r01_bits[r0 + r1] > bits) {\n                    r01_bits[r0 + r1] = bits;\n                    r01_div[r0 + r1] = r0;\n                    r0_tbl[r0 + r1] = r0t;\n                    r1_tbl[r0 + r1] = r1t;\n                }\n            }\n        }\n    }\n\n    function recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl) {\n        var bigv = cod_info2.big_values;\n\n        for (var r2 = 2; r2 < Encoder.SBMAX_l + 1; r2++) {\n            var a2 = gfc.scalefac_band.l[r2];\n            if (a2 >= bigv)\n                break;\n            var bits = r01_bits[r2 - 2] + cod_info2.count1bits;\n            if (gi.part2_3_length <= bits)\n                break;\n\n            var bi = new Bits(bits);\n            var r2t = choose_table(ix, a2, bigv, bi);\n            bits = bi.bits;\n            if (gi.part2_3_length <= bits)\n                continue;\n\n            gi.assign(cod_info2);\n            gi.part2_3_length = bits;\n            gi.region0_count = r01_div[r2 - 2];\n            gi.region1_count = r2 - 2 - r01_div[r2 - 2];\n            gi.table_select[0] = r0_tbl[r2 - 2];\n            gi.table_select[1] = r1_tbl[r2 - 2];\n            gi.table_select[2] = r2t;\n        }\n    }\n\n    this.best_huffman_divide = function (gfc, gi) {\n        var cod_info2 = new GrInfo();\n        var ix = gi.l3_enc;\n        var r01_bits = new_int(7 + 15 + 1);\n        var r01_div = new_int(7 + 15 + 1);\n        var r0_tbl = new_int(7 + 15 + 1);\n        var r1_tbl = new_int(7 + 15 + 1);\n\n        /* SHORT BLOCK stuff fails for MPEG2 */\n        if (gi.block_type == Encoder.SHORT_TYPE && gfc.mode_gr == 1)\n            return;\n\n        cod_info2.assign(gi);\n        if (gi.block_type == Encoder.NORM_TYPE) {\n            recalc_divide_init(gfc, gi, ix, r01_bits, r01_div, r0_tbl, r1_tbl);\n            recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div,\n                r0_tbl, r1_tbl);\n        }\n        var i = cod_info2.big_values;\n        if (i == 0 || (ix[i - 2] | ix[i - 1]) > 1)\n            return;\n\n        i = gi.count1 + 2;\n        if (i > 576)\n            return;\n\n        /* Determines the number of bits to encode the quadruples. */\n        cod_info2.assign(gi);\n        cod_info2.count1 = i;\n        var a1 = 0;\n        var a2 = 0;\n\n        assert(i <= 576);\n\n        for (; i > cod_info2.big_values; i -= 4) {\n            var p = ((ix[i - 4] * 2 + ix[i - 3]) * 2 + ix[i - 2]) * 2\n                + ix[i - 1];\n            a1 += Tables.t32l[p];\n            a2 += Tables.t33l[p];\n        }\n        cod_info2.big_values = i;\n\n        cod_info2.count1table_select = 0;\n        if (a1 > a2) {\n            a1 = a2;\n            cod_info2.count1table_select = 1;\n        }\n\n        cod_info2.count1bits = a1;\n\n        if (cod_info2.block_type == Encoder.NORM_TYPE)\n            recalc_divide_sub(gfc, cod_info2, gi, ix, r01_bits, r01_div,\n                r0_tbl, r1_tbl);\n        else {\n            /* Count the number of bits necessary to code the bigvalues region. */\n            cod_info2.part2_3_length = a1;\n            a1 = gfc.scalefac_band.l[7 + 1];\n            if (a1 > i) {\n                a1 = i;\n            }\n            if (a1 > 0) {\n                var bi = new Bits(cod_info2.part2_3_length);\n                cod_info2.table_select[0] = choose_table(ix, 0, a1, bi);\n                cod_info2.part2_3_length = bi.bits;\n            }\n            if (i > a1) {\n                var bi = new Bits(cod_info2.part2_3_length);\n                cod_info2.table_select[1] = choose_table(ix, a1, i, bi);\n                cod_info2.part2_3_length = bi.bits;\n            }\n            if (gi.part2_3_length > cod_info2.part2_3_length)\n                gi.assign(cod_info2);\n        }\n    }\n\n    var slen1_n = [1, 1, 1, 1, 8, 2, 2, 2, 4, 4, 4, 8, 8, 8, 16, 16];\n    var slen2_n = [1, 2, 4, 8, 1, 2, 4, 8, 2, 4, 8, 2, 4, 8, 4, 8];\n    var slen1_tab = [0, 0, 0, 0, 3, 1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4];\n    var slen2_tab = [0, 1, 2, 3, 0, 1, 2, 3, 1, 2, 3, 1, 2, 3, 2, 3];\n    Takehiro.slen1_tab = slen1_tab;\n    Takehiro.slen2_tab = slen2_tab;\n\n    function scfsi_calc(ch, l3_side) {\n        var sfb;\n        var gi = l3_side.tt[1][ch];\n        var g0 = l3_side.tt[0][ch];\n\n        for (var i = 0; i < Tables.scfsi_band.length - 1; i++) {\n            for (sfb = Tables.scfsi_band[i]; sfb < Tables.scfsi_band[i + 1]; sfb++) {\n                if (g0.scalefac[sfb] != gi.scalefac[sfb]\n                    && gi.scalefac[sfb] >= 0)\n                    break;\n            }\n            if (sfb == Tables.scfsi_band[i + 1]) {\n                for (sfb = Tables.scfsi_band[i]; sfb < Tables.scfsi_band[i + 1]; sfb++) {\n                    gi.scalefac[sfb] = -1;\n                }\n                l3_side.scfsi[ch][i] = 1;\n            }\n        }\n        var s1 = 0;\n        var c1 = 0;\n        for (sfb = 0; sfb < 11; sfb++) {\n            if (gi.scalefac[sfb] == -1)\n                continue;\n            c1++;\n            if (s1 < gi.scalefac[sfb])\n                s1 = gi.scalefac[sfb];\n        }\n        var s2 = 0;\n        var c2 = 0;\n        for (; sfb < Encoder.SBPSY_l; sfb++) {\n            if (gi.scalefac[sfb] == -1)\n                continue;\n            c2++;\n            if (s2 < gi.scalefac[sfb])\n                s2 = gi.scalefac[sfb];\n        }\n\n        for (var i = 0; i < 16; i++) {\n            if (s1 < slen1_n[i] && s2 < slen2_n[i]) {\n                var c = slen1_tab[i] * c1 + slen2_tab[i] * c2;\n                if (gi.part2_length > c) {\n                    gi.part2_length = c;\n                    gi.scalefac_compress = i;\n                }\n            }\n        }\n    }\n\n    /**\n     * Find the optimal way to store the scalefactors. Only call this routine\n     * after final scalefactors have been chosen and the channel/granule will\n     * not be re-encoded.\n     */\n    this.best_scalefac_store = function (gfc, gr, ch, l3_side) {\n        /* use scalefac_scale if we can */\n        var gi = l3_side.tt[gr][ch];\n        var sfb, i, j, l;\n        var recalc = 0;\n\n        /*\n         * remove scalefacs from bands with ix=0. This idea comes from the AAC\n         * ISO docs. added mt 3/00\n         */\n        /* check if l3_enc=0 */\n        j = 0;\n        for (sfb = 0; sfb < gi.sfbmax; sfb++) {\n            var width = gi.width[sfb];\n            assert(width >= 0);\n            j += width;\n            for (l = -width; l < 0; l++) {\n                if (gi.l3_enc[l + j] != 0)\n                    break;\n            }\n            if (l == 0)\n                gi.scalefac[sfb] = recalc = -2;\n            /* anything goes. */\n            /*\n             * only best_scalefac_store and calc_scfsi know--and only they\n             * should know--about the magic number -2.\n             */\n        }\n\n        if (0 == gi.scalefac_scale && 0 == gi.preflag) {\n            var s = 0;\n            for (sfb = 0; sfb < gi.sfbmax; sfb++)\n                if (gi.scalefac[sfb] > 0)\n                    s |= gi.scalefac[sfb];\n\n            if (0 == (s & 1) && s != 0) {\n                for (sfb = 0; sfb < gi.sfbmax; sfb++)\n                    if (gi.scalefac[sfb] > 0)\n                        gi.scalefac[sfb] >>= 1;\n\n                gi.scalefac_scale = recalc = 1;\n            }\n        }\n\n        if (0 == gi.preflag && gi.block_type != Encoder.SHORT_TYPE\n            && gfc.mode_gr == 2) {\n            for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++)\n                if (gi.scalefac[sfb] < qupvt.pretab[sfb]\n                    && gi.scalefac[sfb] != -2)\n                    break;\n            if (sfb == Encoder.SBPSY_l) {\n                for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++)\n                    if (gi.scalefac[sfb] > 0)\n                        gi.scalefac[sfb] -= qupvt.pretab[sfb];\n\n                gi.preflag = recalc = 1;\n            }\n        }\n\n        for (i = 0; i < 4; i++)\n            l3_side.scfsi[ch][i] = 0;\n\n        if (gfc.mode_gr == 2 && gr == 1\n            && l3_side.tt[0][ch].block_type != Encoder.SHORT_TYPE\n            && l3_side.tt[1][ch].block_type != Encoder.SHORT_TYPE) {\n            scfsi_calc(ch, l3_side);\n            recalc = 0;\n        }\n        for (sfb = 0; sfb < gi.sfbmax; sfb++) {\n            if (gi.scalefac[sfb] == -2) {\n                gi.scalefac[sfb] = 0;\n                /* if anything goes, then 0 is a good choice */\n            }\n        }\n        if (recalc != 0) {\n            if (gfc.mode_gr == 2) {\n                this.scale_bitcount(gi);\n            } else {\n                this.scale_bitcount_lsf(gfc, gi);\n            }\n        }\n    }\n\n    function all_scalefactors_not_negative(scalefac, n) {\n        for (var i = 0; i < n; ++i) {\n            if (scalefac[i] < 0)\n                return false;\n        }\n        return true;\n    }\n\n    /**\n     * number of bits used to encode scalefacs.\n     *\n     * 18*slen1_tab[i] + 18*slen2_tab[i]\n     */\n    var scale_short = [0, 18, 36, 54, 54, 36, 54, 72,\n        54, 72, 90, 72, 90, 108, 108, 126];\n\n    /**\n     * number of bits used to encode scalefacs.\n     *\n     * 17*slen1_tab[i] + 18*slen2_tab[i]\n     */\n    var scale_mixed = [0, 18, 36, 54, 51, 35, 53, 71,\n        52, 70, 88, 69, 87, 105, 104, 122];\n\n    /**\n     * number of bits used to encode scalefacs.\n     *\n     * 11*slen1_tab[i] + 10*slen2_tab[i]\n     */\n    var scale_long = [0, 10, 20, 30, 33, 21, 31, 41, 32, 42,\n        52, 43, 53, 63, 64, 74];\n\n    /**\n     * Also calculates the number of bits necessary to code the scalefactors.\n     */\n    this.scale_bitcount = function (cod_info) {\n        var k, sfb, max_slen1 = 0, max_slen2 = 0;\n\n        /* maximum values */\n        var tab;\n        var scalefac = cod_info.scalefac;\n\n        assert(all_scalefactors_not_negative(scalefac, cod_info.sfbmax));\n\n        if (cod_info.block_type == Encoder.SHORT_TYPE) {\n            tab = scale_short;\n            if (cod_info.mixed_block_flag != 0)\n                tab = scale_mixed;\n        } else { /* block_type == 1,2,or 3 */\n            tab = scale_long;\n            if (0 == cod_info.preflag) {\n                for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++)\n                    if (scalefac[sfb] < qupvt.pretab[sfb])\n                        break;\n\n                if (sfb == Encoder.SBPSY_l) {\n                    cod_info.preflag = 1;\n                    for (sfb = 11; sfb < Encoder.SBPSY_l; sfb++)\n                        scalefac[sfb] -= qupvt.pretab[sfb];\n                }\n            }\n        }\n\n        for (sfb = 0; sfb < cod_info.sfbdivide; sfb++)\n            if (max_slen1 < scalefac[sfb])\n                max_slen1 = scalefac[sfb];\n\n        for (; sfb < cod_info.sfbmax; sfb++)\n            if (max_slen2 < scalefac[sfb])\n                max_slen2 = scalefac[sfb];\n\n        /*\n         * from Takehiro TOMINAGA <tominaga@isoternet.org> 10/99 loop over *all*\n         * posible values of scalefac_compress to find the one which uses the\n         * smallest number of bits. ISO would stop at first valid index\n         */\n        cod_info.part2_length = QuantizePVT.LARGE_BITS;\n        for (k = 0; k < 16; k++) {\n            if (max_slen1 < slen1_n[k] && max_slen2 < slen2_n[k]\n                && cod_info.part2_length > tab[k]) {\n                cod_info.part2_length = tab[k];\n                cod_info.scalefac_compress = k;\n            }\n        }\n        return cod_info.part2_length == QuantizePVT.LARGE_BITS;\n    }\n\n    /**\n     * table of largest scalefactor values for MPEG2\n     */\n    var max_range_sfac_tab = [[15, 15, 7, 7],\n        [15, 15, 7, 0], [7, 3, 0, 0], [15, 31, 31, 0],\n        [7, 7, 7, 0], [3, 3, 0, 0]];\n\n    /**\n     * Also counts the number of bits to encode the scalefacs but for MPEG 2\n     * Lower sampling frequencies (24, 22.05 and 16 kHz.)\n     *\n     * This is reverse-engineered from section 2.4.3.2 of the MPEG2 IS,\n     * \"Audio Decoding Layer III\"\n     */\n    this.scale_bitcount_lsf = function (gfc, cod_info) {\n        var table_number, row_in_table, partition, nr_sfb, window;\n        var over;\n        var i, sfb;\n        var max_sfac = new_int(4);\n//var partition_table;\n        var scalefac = cod_info.scalefac;\n\n        /*\n         * Set partition table. Note that should try to use table one, but do\n         * not yet...\n         */\n        if (cod_info.preflag != 0)\n            table_number = 2;\n        else\n            table_number = 0;\n\n        for (i = 0; i < 4; i++)\n            max_sfac[i] = 0;\n\n        if (cod_info.block_type == Encoder.SHORT_TYPE) {\n            row_in_table = 1;\n            var partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n            for (sfb = 0, partition = 0; partition < 4; partition++) {\n                nr_sfb = partition_table[partition] / 3;\n                for (i = 0; i < nr_sfb; i++, sfb++)\n                    for (window = 0; window < 3; window++)\n                        if (scalefac[sfb * 3 + window] > max_sfac[partition])\n                            max_sfac[partition] = scalefac[sfb * 3 + window];\n            }\n        } else {\n            row_in_table = 0;\n            var partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n            for (sfb = 0, partition = 0; partition < 4; partition++) {\n                nr_sfb = partition_table[partition];\n                for (i = 0; i < nr_sfb; i++, sfb++)\n                    if (scalefac[sfb] > max_sfac[partition])\n                        max_sfac[partition] = scalefac[sfb];\n            }\n        }\n\n        for (over = false, partition = 0; partition < 4; partition++) {\n            if (max_sfac[partition] > max_range_sfac_tab[table_number][partition])\n                over = true;\n        }\n        if (!over) {\n            var slen1, slen2, slen3, slen4;\n\n            cod_info.sfb_partition_table = qupvt.nr_of_sfb_block[table_number][row_in_table];\n            for (partition = 0; partition < 4; partition++)\n                cod_info.slen[partition] = log2tab[max_sfac[partition]];\n\n            /* set scalefac_compress */\n            slen1 = cod_info.slen[0];\n            slen2 = cod_info.slen[1];\n            slen3 = cod_info.slen[2];\n            slen4 = cod_info.slen[3];\n\n            switch (table_number) {\n                case 0:\n                    cod_info.scalefac_compress = (((slen1 * 5) + slen2) << 4)\n                        + (slen3 << 2) + slen4;\n                    break;\n\n                case 1:\n                    cod_info.scalefac_compress = 400 + (((slen1 * 5) + slen2) << 2)\n                        + slen3;\n                    break;\n\n                case 2:\n                    cod_info.scalefac_compress = 500 + (slen1 * 3) + slen2;\n                    break;\n\n                default:\n                    System.err.printf(\"intensity stereo not implemented yet\\n\");\n                    break;\n            }\n        }\n        if (!over) {\n            assert(cod_info.sfb_partition_table != null);\n            cod_info.part2_length = 0;\n            for (partition = 0; partition < 4; partition++)\n                cod_info.part2_length += cod_info.slen[partition]\n                    * cod_info.sfb_partition_table[partition];\n        }\n        return over;\n    }\n\n    /*\n     * Since no bands have been over-amplified, we can set scalefac_compress and\n     * slen[] for the formatter\n     */\n    var log2tab = [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4,\n        4, 4, 4, 4];\n\n    this.huffman_init = function (gfc) {\n        for (var i = 2; i <= 576; i += 2) {\n            var scfb_anz = 0, bv_index;\n            while (gfc.scalefac_band.l[++scfb_anz] < i)\n                ;\n\n            bv_index = subdv_table[scfb_anz][0]; // .region0_count\n            while (gfc.scalefac_band.l[bv_index + 1] > i)\n                bv_index--;\n\n            if (bv_index < 0) {\n                /*\n                 * this is an indication that everything is going to be encoded\n                 * as region0: bigvalues < region0 < region1 so lets set\n                 * region0, region1 to some value larger than bigvalues\n                 */\n                bv_index = subdv_table[scfb_anz][0]; // .region0_count\n            }\n\n            gfc.bv_scf[i - 2] = bv_index;\n\n            bv_index = subdv_table[scfb_anz][1]; // .region1_count\n            while (gfc.scalefac_band.l[bv_index + gfc.bv_scf[i - 2] + 2] > i)\n                bv_index--;\n\n            if (bv_index < 0) {\n                bv_index = subdv_table[scfb_anz][1]; // .region1_count\n            }\n\n            gfc.bv_scf[i - 1] = bv_index;\n        }\n    }\n}\n\nmodule.exports = Takehiro;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}