{"ast":null,"code":"/*\n *  ReplayGainAnalysis - analyzes input samples and give the recommended dB change\n *  Copyright (C) 2001 David Robinson and Glen Sawyer\n *  Improvements and optimizations added by Frank Klemm, and by Marcel Muller \n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n *  concept and filter values by David Robinson (David@Robinson.org)\n *    -- blame him if you think the idea is flawed\n *  original coding by Glen Sawyer (mp3gain@hotmail.com)\n *    -- blame him if you think this runs too slowly, or the coding is otherwise flawed\n *\n *  lots of code improvements by Frank Klemm ( http://www.uni-jena.de/~pfk/mpp/ )\n *    -- credit him for all the _good_ programming ;)\n *\n *\n *  For an explanation of the concepts and the basic algorithms involved, go to:\n *    http://www.replaygain.org/\n */\n\n/*\n *  Here's the deal. Call\n *\n *    InitGainAnalysis ( long samplefreq );\n *\n *  to initialize everything. Call\n *\n *    AnalyzeSamples ( var Float_t*  left_samples,\n *                     var Float_t*  right_samples,\n *                     size_t          num_samples,\n *                     int             num_channels );\n *\n *  as many times as you want, with as many or as few samples as you want.\n *  If mono, pass the sample buffer in through left_samples, leave\n *  right_samples NULL, and make sure num_channels = 1.\n *\n *    GetTitleGain()\n *\n *  will return the recommended dB level change for all samples analyzed\n *  SINCE THE LAST TIME you called GetTitleGain() OR InitGainAnalysis().\n *\n *    GetAlbumGain()\n *\n *  will return the recommended dB level change for all samples analyzed\n *  since InitGainAnalysis() was called and finalized with GetTitleGain().\n *\n *  Pseudo-code to process an album:\n *\n *    Float_t       l_samples [4096];\n *    Float_t       r_samples [4096];\n *    size_t        num_samples;\n *    unsigned int  num_songs;\n *    unsigned int  i;\n *\n *    InitGainAnalysis ( 44100 );\n *    for ( i = 1; i <= num_songs; i++ ) {\n *        while ( ( num_samples = getSongSamples ( song[i], left_samples, right_samples ) ) > 0 )\n *            AnalyzeSamples ( left_samples, right_samples, num_samples, 2 );\n *        fprintf (\"Recommended dB change for song %2d: %+6.2 dB\\n\", i, GetTitleGain() );\n *    }\n *    fprintf (\"Recommended dB change for whole album: %+6.2 dB\\n\", GetAlbumGain() );\n */\n\n/*\n *  So here's the main source of potential code confusion:\n *\n *  The filters applied to the incoming samples are IIR filters,\n *  meaning they rely on up to <filter order> number of previous samples\n *  AND up to <filter order> number of previous filtered samples.\n *\n *  I set up the AnalyzeSamples routine to minimize memory usage and interface\n *  complexity. The speed isn't compromised too much (I don't think), but the\n *  internal complexity is higher than it should be for such a relatively\n *  simple routine.\n *\n *  Optimization/clarity suggestions are welcome.\n */\nvar common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\n/**\n * Table entries per dB\n */\nGainAnalysis.STEPS_per_dB = 100.;\n/**\n * Table entries for 0...MAX_dB (normal max. values are 70...80 dB)\n */\nGainAnalysis.MAX_dB = 120.;\nGainAnalysis.GAIN_NOT_ENOUGH_SAMPLES = -24601;\nGainAnalysis.GAIN_ANALYSIS_ERROR = 0;\nGainAnalysis.GAIN_ANALYSIS_OK = 1;\nGainAnalysis.INIT_GAIN_ANALYSIS_ERROR = 0;\nGainAnalysis.INIT_GAIN_ANALYSIS_OK = 1;\nGainAnalysis.YULE_ORDER = 10;\nGainAnalysis.MAX_ORDER = GainAnalysis.YULE_ORDER;\nGainAnalysis.MAX_SAMP_FREQ = 48000;\nGainAnalysis.RMS_WINDOW_TIME_NUMERATOR = 1;\nGainAnalysis.RMS_WINDOW_TIME_DENOMINATOR = 20;\nGainAnalysis.MAX_SAMPLES_PER_WINDOW = GainAnalysis.MAX_SAMP_FREQ * GainAnalysis.RMS_WINDOW_TIME_NUMERATOR / GainAnalysis.RMS_WINDOW_TIME_DENOMINATOR + 1;\nfunction GainAnalysis() {\n  /**\n   * calibration value for 89dB\n   */\n  var PINK_REF = 64.82;\n  var YULE_ORDER = GainAnalysis.YULE_ORDER;\n  /**\n   * percentile which is louder than the proposed level\n   */\n  var RMS_PERCENTILE = 0.95;\n  /**\n   * maximum allowed sample frequency [Hz]\n   */\n  var MAX_SAMP_FREQ = GainAnalysis.MAX_SAMP_FREQ;\n  var RMS_WINDOW_TIME_NUMERATOR = GainAnalysis.RMS_WINDOW_TIME_NUMERATOR;\n  /**\n   * numerator / denominator = time slice size [s]\n   */\n  var RMS_WINDOW_TIME_DENOMINATOR = GainAnalysis.RMS_WINDOW_TIME_DENOMINATOR;\n  /**\n   * max. Samples per Time slice\n   */\n  var MAX_SAMPLES_PER_WINDOW = GainAnalysis.MAX_SAMPLES_PER_WINDOW;\n  var ABYule = [[0.03857599435200, -3.84664617118067, -0.02160367184185, 7.81501653005538, -0.00123395316851, -11.34170355132042, -0.00009291677959, 13.05504219327545, -0.01655260341619, -12.28759895145294, 0.02161526843274, 9.48293806319790, -0.02074045215285, -5.87257861775999, 0.00594298065125, 2.75465861874613, 0.00306428023191, -0.86984376593551, 0.00012025322027, 0.13919314567432, 0.00288463683916], [0.05418656406430, -3.47845948550071, -0.02911007808948, 6.36317777566148, -0.00848709379851, -8.54751527471874, -0.00851165645469, 9.47693607801280, -0.00834990904936, -8.81498681370155, 0.02245293253339, 6.85401540936998, -0.02596338512915, -4.39470996079559, 0.01624864962975, 2.19611684890774, -0.00240879051584, -0.75104302451432, 0.00674613682247, 0.13149317958808, -0.00187763777362], [0.15457299681924, -2.37898834973084, -0.09331049056315, 2.84868151156327, -0.06247880153653, -2.64577170229825, 0.02163541888798, 2.23697657451713, -0.05588393329856, -1.67148153367602, 0.04781476674921, 1.00595954808547, 0.00222312597743, -0.45953458054983, 0.03174092540049, 0.16378164858596, -0.01390589421898, -0.05032077717131, 0.00651420667831, 0.02347897407020, -0.00881362733839], [0.30296907319327, -1.61273165137247, -0.22613988682123, 1.07977492259970, -0.08587323730772, -0.25656257754070, 0.03282930172664, -0.16276719120440, -0.00915702933434, -0.22638893773906, -0.02364141202522, 0.39120800788284, -0.00584456039913, -0.22138138954925, 0.06276101321749, 0.04500235387352, -0.00000828086748, 0.02005851806501, 0.00205861885564, 0.00302439095741, -0.02950134983287], [0.33642304856132, -1.49858979367799, -0.25572241425570, 0.87350271418188, -0.11828570177555, 0.12205022308084, 0.11921148675203, -0.80774944671438, -0.07834489609479, 0.47854794562326, -0.00469977914380, -0.12453458140019, -0.00589500224440, -0.04067510197014, 0.05724228140351, 0.08333755284107, 0.00832043980773, -0.04237348025746, -0.01635381384540, 0.02977207319925, -0.01760176568150], [0.44915256608450, -0.62820619233671, -0.14351757464547, 0.29661783706366, -0.22784394429749, -0.37256372942400, -0.01419140100551, 0.00213767857124, 0.04078262797139, -0.42029820170918, -0.12398163381748, 0.22199650564824, 0.04097565135648, 0.00613424350682, 0.10478503600251, 0.06747620744683, -0.01863887810927, 0.05784820375801, -0.03193428438915, 0.03222754072173, 0.00541907748707], [0.56619470757641, -1.04800335126349, -0.75464456939302, 0.29156311971249, 0.16242137742230, -0.26806001042947, 0.16744243493672, 0.00819999645858, -0.18901604199609, 0.45054734505008, 0.30931782841830, -0.33032403314006, -0.27562961986224, 0.06739368333110, 0.00647310677246, -0.04784254229033, 0.08647503780351, 0.01639907836189, -0.03788984554840, 0.01807364323573, -0.00588215443421], [0.58100494960553, -0.51035327095184, -0.53174909058578, -0.31863563325245, -0.14289799034253, -0.20256413484477, 0.17520704835522, 0.14728154134330, 0.02377945217615, 0.38952639978999, 0.15558449135573, -0.23313271880868, -0.25344790059353, -0.05246019024463, 0.01628462406333, -0.02505961724053, 0.06920467763959, 0.02442357316099, -0.03721611395801, 0.01818801111503, -0.00749618797172], [0.53648789255105, -0.25049871956020, -0.42163034350696, -0.43193942311114, -0.00275953611929, -0.03424681017675, 0.04267842219415, -0.04678328784242, -0.10214864179676, 0.26408300200955, 0.14590772289388, 0.15113130533216, -0.02459864859345, -0.17556493366449, -0.11202315195388, -0.18823009262115, -0.04060034127000, 0.05477720428674, 0.04788665548180, 0.04704409688120, -0.02217936801134]];\n  var ABButter = [[0.98621192462708, -1.97223372919527, -1.97242384925416, 0.97261396931306, 0.98621192462708], [0.98500175787242, -1.96977855582618, -1.97000351574484, 0.97022847566350, 0.98500175787242], [0.97938932735214, -1.95835380975398, -1.95877865470428, 0.95920349965459, 0.97938932735214], [0.97531843204928, -1.95002759149878, -1.95063686409857, 0.95124613669835, 0.97531843204928], [0.97316523498161, -1.94561023566527, -1.94633046996323, 0.94705070426118, 0.97316523498161], [0.96454515552826, -1.92783286977036, -1.92909031105652, 0.93034775234268, 0.96454515552826], [0.96009142950541, -1.91858953033784, -1.92018285901082, 0.92177618768381, 0.96009142950541], [0.95856916599601, -1.91542108074780, -1.91713833199203, 0.91885558323625, 0.95856916599601], [0.94597685600279, -1.88903307939452, -1.89195371200558, 0.89487434461664, 0.94597685600279]];\n\n  /**\n   * When calling this procedure, make sure that ip[-order] and op[-order]\n   * point to real data\n   */\n  //private void filterYule(final float[] input, int inputPos, float[] output,\n  //int outputPos, int nSamples, final float[] kernel) {\n  function filterYule(input, inputPos, output, outputPos, nSamples, kernel) {\n    while (nSamples-- != 0) {\n      /* 1e-10 is a hack to avoid slowdown because of denormals */\n      output[outputPos] = 1e-10 + input[inputPos + 0] * kernel[0] - output[outputPos - 1] * kernel[1] + input[inputPos - 1] * kernel[2] - output[outputPos - 2] * kernel[3] + input[inputPos - 2] * kernel[4] - output[outputPos - 3] * kernel[5] + input[inputPos - 3] * kernel[6] - output[outputPos - 4] * kernel[7] + input[inputPos - 4] * kernel[8] - output[outputPos - 5] * kernel[9] + input[inputPos - 5] * kernel[10] - output[outputPos - 6] * kernel[11] + input[inputPos - 6] * kernel[12] - output[outputPos - 7] * kernel[13] + input[inputPos - 7] * kernel[14] - output[outputPos - 8] * kernel[15] + input[inputPos - 8] * kernel[16] - output[outputPos - 9] * kernel[17] + input[inputPos - 9] * kernel[18] - output[outputPos - 10] * kernel[19] + input[inputPos - 10] * kernel[20];\n      ++outputPos;\n      ++inputPos;\n    }\n  }\n\n  //private void filterButter(final float[] input, int inputPos,\n  //    float[] output, int outputPos, int nSamples, final float[] kernel) {\n  function filterButter(input, inputPos, output, outputPos, nSamples, kernel) {\n    while (nSamples-- != 0) {\n      output[outputPos] = input[inputPos + 0] * kernel[0] - output[outputPos - 1] * kernel[1] + input[inputPos - 1] * kernel[2] - output[outputPos - 2] * kernel[3] + input[inputPos - 2] * kernel[4];\n      ++outputPos;\n      ++inputPos;\n    }\n  }\n\n  /**\n   * @return INIT_GAIN_ANALYSIS_OK if successful, INIT_GAIN_ANALYSIS_ERROR if\n   *         not\n   */\n  function ResetSampleFrequency(rgData, samplefreq) {\n    /* zero out initial values */\n    for (var i = 0; i < MAX_ORDER; i++) rgData.linprebuf[i] = rgData.lstepbuf[i] = rgData.loutbuf[i] = rgData.rinprebuf[i] = rgData.rstepbuf[i] = rgData.routbuf[i] = 0.;\n    switch (0 | samplefreq) {\n      case 48000:\n        rgData.reqindex = 0;\n        break;\n      case 44100:\n        rgData.reqindex = 1;\n        break;\n      case 32000:\n        rgData.reqindex = 2;\n        break;\n      case 24000:\n        rgData.reqindex = 3;\n        break;\n      case 22050:\n        rgData.reqindex = 4;\n        break;\n      case 16000:\n        rgData.reqindex = 5;\n        break;\n      case 12000:\n        rgData.reqindex = 6;\n        break;\n      case 11025:\n        rgData.reqindex = 7;\n        break;\n      case 8000:\n        rgData.reqindex = 8;\n        break;\n      default:\n        return INIT_GAIN_ANALYSIS_ERROR;\n    }\n    rgData.sampleWindow = 0 | (samplefreq * RMS_WINDOW_TIME_NUMERATOR + RMS_WINDOW_TIME_DENOMINATOR - 1) / RMS_WINDOW_TIME_DENOMINATOR;\n    rgData.lsum = 0.;\n    rgData.rsum = 0.;\n    rgData.totsamp = 0;\n    Arrays.ill(rgData.A, 0);\n    return INIT_GAIN_ANALYSIS_OK;\n  }\n  this.InitGainAnalysis = function (rgData, samplefreq) {\n    if (ResetSampleFrequency(rgData, samplefreq) != INIT_GAIN_ANALYSIS_OK) {\n      return INIT_GAIN_ANALYSIS_ERROR;\n    }\n    rgData.linpre = MAX_ORDER;\n    rgData.rinpre = MAX_ORDER;\n    rgData.lstep = MAX_ORDER;\n    rgData.rstep = MAX_ORDER;\n    rgData.lout = MAX_ORDER;\n    rgData.rout = MAX_ORDER;\n    Arrays.fill(rgData.B, 0);\n    return INIT_GAIN_ANALYSIS_OK;\n  };\n\n  /**\n   * square\n   */\n  function fsqr(d) {\n    return d * d;\n  }\n  this.AnalyzeSamples = function (rgData, left_samples, left_samplesPos, right_samples, right_samplesPos, num_samples, num_channels) {\n    var curleft;\n    var curleftBase;\n    var curright;\n    var currightBase;\n    var batchsamples;\n    var cursamples;\n    var cursamplepos;\n    if (num_samples == 0) return GAIN_ANALYSIS_OK;\n    cursamplepos = 0;\n    batchsamples = num_samples;\n    switch (num_channels) {\n      case 1:\n        right_samples = left_samples;\n        right_samplesPos = left_samplesPos;\n        break;\n      case 2:\n        break;\n      default:\n        return GAIN_ANALYSIS_ERROR;\n    }\n    if (num_samples < MAX_ORDER) {\n      System.arraycopy(left_samples, left_samplesPos, rgData.linprebuf, MAX_ORDER, num_samples);\n      System.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf, MAX_ORDER, num_samples);\n    } else {\n      System.arraycopy(left_samples, left_samplesPos, rgData.linprebuf, MAX_ORDER, MAX_ORDER);\n      System.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf, MAX_ORDER, MAX_ORDER);\n    }\n    while (batchsamples > 0) {\n      cursamples = batchsamples > rgData.sampleWindow - rgData.totsamp ? rgData.sampleWindow - rgData.totsamp : batchsamples;\n      if (cursamplepos < MAX_ORDER) {\n        curleft = rgData.linpre + cursamplepos;\n        curleftBase = rgData.linprebuf;\n        curright = rgData.rinpre + cursamplepos;\n        currightBase = rgData.rinprebuf;\n        if (cursamples > MAX_ORDER - cursamplepos) cursamples = MAX_ORDER - cursamplepos;\n      } else {\n        curleft = left_samplesPos + cursamplepos;\n        curleftBase = left_samples;\n        curright = right_samplesPos + cursamplepos;\n        currightBase = right_samples;\n      }\n      filterYule(curleftBase, curleft, rgData.lstepbuf, rgData.lstep + rgData.totsamp, cursamples, ABYule[rgData.reqindex]);\n      filterYule(currightBase, curright, rgData.rstepbuf, rgData.rstep + rgData.totsamp, cursamples, ABYule[rgData.reqindex]);\n      filterButter(rgData.lstepbuf, rgData.lstep + rgData.totsamp, rgData.loutbuf, rgData.lout + rgData.totsamp, cursamples, ABButter[rgData.reqindex]);\n      filterButter(rgData.rstepbuf, rgData.rstep + rgData.totsamp, rgData.routbuf, rgData.rout + rgData.totsamp, cursamples, ABButter[rgData.reqindex]);\n      curleft = rgData.lout + rgData.totsamp;\n      /* Get the squared values */\n      curleftBase = rgData.loutbuf;\n      curright = rgData.rout + rgData.totsamp;\n      currightBase = rgData.routbuf;\n      var i = cursamples % 8;\n      while (i-- != 0) {\n        rgData.lsum += fsqr(curleftBase[curleft++]);\n        rgData.rsum += fsqr(currightBase[curright++]);\n      }\n      i = cursamples / 8;\n      while (i-- != 0) {\n        rgData.lsum += fsqr(curleftBase[curleft + 0]) + fsqr(curleftBase[curleft + 1]) + fsqr(curleftBase[curleft + 2]) + fsqr(curleftBase[curleft + 3]) + fsqr(curleftBase[curleft + 4]) + fsqr(curleftBase[curleft + 5]) + fsqr(curleftBase[curleft + 6]) + fsqr(curleftBase[curleft + 7]);\n        curleft += 8;\n        rgData.rsum += fsqr(currightBase[curright + 0]) + fsqr(currightBase[curright + 1]) + fsqr(currightBase[curright + 2]) + fsqr(currightBase[curright + 3]) + fsqr(currightBase[curright + 4]) + fsqr(currightBase[curright + 5]) + fsqr(currightBase[curright + 6]) + fsqr(currightBase[curright + 7]);\n        curright += 8;\n      }\n      batchsamples -= cursamples;\n      cursamplepos += cursamples;\n      rgData.totsamp += cursamples;\n      if (rgData.totsamp == rgData.sampleWindow) {\n        /* Get the Root Mean Square (RMS) for this set of samples */\n        var val = GainAnalysis.STEPS_per_dB * 10. * Math.log10((rgData.lsum + rgData.rsum) / rgData.totsamp * 0.5 + 1.e-37);\n        var ival = val <= 0 ? 0 : 0 | val;\n        if (ival >= rgData.A.length) ival = rgData.A.length - 1;\n        rgData.A[ival]++;\n        rgData.lsum = rgData.rsum = 0.;\n        System.arraycopy(rgData.loutbuf, rgData.totsamp, rgData.loutbuf, 0, MAX_ORDER);\n        System.arraycopy(rgData.routbuf, rgData.totsamp, rgData.routbuf, 0, MAX_ORDER);\n        System.arraycopy(rgData.lstepbuf, rgData.totsamp, rgData.lstepbuf, 0, MAX_ORDER);\n        System.arraycopy(rgData.rstepbuf, rgData.totsamp, rgData.rstepbuf, 0, MAX_ORDER);\n        rgData.totsamp = 0;\n      }\n      if (rgData.totsamp > rgData.sampleWindow) {\n        /*\n         * somehow I really screwed up: Error in programming! Contact\n         * author about totsamp > sampleWindow\n         */\n        return GAIN_ANALYSIS_ERROR;\n      }\n    }\n    if (num_samples < MAX_ORDER) {\n      System.arraycopy(rgData.linprebuf, num_samples, rgData.linprebuf, 0, MAX_ORDER - num_samples);\n      System.arraycopy(rgData.rinprebuf, num_samples, rgData.rinprebuf, 0, MAX_ORDER - num_samples);\n      System.arraycopy(left_samples, left_samplesPos, rgData.linprebuf, MAX_ORDER - num_samples, num_samples);\n      System.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf, MAX_ORDER - num_samples, num_samples);\n    } else {\n      System.arraycopy(left_samples, left_samplesPos + num_samples - MAX_ORDER, rgData.linprebuf, 0, MAX_ORDER);\n      System.arraycopy(right_samples, right_samplesPos + num_samples - MAX_ORDER, rgData.rinprebuf, 0, MAX_ORDER);\n    }\n    return GAIN_ANALYSIS_OK;\n  };\n  function analyzeResult(Array, len) {\n    var i;\n    var elems = 0;\n    for (i = 0; i < len; i++) elems += Array[i];\n    if (elems == 0) return GAIN_NOT_ENOUGH_SAMPLES;\n    var upper = 0 | Math.ceil(elems * (1. - RMS_PERCENTILE));\n    for (i = len; i-- > 0;) {\n      if ((upper -= Array[i]) <= 0) break;\n    }\n\n    //return (float) ((float) PINK_REF - (float) i / (float) STEPS_per_dB);\n    return PINK_REF - i / GainAnalysis.STEPS_per_dB;\n  }\n  this.GetTitleGain = function (rgData) {\n    var retval = analyzeResult(rgData.A, rgData.A.length);\n    for (var i = 0; i < rgData.A.length; i++) {\n      rgData.B[i] += rgData.A[i];\n      rgData.A[i] = 0;\n    }\n    for (var i = 0; i < MAX_ORDER; i++) rgData.linprebuf[i] = rgData.lstepbuf[i] = rgData.loutbuf[i] = rgData.rinprebuf[i] = rgData.rstepbuf[i] = rgData.routbuf[i] = 0.;\n    rgData.totsamp = 0;\n    rgData.lsum = rgData.rsum = 0.;\n    return retval;\n  };\n}\nmodule.exports = GainAnalysis;","map":{"version":3,"names":["common","require","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","GainAnalysis","STEPS_per_dB","MAX_dB","GAIN_NOT_ENOUGH_SAMPLES","GAIN_ANALYSIS_ERROR","GAIN_ANALYSIS_OK","INIT_GAIN_ANALYSIS_ERROR","INIT_GAIN_ANALYSIS_OK","YULE_ORDER","MAX_ORDER","MAX_SAMP_FREQ","RMS_WINDOW_TIME_NUMERATOR","RMS_WINDOW_TIME_DENOMINATOR","MAX_SAMPLES_PER_WINDOW","PINK_REF","RMS_PERCENTILE","ABYule","ABButter","filterYule","input","inputPos","output","outputPos","nSamples","kernel","filterButter","ResetSampleFrequency","rgData","samplefreq","i","linprebuf","lstepbuf","loutbuf","rinprebuf","rstepbuf","routbuf","reqindex","sampleWindow","lsum","rsum","totsamp","ill","A","InitGainAnalysis","linpre","rinpre","lstep","rstep","lout","rout","fill","B","fsqr","d","AnalyzeSamples","left_samples","left_samplesPos","right_samples","right_samplesPos","num_samples","num_channels","curleft","curleftBase","curright","currightBase","batchsamples","cursamples","cursamplepos","arraycopy","val","Math","log10","ival","length","analyzeResult","Array","len","elems","upper","ceil","GetTitleGain","retval","module","exports"],"sources":["D:/代码/vscodeProjects/AiEducation/vue_aieducation/node_modules/lamejs/src/js/GainAnalysis.js"],"sourcesContent":["/*\n *  ReplayGainAnalysis - analyzes input samples and give the recommended dB change\n *  Copyright (C) 2001 David Robinson and Glen Sawyer\n *  Improvements and optimizations added by Frank Klemm, and by Marcel Muller \n *\n *  This library is free software; you can redistribute it and/or\n *  modify it under the terms of the GNU Lesser General Public\n *  License as published by the Free Software Foundation; either\n *  version 2.1 of the License, or (at your option) any later version.\n *\n *  This library is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n *  Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n *\n *  concept and filter values by David Robinson (David@Robinson.org)\n *    -- blame him if you think the idea is flawed\n *  original coding by Glen Sawyer (mp3gain@hotmail.com)\n *    -- blame him if you think this runs too slowly, or the coding is otherwise flawed\n *\n *  lots of code improvements by Frank Klemm ( http://www.uni-jena.de/~pfk/mpp/ )\n *    -- credit him for all the _good_ programming ;)\n *\n *\n *  For an explanation of the concepts and the basic algorithms involved, go to:\n *    http://www.replaygain.org/\n */\n\n/*\n *  Here's the deal. Call\n *\n *    InitGainAnalysis ( long samplefreq );\n *\n *  to initialize everything. Call\n *\n *    AnalyzeSamples ( var Float_t*  left_samples,\n *                     var Float_t*  right_samples,\n *                     size_t          num_samples,\n *                     int             num_channels );\n *\n *  as many times as you want, with as many or as few samples as you want.\n *  If mono, pass the sample buffer in through left_samples, leave\n *  right_samples NULL, and make sure num_channels = 1.\n *\n *    GetTitleGain()\n *\n *  will return the recommended dB level change for all samples analyzed\n *  SINCE THE LAST TIME you called GetTitleGain() OR InitGainAnalysis().\n *\n *    GetAlbumGain()\n *\n *  will return the recommended dB level change for all samples analyzed\n *  since InitGainAnalysis() was called and finalized with GetTitleGain().\n *\n *  Pseudo-code to process an album:\n *\n *    Float_t       l_samples [4096];\n *    Float_t       r_samples [4096];\n *    size_t        num_samples;\n *    unsigned int  num_songs;\n *    unsigned int  i;\n *\n *    InitGainAnalysis ( 44100 );\n *    for ( i = 1; i <= num_songs; i++ ) {\n *        while ( ( num_samples = getSongSamples ( song[i], left_samples, right_samples ) ) > 0 )\n *            AnalyzeSamples ( left_samples, right_samples, num_samples, 2 );\n *        fprintf (\"Recommended dB change for song %2d: %+6.2 dB\\n\", i, GetTitleGain() );\n *    }\n *    fprintf (\"Recommended dB change for whole album: %+6.2 dB\\n\", GetAlbumGain() );\n */\n\n/*\n *  So here's the main source of potential code confusion:\n *\n *  The filters applied to the incoming samples are IIR filters,\n *  meaning they rely on up to <filter order> number of previous samples\n *  AND up to <filter order> number of previous filtered samples.\n *\n *  I set up the AnalyzeSamples routine to minimize memory usage and interface\n *  complexity. The speed isn't compromised too much (I don't think), but the\n *  internal complexity is higher than it should be for such a relatively\n *  simple routine.\n *\n *  Optimization/clarity suggestions are welcome.\n */\nvar common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\n/**\n * Table entries per dB\n */\nGainAnalysis.STEPS_per_dB = 100.;\n/**\n * Table entries for 0...MAX_dB (normal max. values are 70...80 dB)\n */\nGainAnalysis.MAX_dB = 120.;\nGainAnalysis.GAIN_NOT_ENOUGH_SAMPLES = -24601;\nGainAnalysis.GAIN_ANALYSIS_ERROR = 0;\nGainAnalysis.GAIN_ANALYSIS_OK = 1;\nGainAnalysis.INIT_GAIN_ANALYSIS_ERROR = 0;\nGainAnalysis.INIT_GAIN_ANALYSIS_OK = 1;\n\nGainAnalysis.YULE_ORDER = 10;\nGainAnalysis.MAX_ORDER = GainAnalysis.YULE_ORDER;\n\nGainAnalysis.MAX_SAMP_FREQ = 48000;\nGainAnalysis.RMS_WINDOW_TIME_NUMERATOR = 1;\nGainAnalysis.RMS_WINDOW_TIME_DENOMINATOR = 20;\nGainAnalysis.MAX_SAMPLES_PER_WINDOW = ((GainAnalysis.MAX_SAMP_FREQ * GainAnalysis.RMS_WINDOW_TIME_NUMERATOR) / GainAnalysis.RMS_WINDOW_TIME_DENOMINATOR + 1);\n\nfunction GainAnalysis() {\n    /**\n     * calibration value for 89dB\n     */\n    var PINK_REF = 64.82;\n\n    var YULE_ORDER = GainAnalysis.YULE_ORDER;\n    /**\n     * percentile which is louder than the proposed level\n     */\n    var RMS_PERCENTILE = 0.95;\n    /**\n     * maximum allowed sample frequency [Hz]\n     */\n    var MAX_SAMP_FREQ = GainAnalysis.MAX_SAMP_FREQ;\n    var RMS_WINDOW_TIME_NUMERATOR = GainAnalysis.RMS_WINDOW_TIME_NUMERATOR;\n    /**\n     * numerator / denominator = time slice size [s]\n     */\n    var RMS_WINDOW_TIME_DENOMINATOR = GainAnalysis.RMS_WINDOW_TIME_DENOMINATOR;\n    /**\n     * max. Samples per Time slice\n     */\n    var MAX_SAMPLES_PER_WINDOW = GainAnalysis.MAX_SAMPLES_PER_WINDOW;\n\n\n    var ABYule = [\n        [0.03857599435200, -3.84664617118067, -0.02160367184185,\n            7.81501653005538, -0.00123395316851, -11.34170355132042,\n            -0.00009291677959, 13.05504219327545, -0.01655260341619,\n            -12.28759895145294, 0.02161526843274, 9.48293806319790,\n            -0.02074045215285, -5.87257861775999, 0.00594298065125,\n            2.75465861874613, 0.00306428023191, -0.86984376593551,\n            0.00012025322027, 0.13919314567432, 0.00288463683916],\n        [0.05418656406430, -3.47845948550071, -0.02911007808948,\n            6.36317777566148, -0.00848709379851, -8.54751527471874,\n            -0.00851165645469, 9.47693607801280, -0.00834990904936,\n            -8.81498681370155, 0.02245293253339, 6.85401540936998,\n            -0.02596338512915, -4.39470996079559, 0.01624864962975,\n            2.19611684890774, -0.00240879051584, -0.75104302451432,\n            0.00674613682247, 0.13149317958808, -0.00187763777362],\n        [0.15457299681924, -2.37898834973084, -0.09331049056315,\n            2.84868151156327, -0.06247880153653, -2.64577170229825,\n            0.02163541888798, 2.23697657451713, -0.05588393329856,\n            -1.67148153367602, 0.04781476674921, 1.00595954808547,\n            0.00222312597743, -0.45953458054983, 0.03174092540049,\n            0.16378164858596, -0.01390589421898, -0.05032077717131,\n            0.00651420667831, 0.02347897407020, -0.00881362733839],\n        [0.30296907319327, -1.61273165137247, -0.22613988682123,\n            1.07977492259970, -0.08587323730772, -0.25656257754070,\n            0.03282930172664, -0.16276719120440, -0.00915702933434,\n            -0.22638893773906, -0.02364141202522, 0.39120800788284,\n            -0.00584456039913, -0.22138138954925, 0.06276101321749,\n            0.04500235387352, -0.00000828086748, 0.02005851806501,\n            0.00205861885564, 0.00302439095741, -0.02950134983287],\n        [0.33642304856132, -1.49858979367799, -0.25572241425570,\n            0.87350271418188, -0.11828570177555, 0.12205022308084,\n            0.11921148675203, -0.80774944671438, -0.07834489609479,\n            0.47854794562326, -0.00469977914380, -0.12453458140019,\n            -0.00589500224440, -0.04067510197014, 0.05724228140351,\n            0.08333755284107, 0.00832043980773, -0.04237348025746,\n            -0.01635381384540, 0.02977207319925, -0.01760176568150],\n        [0.44915256608450, -0.62820619233671, -0.14351757464547,\n            0.29661783706366, -0.22784394429749, -0.37256372942400,\n            -0.01419140100551, 0.00213767857124, 0.04078262797139,\n            -0.42029820170918, -0.12398163381748, 0.22199650564824,\n            0.04097565135648, 0.00613424350682, 0.10478503600251,\n            0.06747620744683, -0.01863887810927, 0.05784820375801,\n            -0.03193428438915, 0.03222754072173, 0.00541907748707],\n        [0.56619470757641, -1.04800335126349, -0.75464456939302,\n            0.29156311971249, 0.16242137742230, -0.26806001042947,\n            0.16744243493672, 0.00819999645858, -0.18901604199609,\n            0.45054734505008, 0.30931782841830, -0.33032403314006,\n            -0.27562961986224, 0.06739368333110, 0.00647310677246,\n            -0.04784254229033, 0.08647503780351, 0.01639907836189,\n            -0.03788984554840, 0.01807364323573, -0.00588215443421],\n        [0.58100494960553, -0.51035327095184, -0.53174909058578,\n            -0.31863563325245, -0.14289799034253, -0.20256413484477,\n            0.17520704835522, 0.14728154134330, 0.02377945217615,\n            0.38952639978999, 0.15558449135573, -0.23313271880868,\n            -0.25344790059353, -0.05246019024463, 0.01628462406333,\n            -0.02505961724053, 0.06920467763959, 0.02442357316099,\n            -0.03721611395801, 0.01818801111503, -0.00749618797172],\n        [0.53648789255105, -0.25049871956020, -0.42163034350696,\n            -0.43193942311114, -0.00275953611929, -0.03424681017675,\n            0.04267842219415, -0.04678328784242, -0.10214864179676,\n            0.26408300200955, 0.14590772289388, 0.15113130533216,\n            -0.02459864859345, -0.17556493366449, -0.11202315195388,\n            -0.18823009262115, -0.04060034127000, 0.05477720428674,\n            0.04788665548180, 0.04704409688120, -0.02217936801134]];\n\n    var ABButter = [\n        [0.98621192462708, -1.97223372919527, -1.97242384925416,\n            0.97261396931306, 0.98621192462708],\n        [0.98500175787242, -1.96977855582618, -1.97000351574484,\n            0.97022847566350, 0.98500175787242],\n        [0.97938932735214, -1.95835380975398, -1.95877865470428,\n            0.95920349965459, 0.97938932735214],\n        [0.97531843204928, -1.95002759149878, -1.95063686409857,\n            0.95124613669835, 0.97531843204928],\n        [0.97316523498161, -1.94561023566527, -1.94633046996323,\n            0.94705070426118, 0.97316523498161],\n        [0.96454515552826, -1.92783286977036, -1.92909031105652,\n            0.93034775234268, 0.96454515552826],\n        [0.96009142950541, -1.91858953033784, -1.92018285901082,\n            0.92177618768381, 0.96009142950541],\n        [0.95856916599601, -1.91542108074780, -1.91713833199203,\n            0.91885558323625, 0.95856916599601],\n        [0.94597685600279, -1.88903307939452, -1.89195371200558,\n            0.89487434461664, 0.94597685600279]];\n\n\n    /**\n     * When calling this procedure, make sure that ip[-order] and op[-order]\n     * point to real data\n     */\n    //private void filterYule(final float[] input, int inputPos, float[] output,\n    //int outputPos, int nSamples, final float[] kernel) {\n    function filterYule(input, inputPos, output, outputPos, nSamples, kernel) {\n\n        while ((nSamples--) != 0) {\n            /* 1e-10 is a hack to avoid slowdown because of denormals */\n            output[outputPos] = 1e-10 + input[inputPos + 0] * kernel[0]\n                - output[outputPos - 1] * kernel[1] + input[inputPos - 1]\n                * kernel[2] - output[outputPos - 2] * kernel[3]\n                + input[inputPos - 2] * kernel[4] - output[outputPos - 3]\n                * kernel[5] + input[inputPos - 3] * kernel[6]\n                - output[outputPos - 4] * kernel[7] + input[inputPos - 4]\n                * kernel[8] - output[outputPos - 5] * kernel[9]\n                + input[inputPos - 5] * kernel[10] - output[outputPos - 6]\n                * kernel[11] + input[inputPos - 6] * kernel[12]\n                - output[outputPos - 7] * kernel[13] + input[inputPos - 7]\n                * kernel[14] - output[outputPos - 8] * kernel[15]\n                + input[inputPos - 8] * kernel[16] - output[outputPos - 9]\n                * kernel[17] + input[inputPos - 9] * kernel[18]\n                - output[outputPos - 10] * kernel[19]\n                + input[inputPos - 10] * kernel[20];\n            ++outputPos;\n            ++inputPos;\n        }\n    }\n\n//private void filterButter(final float[] input, int inputPos,\n//    float[] output, int outputPos, int nSamples, final float[] kernel) {\n    function filterButter(input, inputPos, output, outputPos, nSamples, kernel) {\n\n        while ((nSamples--) != 0) {\n            output[outputPos] = input[inputPos + 0] * kernel[0]\n                - output[outputPos - 1] * kernel[1] + input[inputPos - 1]\n                * kernel[2] - output[outputPos - 2] * kernel[3]\n                + input[inputPos - 2] * kernel[4];\n            ++outputPos;\n            ++inputPos;\n        }\n    }\n\n    /**\n     * @return INIT_GAIN_ANALYSIS_OK if successful, INIT_GAIN_ANALYSIS_ERROR if\n     *         not\n     */\n    function ResetSampleFrequency(rgData, samplefreq) {\n        /* zero out initial values */\n        for (var i = 0; i < MAX_ORDER; i++)\n            rgData.linprebuf[i] = rgData.lstepbuf[i] = rgData.loutbuf[i] = rgData.rinprebuf[i] = rgData.rstepbuf[i] = rgData.routbuf[i] = 0.;\n\n        switch (0 | (samplefreq)) {\n            case 48000:\n                rgData.reqindex = 0;\n                break;\n            case 44100:\n                rgData.reqindex = 1;\n                break;\n            case 32000:\n                rgData.reqindex = 2;\n                break;\n            case 24000:\n                rgData.reqindex = 3;\n                break;\n            case 22050:\n                rgData.reqindex = 4;\n                break;\n            case 16000:\n                rgData.reqindex = 5;\n                break;\n            case 12000:\n                rgData.reqindex = 6;\n                break;\n            case 11025:\n                rgData.reqindex = 7;\n                break;\n            case 8000:\n                rgData.reqindex = 8;\n                break;\n            default:\n                return INIT_GAIN_ANALYSIS_ERROR;\n        }\n\n        rgData.sampleWindow = 0 | ((samplefreq * RMS_WINDOW_TIME_NUMERATOR\n            + RMS_WINDOW_TIME_DENOMINATOR - 1) / RMS_WINDOW_TIME_DENOMINATOR);\n\n        rgData.lsum = 0.;\n        rgData.rsum = 0.;\n        rgData.totsamp = 0;\n\n        Arrays.ill(rgData.A, 0);\n\n        return INIT_GAIN_ANALYSIS_OK;\n    }\n\n    this.InitGainAnalysis = function (rgData, samplefreq) {\n        if (ResetSampleFrequency(rgData, samplefreq) != INIT_GAIN_ANALYSIS_OK) {\n            return INIT_GAIN_ANALYSIS_ERROR;\n        }\n\n        rgData.linpre = MAX_ORDER;\n        rgData.rinpre = MAX_ORDER;\n        rgData.lstep = MAX_ORDER;\n        rgData.rstep = MAX_ORDER;\n        rgData.lout = MAX_ORDER;\n        rgData.rout = MAX_ORDER;\n\n        Arrays.fill(rgData.B, 0);\n\n        return INIT_GAIN_ANALYSIS_OK;\n    };\n\n    /**\n     * square\n     */\n    function fsqr(d) {\n        return d * d;\n    }\n\n    this.AnalyzeSamples = function (rgData, left_samples, left_samplesPos, right_samples, right_samplesPos, num_samples,\n                                    num_channels) {\n        var curleft;\n        var curleftBase;\n        var curright;\n        var currightBase;\n        var batchsamples;\n        var cursamples;\n        var cursamplepos;\n\n        if (num_samples == 0)\n            return GAIN_ANALYSIS_OK;\n\n        cursamplepos = 0;\n        batchsamples = num_samples;\n\n        switch (num_channels) {\n            case 1:\n                right_samples = left_samples;\n                right_samplesPos = left_samplesPos;\n                break;\n            case 2:\n                break;\n            default:\n                return GAIN_ANALYSIS_ERROR;\n        }\n\n        if (num_samples < MAX_ORDER) {\n            System.arraycopy(left_samples, left_samplesPos, rgData.linprebuf,\n                MAX_ORDER, num_samples);\n            System.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf,\n                MAX_ORDER, num_samples);\n        } else {\n            System.arraycopy(left_samples, left_samplesPos, rgData.linprebuf,\n                MAX_ORDER, MAX_ORDER);\n            System.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf,\n                MAX_ORDER, MAX_ORDER);\n        }\n\n        while (batchsamples > 0) {\n            cursamples = batchsamples > rgData.sampleWindow - rgData.totsamp ? rgData.sampleWindow\n            - rgData.totsamp\n                : batchsamples;\n            if (cursamplepos < MAX_ORDER) {\n                curleft = rgData.linpre + cursamplepos;\n                curleftBase = rgData.linprebuf;\n                curright = rgData.rinpre + cursamplepos;\n                currightBase = rgData.rinprebuf;\n                if (cursamples > MAX_ORDER - cursamplepos)\n                    cursamples = MAX_ORDER - cursamplepos;\n            } else {\n                curleft = left_samplesPos + cursamplepos;\n                curleftBase = left_samples;\n                curright = right_samplesPos + cursamplepos;\n                currightBase = right_samples;\n            }\n\n            filterYule(curleftBase, curleft, rgData.lstepbuf, rgData.lstep\n                + rgData.totsamp, cursamples, ABYule[rgData.reqindex]);\n            filterYule(currightBase, curright, rgData.rstepbuf, rgData.rstep\n                + rgData.totsamp, cursamples, ABYule[rgData.reqindex]);\n\n            filterButter(rgData.lstepbuf, rgData.lstep + rgData.totsamp,\n                rgData.loutbuf, rgData.lout + rgData.totsamp, cursamples,\n                ABButter[rgData.reqindex]);\n            filterButter(rgData.rstepbuf, rgData.rstep + rgData.totsamp,\n                rgData.routbuf, rgData.rout + rgData.totsamp, cursamples,\n                ABButter[rgData.reqindex]);\n\n            curleft = rgData.lout + rgData.totsamp;\n            /* Get the squared values */\n            curleftBase = rgData.loutbuf;\n            curright = rgData.rout + rgData.totsamp;\n            currightBase = rgData.routbuf;\n\n            var i = cursamples % 8;\n            while ((i--) != 0) {\n                rgData.lsum += fsqr(curleftBase[curleft++]);\n                rgData.rsum += fsqr(currightBase[curright++]);\n            }\n            i = cursamples / 8;\n            while ((i--) != 0) {\n                rgData.lsum += fsqr(curleftBase[curleft + 0])\n                    + fsqr(curleftBase[curleft + 1])\n                    + fsqr(curleftBase[curleft + 2])\n                    + fsqr(curleftBase[curleft + 3])\n                    + fsqr(curleftBase[curleft + 4])\n                    + fsqr(curleftBase[curleft + 5])\n                    + fsqr(curleftBase[curleft + 6])\n                    + fsqr(curleftBase[curleft + 7]);\n                curleft += 8;\n                rgData.rsum += fsqr(currightBase[curright + 0])\n                    + fsqr(currightBase[curright + 1])\n                    + fsqr(currightBase[curright + 2])\n                    + fsqr(currightBase[curright + 3])\n                    + fsqr(currightBase[curright + 4])\n                    + fsqr(currightBase[curright + 5])\n                    + fsqr(currightBase[curright + 6])\n                    + fsqr(currightBase[curright + 7]);\n                curright += 8;\n            }\n\n            batchsamples -= cursamples;\n            cursamplepos += cursamples;\n            rgData.totsamp += cursamples;\n            if (rgData.totsamp == rgData.sampleWindow) {\n                /* Get the Root Mean Square (RMS) for this set of samples */\n                var val = GainAnalysis.STEPS_per_dB\n                    * 10.\n                    * Math.log10((rgData.lsum + rgData.rsum)\n                        / rgData.totsamp * 0.5 + 1.e-37);\n                var ival = (val <= 0) ? 0 : 0 | val;\n                if (ival >= rgData.A.length)\n                    ival = rgData.A.length - 1;\n                rgData.A[ival]++;\n                rgData.lsum = rgData.rsum = 0.;\n\n                System.arraycopy(rgData.loutbuf, rgData.totsamp,\n                    rgData.loutbuf, 0, MAX_ORDER);\n                System.arraycopy(rgData.routbuf, rgData.totsamp,\n                    rgData.routbuf, 0, MAX_ORDER);\n                System.arraycopy(rgData.lstepbuf, rgData.totsamp,\n                    rgData.lstepbuf, 0, MAX_ORDER);\n                System.arraycopy(rgData.rstepbuf, rgData.totsamp,\n                    rgData.rstepbuf, 0, MAX_ORDER);\n                rgData.totsamp = 0;\n            }\n            if (rgData.totsamp > rgData.sampleWindow) {\n                /*\n                 * somehow I really screwed up: Error in programming! Contact\n                 * author about totsamp > sampleWindow\n                 */\n                return GAIN_ANALYSIS_ERROR;\n            }\n        }\n        if (num_samples < MAX_ORDER) {\n            System.arraycopy(rgData.linprebuf, num_samples, rgData.linprebuf,\n                0, MAX_ORDER - num_samples);\n            System.arraycopy(rgData.rinprebuf, num_samples, rgData.rinprebuf,\n                0, MAX_ORDER - num_samples);\n            System.arraycopy(left_samples, left_samplesPos, rgData.linprebuf,\n                MAX_ORDER - num_samples, num_samples);\n            System.arraycopy(right_samples, right_samplesPos, rgData.rinprebuf,\n                MAX_ORDER - num_samples, num_samples);\n        } else {\n            System.arraycopy(left_samples, left_samplesPos + num_samples\n                - MAX_ORDER, rgData.linprebuf, 0, MAX_ORDER);\n            System.arraycopy(right_samples, right_samplesPos + num_samples\n                - MAX_ORDER, rgData.rinprebuf, 0, MAX_ORDER);\n        }\n\n        return GAIN_ANALYSIS_OK;\n    };\n\n    function analyzeResult(Array, len) {\n        var i;\n\n        var elems = 0;\n        for (i = 0; i < len; i++)\n            elems += Array[i];\n        if (elems == 0)\n            return GAIN_NOT_ENOUGH_SAMPLES;\n\n        var upper = 0 | Math.ceil(elems * (1. - RMS_PERCENTILE));\n        for (i = len; i-- > 0;) {\n            if ((upper -= Array[i]) <= 0)\n                break;\n        }\n\n        //return (float) ((float) PINK_REF - (float) i / (float) STEPS_per_dB);\n        return (PINK_REF - i / GainAnalysis.STEPS_per_dB);\n    }\n\n    this.GetTitleGain = function (rgData) {\n        var retval = analyzeResult(rgData.A, rgData.A.length);\n\n        for (var i = 0; i < rgData.A.length; i++) {\n            rgData.B[i] += rgData.A[i];\n            rgData.A[i] = 0;\n        }\n\n        for (var i = 0; i < MAX_ORDER; i++)\n            rgData.linprebuf[i] = rgData.lstepbuf[i] = rgData.loutbuf[i] = rgData.rinprebuf[i] = rgData.rstepbuf[i] = rgData.routbuf[i] = 0.;\n\n        rgData.totsamp = 0;\n        rgData.lsum = rgData.rsum = 0.;\n        return retval;\n    }\n\n}\n\nmodule.exports = GainAnalysis;\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAIA,MAAM,GAAGC,OAAO,CAAC,aAAa,CAAC;AACnC,IAAIC,MAAM,GAAGF,MAAM,CAACE,MAAM;AAC1B,IAAIC,OAAO,GAAGH,MAAM,CAACG,OAAO;AAC5B,IAAIC,KAAK,GAAGJ,MAAM,CAACI,KAAK;AACxB,IAAIC,UAAU,GAAGL,MAAM,CAACK,UAAU;AAClC,IAAIC,IAAI,GAAGN,MAAM,CAACM,IAAI;AACtB,IAAIC,MAAM,GAAGP,MAAM,CAACO,MAAM;AAC1B,IAAIC,WAAW,GAAGR,MAAM,CAACQ,WAAW;AACpC,IAAIC,QAAQ,GAAGT,MAAM,CAACS,QAAQ;AAC9B,IAAIC,UAAU,GAAGV,MAAM,CAACU,UAAU;AAClC,IAAIC,SAAS,GAAGX,MAAM,CAACW,SAAS;AAChC,IAAIC,WAAW,GAAGZ,MAAM,CAACY,WAAW;AACpC,IAAIC,OAAO,GAAGb,MAAM,CAACa,OAAO;AAC5B,IAAIC,SAAS,GAAGd,MAAM,CAACc,SAAS;AAChC,IAAIC,MAAM,GAAGf,MAAM,CAACe,MAAM;;AAE1B;AACA;AACA;AACAC,YAAY,CAACC,YAAY,GAAG,IAAI;AAChC;AACA;AACA;AACAD,YAAY,CAACE,MAAM,GAAG,IAAI;AAC1BF,YAAY,CAACG,uBAAuB,GAAG,CAAC,KAAK;AAC7CH,YAAY,CAACI,mBAAmB,GAAG,CAAC;AACpCJ,YAAY,CAACK,gBAAgB,GAAG,CAAC;AACjCL,YAAY,CAACM,wBAAwB,GAAG,CAAC;AACzCN,YAAY,CAACO,qBAAqB,GAAG,CAAC;AAEtCP,YAAY,CAACQ,UAAU,GAAG,EAAE;AAC5BR,YAAY,CAACS,SAAS,GAAGT,YAAY,CAACQ,UAAU;AAEhDR,YAAY,CAACU,aAAa,GAAG,KAAK;AAClCV,YAAY,CAACW,yBAAyB,GAAG,CAAC;AAC1CX,YAAY,CAACY,2BAA2B,GAAG,EAAE;AAC7CZ,YAAY,CAACa,sBAAsB,GAAKb,YAAY,CAACU,aAAa,GAAGV,YAAY,CAACW,yBAAyB,GAAIX,YAAY,CAACY,2BAA2B,GAAG,CAAE;AAE5J,SAASZ,YAAYA,CAAA,EAAG;EACpB;AACJ;AACA;EACI,IAAIc,QAAQ,GAAG,KAAK;EAEpB,IAAIN,UAAU,GAAGR,YAAY,CAACQ,UAAU;EACxC;AACJ;AACA;EACI,IAAIO,cAAc,GAAG,IAAI;EACzB;AACJ;AACA;EACI,IAAIL,aAAa,GAAGV,YAAY,CAACU,aAAa;EAC9C,IAAIC,yBAAyB,GAAGX,YAAY,CAACW,yBAAyB;EACtE;AACJ;AACA;EACI,IAAIC,2BAA2B,GAAGZ,YAAY,CAACY,2BAA2B;EAC1E;AACJ;AACA;EACI,IAAIC,sBAAsB,GAAGb,YAAY,CAACa,sBAAsB;EAGhE,IAAIG,MAAM,GAAG,CACT,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACnD,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,iBAAiB,EACvD,CAAC,gBAAgB,EAAE,iBAAiB,EAAE,CAAC,gBAAgB,EACvD,CAAC,iBAAiB,EAAE,gBAAgB,EAAE,gBAAgB,EACtD,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,EACtD,gBAAgB,EAAE,gBAAgB,EAAE,CAAC,gBAAgB,EACrD,gBAAgB,EAAE,gBAAgB,EAAE,gBAAgB,CAAC,EACzD,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACnD,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACtD,CAAC,gBAAgB,EAAE,gBAAgB,EAAE,CAAC,gBAAgB,EACtD,CAAC,gBAAgB,EAAE,gBAAgB,EAAE,gBAAgB,EACrD,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,EACtD,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACtD,gBAAgB,EAAE,gBAAgB,EAAE,CAAC,gBAAgB,CAAC,EAC1D,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACnD,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACtD,gBAAgB,EAAE,gBAAgB,EAAE,CAAC,gBAAgB,EACrD,CAAC,gBAAgB,EAAE,gBAAgB,EAAE,gBAAgB,EACrD,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,EACrD,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACtD,gBAAgB,EAAE,gBAAgB,EAAE,CAAC,gBAAgB,CAAC,EAC1D,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACnD,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACtD,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACtD,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,EACtD,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,EACtD,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,EACrD,gBAAgB,EAAE,gBAAgB,EAAE,CAAC,gBAAgB,CAAC,EAC1D,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACnD,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,EACrD,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACtD,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EACtD,CAAC,gBAAgB,EAAE,CAAC,gBAAgB,EAAE,gBAAgB,EACtD,gBAAgB,EAAE,gBAAgB,EAAE,CAAC,gBAAgB,EACrD,CAAC,gBAAgB,EAAE,gBAAgB,EAAE,CAAC,gBAAgB,CAAC,EA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}