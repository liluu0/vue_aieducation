{"ast":null,"code":"require(\"core-js/modules/es.regexp.flags.js\");\nvar common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\n/**\n * A Vbr header may be present in the ancillary data field of the first frame of\n * an mp3 bitstream<BR>\n * The Vbr header (optionally) contains\n * <UL>\n * <LI>frames total number of audio frames in the bitstream\n * <LI>bytes total number of bytes in the bitstream\n * <LI>toc table of contents\n * </UL>\n *\n * toc (table of contents) gives seek points for random access.<BR>\n * The ith entry determines the seek point for i-percent duration.<BR>\n * seek point in bytes = (toc[i]/256.0) * total_bitstream_bytes<BR>\n * e.g. half duration seek point = (toc[50]/256.0) * total_bitstream_bytes\n */\nVBRTag.NUMTOCENTRIES = 100;\nVBRTag.MAXFRAMESIZE = 2880;\nfunction VBRTag() {\n  var lame;\n  var bs;\n  var v;\n  this.setModules = function (_lame, _bs, _v) {\n    lame = _lame;\n    bs = _bs;\n    v = _v;\n  };\n  var FRAMES_FLAG = 0x0001;\n  var BYTES_FLAG = 0x0002;\n  var TOC_FLAG = 0x0004;\n  var VBR_SCALE_FLAG = 0x0008;\n  var NUMTOCENTRIES = VBRTag.NUMTOCENTRIES;\n\n  /**\n   * (0xB40) the max freeformat 640 32kHz framesize.\n   */\n  var MAXFRAMESIZE = VBRTag.MAXFRAMESIZE;\n\n  /**\n   * <PRE>\n   *    4 bytes for Header Tag\n   *    4 bytes for Header Flags\n   *  100 bytes for entry (toc)\n   *    4 bytes for frame size\n   *    4 bytes for stream size\n   *    4 bytes for VBR scale. a VBR quality indicator: 0=best 100=worst\n   *   20 bytes for LAME tag.  for example, \"LAME3.12 (beta 6)\"\n   * ___________\n   *  140 bytes\n   * </PRE>\n   */\n  var VBRHEADERSIZE = NUMTOCENTRIES + 4 + 4 + 4 + 4 + 4;\n  var LAMEHEADERSIZE = VBRHEADERSIZE + 9 + 1 + 1 + 8 + 1 + 1 + 3 + 1 + 1 + 2 + 4 + 2 + 2;\n\n  /**\n   * The size of the Xing header MPEG-1, bit rate in kbps.\n   */\n  var XING_BITRATE1 = 128;\n  /**\n   * The size of the Xing header MPEG-2, bit rate in kbps.\n   */\n  var XING_BITRATE2 = 64;\n  /**\n   * The size of the Xing header MPEG-2.5, bit rate in kbps.\n   */\n  var XING_BITRATE25 = 32;\n\n  /**\n   * ISO-8859-1 charset for byte to string operations.\n   */\n  var ISO_8859_1 = null; //Charset.forName(\"ISO-8859-1\");\n\n  /**\n   * VBR header magic string.\n   */\n  var VBRTag0 = \"Xing\";\n  /**\n   * VBR header magic string (VBR == VBRMode.vbr_off).\n   */\n  var VBRTag1 = \"Info\";\n\n  /**\n   * Lookup table for fast CRC-16 computation. Uses the polynomial\n   * x^16+x^15+x^2+1\n   */\n  var crc16Lookup = [0x0000, 0xC0C1, 0xC181, 0x0140, 0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741, 0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0, 0x0D80, 0xCD41, 0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40, 0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941, 0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40, 0xDD01, 0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540, 0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341, 0x1100, 0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141, 0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740, 0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40, 0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41, 0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940, 0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41, 0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541, 0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340, 0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141, 0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740, 0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40, 0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41, 0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940, 0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41, 0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541, 0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340, 0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140, 0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741, 0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80, 0x9D41, 0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40, 0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0, 0x4980, 0x8941, 0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40, 0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581, 0x4540, 0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341, 0x4100, 0x81C1, 0x8081, 0x4040];\n\n  /***********************************************************************\n   * Robert Hegemann 2001-01-17\n   ***********************************************************************/\n\n  function addVbr(v, bitrate) {\n    v.nVbrNumFrames++;\n    v.sum += bitrate;\n    v.seen++;\n    if (v.seen < v.want) {\n      return;\n    }\n    if (v.pos < v.size) {\n      v.bag[v.pos] = v.sum;\n      v.pos++;\n      v.seen = 0;\n    }\n    if (v.pos == v.size) {\n      for (var i = 1; i < v.size; i += 2) {\n        v.bag[i / 2] = v.bag[i];\n      }\n      v.want *= 2;\n      v.pos /= 2;\n    }\n  }\n  function xingSeekTable(v, t) {\n    if (v.pos <= 0) return;\n    for (var i = 1; i < NUMTOCENTRIES; ++i) {\n      var j = i / NUMTOCENTRIES,\n        act,\n        sum;\n      var indx = 0 | Math.floor(j * v.pos);\n      if (indx > v.pos - 1) indx = v.pos - 1;\n      act = v.bag[indx];\n      sum = v.sum;\n      var seek_point = 0 | 256. * act / sum;\n      if (seek_point > 255) seek_point = 255;\n      t[i] = 0xff & seek_point;\n    }\n  }\n\n  /**\n   * Add VBR entry, used to fill the VBR TOC entries.\n   *\n   * @param gfp\n   *            global flags\n   */\n  this.addVbrFrame = function (gfp) {\n    var gfc = gfp.internal_flags;\n    var kbps = Tables.bitrate_table[gfp.version][gfc.bitrate_index];\n    assert(gfc.VBR_seek_table.bag != null);\n    addVbr(gfc.VBR_seek_table, kbps);\n  };\n\n  /**\n   * Read big endian integer (4-bytes) from header.\n   *\n   * @param buf\n   *            header containing the integer\n   * @param bufPos\n   *            offset into the header\n   * @return extracted integer\n   */\n  function extractInteger(buf, bufPos) {\n    var x = buf[bufPos + 0] & 0xff;\n    x <<= 8;\n    x |= buf[bufPos + 1] & 0xff;\n    x <<= 8;\n    x |= buf[bufPos + 2] & 0xff;\n    x <<= 8;\n    x |= buf[bufPos + 3] & 0xff;\n    return x;\n  }\n\n  /**\n   * Write big endian integer (4-bytes) in the header.\n   *\n   * @param buf\n   *            header to write the integer into\n   * @param bufPos\n   *            offset into the header\n   * @param value\n   *            integer value to write\n   */\n  function createInteger(buf, bufPos, value) {\n    buf[bufPos + 0] = 0xff & (value >> 24 & 0xff);\n    buf[bufPos + 1] = 0xff & (value >> 16 & 0xff);\n    buf[bufPos + 2] = 0xff & (value >> 8 & 0xff);\n    buf[bufPos + 3] = 0xff & (value & 0xff);\n  }\n\n  /**\n   * Write big endian short (2-bytes) in the header.\n   *\n   * @param buf\n   *            header to write the integer into\n   * @param bufPos\n   *            offset into the header\n   * @param value\n   *            integer value to write\n   */\n  function createShort(buf, bufPos, value) {\n    buf[bufPos + 0] = 0xff & (value >> 8 & 0xff);\n    buf[bufPos + 1] = 0xff & (value & 0xff);\n  }\n\n  /**\n   * Check for magic strings (Xing/Info).\n   *\n   * @param buf\n   *            header to check\n   * @param bufPos\n   *            header offset to check\n   * @return magic string found\n   */\n  function isVbrTag(buf, bufPos) {\n    return new String(buf, bufPos, VBRTag0.length(), ISO_8859_1).equals(VBRTag0) || new String(buf, bufPos, VBRTag1.length(), ISO_8859_1).equals(VBRTag1);\n  }\n  function shiftInBitsValue(x, n, v) {\n    return 0xff & (x << n | v & ~(-1 << n));\n  }\n\n  /**\n   * Construct the MP3 header using the settings of the global flags.\n   *\n   * <img src=\"1000px-Mp3filestructure.svg.png\">\n   *\n   * @param gfp\n   *            global flags\n   * @param buffer\n   *            header\n   */\n  function setLameTagFrameHeader(gfp, buffer) {\n    var gfc = gfp.internal_flags;\n\n    // MP3 Sync Word\n    buffer[0] = shiftInBitsValue(buffer[0], 8, 0xff);\n    buffer[1] = shiftInBitsValue(buffer[1], 3, 7);\n    buffer[1] = shiftInBitsValue(buffer[1], 1, gfp.out_samplerate < 16000 ? 0 : 1);\n    // Version\n    buffer[1] = shiftInBitsValue(buffer[1], 1, gfp.version);\n    // 01 == Layer 3\n    buffer[1] = shiftInBitsValue(buffer[1], 2, 4 - 3);\n    // Error protection\n    buffer[1] = shiftInBitsValue(buffer[1], 1, !gfp.error_protection ? 1 : 0);\n\n    // Bit rate\n    buffer[2] = shiftInBitsValue(buffer[2], 4, gfc.bitrate_index);\n    // Frequency\n    buffer[2] = shiftInBitsValue(buffer[2], 2, gfc.samplerate_index);\n    // Pad. Bit\n    buffer[2] = shiftInBitsValue(buffer[2], 1, 0);\n    // Priv. Bit\n    buffer[2] = shiftInBitsValue(buffer[2], 1, gfp.extension);\n\n    // Mode\n    buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.mode.ordinal());\n    // Mode extension (Used with Joint Stereo)\n    buffer[3] = shiftInBitsValue(buffer[3], 2, gfc.mode_ext);\n    // Copy\n    buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.copyright);\n    // Original\n    buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.original);\n    // Emphasis\n    buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.emphasis);\n\n    /* the default VBR header. 48 kbps layer III, no padding, no crc */\n    /* but sampling freq, mode and copyright/copy protection taken */\n    /* from first valid frame */\n    buffer[0] = 0xff;\n    var abyte = 0xff & (buffer[1] & 0xf1);\n    var bitrate;\n    if (1 == gfp.version) {\n      bitrate = XING_BITRATE1;\n    } else {\n      if (gfp.out_samplerate < 16000) bitrate = XING_BITRATE25;else bitrate = XING_BITRATE2;\n    }\n    if (gfp.VBR == VbrMode.vbr_off) bitrate = gfp.brate;\n    var bbyte;\n    if (gfp.free_format) bbyte = 0x00;else bbyte = 0xff & 16 * lame.BitrateIndex(bitrate, gfp.version, gfp.out_samplerate);\n\n    /*\n     * Use as much of the info from the real frames in the Xing header:\n     * samplerate, channels, crc, etc...\n     */\n    if (gfp.version == 1) {\n      /* MPEG1 */\n      buffer[1] = 0xff & (abyte | 0x0a);\n      /* was 0x0b; */\n      abyte = 0xff & (buffer[2] & 0x0d);\n      /* AF keep also private bit */\n      buffer[2] = 0xff & (bbyte | abyte);\n      /* 64kbs MPEG1 frame */\n    } else {\n      /* MPEG2 */\n      buffer[1] = 0xff & (abyte | 0x02);\n      /* was 0x03; */\n      abyte = 0xff & (buffer[2] & 0x0d);\n      /* AF keep also private bit */\n      buffer[2] = 0xff & (bbyte | abyte);\n      /* 64kbs MPEG2 frame */\n    }\n  }\n\n  /**\n   * Get VBR tag information\n   *\n   * @param buf\n   *            header to analyze\n   * @param bufPos\n   *            offset into the header\n   * @return VBR tag data\n   */\n  this.getVbrTag = function (buf) {\n    var pTagData = new VBRTagData();\n    var bufPos = 0;\n\n    /* get Vbr header data */\n    pTagData.flags = 0;\n\n    /* get selected MPEG header data */\n    var hId = buf[bufPos + 1] >> 3 & 1;\n    var hSrIndex = buf[bufPos + 2] >> 2 & 3;\n    var hMode = buf[bufPos + 3] >> 6 & 3;\n    var hBitrate = buf[bufPos + 2] >> 4 & 0xf;\n    hBitrate = Tables.bitrate_table[hId][hBitrate];\n\n    /* check for FFE syncword */\n    if (buf[bufPos + 1] >> 4 == 0xE) pTagData.samprate = Tables.samplerate_table[2][hSrIndex];else pTagData.samprate = Tables.samplerate_table[hId][hSrIndex];\n\n    /* determine offset of header */\n    if (hId != 0) {\n      /* mpeg1 */\n      if (hMode != 3) bufPos += 32 + 4;else bufPos += 17 + 4;\n    } else {\n      /* mpeg2 */\n      if (hMode != 3) bufPos += 17 + 4;else bufPos += 9 + 4;\n    }\n    if (!isVbrTag(buf, bufPos)) return null;\n    bufPos += 4;\n    pTagData.hId = hId;\n\n    /* get flags */\n    var head_flags = pTagData.flags = extractInteger(buf, bufPos);\n    bufPos += 4;\n    if ((head_flags & FRAMES_FLAG) != 0) {\n      pTagData.frames = extractInteger(buf, bufPos);\n      bufPos += 4;\n    }\n    if ((head_flags & BYTES_FLAG) != 0) {\n      pTagData.bytes = extractInteger(buf, bufPos);\n      bufPos += 4;\n    }\n    if ((head_flags & TOC_FLAG) != 0) {\n      if (pTagData.toc != null) {\n        for (var i = 0; i < NUMTOCENTRIES; i++) pTagData.toc[i] = buf[bufPos + i];\n      }\n      bufPos += NUMTOCENTRIES;\n    }\n    pTagData.vbrScale = -1;\n    if ((head_flags & VBR_SCALE_FLAG) != 0) {\n      pTagData.vbrScale = extractInteger(buf, bufPos);\n      bufPos += 4;\n    }\n    pTagData.headersize = (hId + 1) * 72000 * hBitrate / pTagData.samprate;\n    bufPos += 21;\n    var encDelay = buf[bufPos + 0] << 4;\n    encDelay += buf[bufPos + 1] >> 4;\n    var encPadding = (buf[bufPos + 1] & 0x0F) << 8;\n    encPadding += buf[bufPos + 2] & 0xff;\n    /* check for reasonable values (this may be an old Xing header, */\n    /* not a INFO tag) */\n    if (encDelay < 0 || encDelay > 3000) encDelay = -1;\n    if (encPadding < 0 || encPadding > 3000) encPadding = -1;\n    pTagData.encDelay = encDelay;\n    pTagData.encPadding = encPadding;\n\n    /* success */\n    return pTagData;\n  };\n\n  /**\n   * Initializes the header\n   *\n   * @param gfp\n   *            global flags\n   */\n  this.InitVbrTag = function (gfp) {\n    var gfc = gfp.internal_flags;\n\n    /**\n     * <PRE>\n     * Xing VBR pretends to be a 48kbs layer III frame.  (at 44.1kHz).\n     * (at 48kHz they use 56kbs since 48kbs frame not big enough for\n     * table of contents)\n     * let's always embed Xing header inside a 64kbs layer III frame.\n     * this gives us enough room for a LAME version string too.\n     * size determined by sampling frequency (MPEG1)\n     * 32kHz:    216 bytes@48kbs    288bytes@ 64kbs\n     * 44.1kHz:  156 bytes          208bytes@64kbs     (+1 if padding = 1)\n     * 48kHz:    144 bytes          192\n     *\n     * MPEG 2 values are the same since the framesize and samplerate\n     * are each reduced by a factor of 2.\n     * </PRE>\n     */\n    var kbps_header;\n    if (1 == gfp.version) {\n      kbps_header = XING_BITRATE1;\n    } else {\n      if (gfp.out_samplerate < 16000) kbps_header = XING_BITRATE25;else kbps_header = XING_BITRATE2;\n    }\n    if (gfp.VBR == VbrMode.vbr_off) kbps_header = gfp.brate;\n\n    // make sure LAME Header fits into Frame\n    var totalFrameSize = (gfp.version + 1) * 72000 * kbps_header / gfp.out_samplerate;\n    var headerSize = gfc.sideinfo_len + LAMEHEADERSIZE;\n    gfc.VBR_seek_table.TotalFrameSize = totalFrameSize;\n    if (totalFrameSize < headerSize || totalFrameSize > MAXFRAMESIZE) {\n      /* disable tag, it wont fit */\n      gfp.bWriteVbrTag = false;\n      return;\n    }\n    gfc.VBR_seek_table.nVbrNumFrames = 0;\n    gfc.VBR_seek_table.nBytesWritten = 0;\n    gfc.VBR_seek_table.sum = 0;\n    gfc.VBR_seek_table.seen = 0;\n    gfc.VBR_seek_table.want = 1;\n    gfc.VBR_seek_table.pos = 0;\n    if (gfc.VBR_seek_table.bag == null) {\n      gfc.VBR_seek_table.bag = new int[400]();\n      gfc.VBR_seek_table.size = 400;\n    }\n\n    // write dummy VBR tag of all 0's into bitstream\n    var buffer = new_byte(MAXFRAMESIZE);\n    setLameTagFrameHeader(gfp, buffer);\n    var n = gfc.VBR_seek_table.TotalFrameSize;\n    for (var i = 0; i < n; ++i) {\n      bs.add_dummy_byte(gfp, buffer[i] & 0xff, 1);\n    }\n  };\n\n  /**\n   * Fast CRC-16 computation (uses table crc16Lookup).\n   *\n   * @param value\n   * @param crc\n   * @return\n   */\n  function crcUpdateLookup(value, crc) {\n    var tmp = crc ^ value;\n    crc = crc >> 8 ^ crc16Lookup[tmp & 0xff];\n    return crc;\n  }\n  this.updateMusicCRC = function (crc, buffer, bufferPos, size) {\n    for (var i = 0; i < size; ++i) crc[0] = crcUpdateLookup(buffer[bufferPos + i], crc[0]);\n  };\n\n  /**\n   * Write LAME info: mini version + info on various switches used (Jonathan\n   * Dee 2001/08/31).\n   *\n   * @param gfp\n   *            global flags\n   * @param musicLength\n   *            music length\n   * @param streamBuffer\n   *            pointer to output buffer\n   * @param streamBufferPos\n   *            offset into the output buffer\n   * @param crc\n   *            computation of CRC-16 of Lame Tag so far (starting at frame\n   *            sync)\n   * @return number of bytes written to the stream\n   */\n  function putLameVBR(gfp, musicLength, streamBuffer, streamBufferPos, crc) {\n    var gfc = gfp.internal_flags;\n    var bytesWritten = 0;\n\n    /* encoder delay */\n    var encDelay = gfp.encoder_delay;\n    /* encoder padding */\n    var encPadding = gfp.encoder_padding;\n\n    /* recall: gfp.VBR_q is for example set by the switch -V */\n    /* gfp.quality by -q, -h, -f, etc */\n    var quality = 100 - 10 * gfp.VBR_q - gfp.quality;\n    var version = v.getLameVeryShortVersion();\n    var vbr;\n    var revision = 0x00;\n    var revMethod;\n    // numbering different in vbr_mode vs. Lame tag\n    var vbrTypeTranslator = [1, 5, 3, 2, 4, 0, 3];\n    var lowpass = 0 | (gfp.lowpassfreq / 100.0 + .5 > 255 ? 255 : gfp.lowpassfreq / 100.0 + .5);\n    var peakSignalAmplitude = 0;\n    var radioReplayGain = 0;\n    var audiophileReplayGain = 0;\n    var noiseShaping = gfp.internal_flags.noise_shaping;\n    var stereoMode = 0;\n    var nonOptimal = 0;\n    var sourceFreq = 0;\n    var misc = 0;\n    var musicCRC = 0;\n\n    // psy model type: Gpsycho or NsPsytune\n    var expNPsyTune = (gfp.exp_nspsytune & 1) != 0;\n    var safeJoint = (gfp.exp_nspsytune & 2) != 0;\n    var noGapMore = false;\n    var noGapPrevious = false;\n    var noGapCount = gfp.internal_flags.nogap_total;\n    var noGapCurr = gfp.internal_flags.nogap_current;\n\n    // 4 bits\n    var athType = gfp.ATHtype;\n    var flags = 0;\n\n    // vbr modes\n    var abrBitrate;\n    switch (gfp.VBR) {\n      case vbr_abr:\n        abrBitrate = gfp.VBR_mean_bitrate_kbps;\n        break;\n      case vbr_off:\n        abrBitrate = gfp.brate;\n        break;\n      default:\n        abrBitrate = gfp.VBR_min_bitrate_kbps;\n    }\n\n    // revision and vbr method\n    if (gfp.VBR.ordinal() < vbrTypeTranslator.length) vbr = vbrTypeTranslator[gfp.VBR.ordinal()];else vbr = 0x00; // unknown\n\n    revMethod = 0x10 * revision + vbr;\n\n    // ReplayGain\n    if (gfc.findReplayGain) {\n      if (gfc.RadioGain > 0x1FE) gfc.RadioGain = 0x1FE;\n      if (gfc.RadioGain < -0x1FE) gfc.RadioGain = -0x1FE;\n\n      // set name code\n      radioReplayGain = 0x2000;\n      // set originator code to `determined automatically'\n      radioReplayGain |= 0xC00;\n      if (gfc.RadioGain >= 0) {\n        // set gain adjustment\n        radioReplayGain |= gfc.RadioGain;\n      } else {\n        // set the sign bit\n        radioReplayGain |= 0x200;\n        // set gain adjustment\n        radioReplayGain |= -gfc.RadioGain;\n      }\n    }\n\n    // peak sample\n    if (gfc.findPeakSample) peakSignalAmplitude = Math.abs(0 | gfc.PeakSample / 32767.0 * Math.pow(2, 23) + .5);\n\n    // nogap\n    if (noGapCount != -1) {\n      if (noGapCurr > 0) noGapPrevious = true;\n      if (noGapCurr < noGapCount - 1) noGapMore = true;\n    }\n\n    // flags\n    flags = athType + ((expNPsyTune ? 1 : 0) << 4) + ((safeJoint ? 1 : 0) << 5) + ((noGapMore ? 1 : 0) << 6) + ((noGapPrevious ? 1 : 0) << 7);\n    if (quality < 0) quality = 0;\n\n    // stereo mode field (Intensity stereo is not implemented)\n    switch (gfp.mode) {\n      case MONO:\n        stereoMode = 0;\n        break;\n      case STEREO:\n        stereoMode = 1;\n        break;\n      case DUAL_CHANNEL:\n        stereoMode = 2;\n        break;\n      case JOINT_STEREO:\n        if (gfp.force_ms) stereoMode = 4;else stereoMode = 3;\n        break;\n      case NOT_SET:\n      //$FALL-THROUGH$\n      default:\n        stereoMode = 7;\n        break;\n    }\n    if (gfp.in_samplerate <= 32000) sourceFreq = 0x00;else if (gfp.in_samplerate == 48000) sourceFreq = 0x02;else if (gfp.in_samplerate > 48000) sourceFreq = 0x03;else {\n      // default is 44100Hz\n      sourceFreq = 0x01;\n    }\n\n    // Check if the user overrided the default LAME behavior with some\n    // nasty options\n    if (gfp.short_blocks == ShortBlock.short_block_forced || gfp.short_blocks == ShortBlock.short_block_dispensed || gfp.lowpassfreq == -1 && gfp.highpassfreq == -1 || ( /* \"-k\" */\n    gfp.scale_left < gfp.scale_right) || gfp.scale_left > gfp.scale_right || gfp.disable_reservoir && gfp.brate < 320 || gfp.noATH || gfp.ATHonly || athType == 0 || gfp.in_samplerate <= 32000) nonOptimal = 1;\n    misc = noiseShaping + (stereoMode << 2) + (nonOptimal << 5) + (sourceFreq << 6);\n    musicCRC = gfc.nMusicCRC;\n\n    // Write all this information into the stream\n\n    createInteger(streamBuffer, streamBufferPos + bytesWritten, quality);\n    bytesWritten += 4;\n    for (var j = 0; j < 9; j++) {\n      streamBuffer[streamBufferPos + bytesWritten + j] = 0xff & version.charAt(j);\n    }\n    bytesWritten += 9;\n    streamBuffer[streamBufferPos + bytesWritten] = 0xff & revMethod;\n    bytesWritten++;\n    streamBuffer[streamBufferPos + bytesWritten] = 0xff & lowpass;\n    bytesWritten++;\n    createInteger(streamBuffer, streamBufferPos + bytesWritten, peakSignalAmplitude);\n    bytesWritten += 4;\n    createShort(streamBuffer, streamBufferPos + bytesWritten, radioReplayGain);\n    bytesWritten += 2;\n    createShort(streamBuffer, streamBufferPos + bytesWritten, audiophileReplayGain);\n    bytesWritten += 2;\n    streamBuffer[streamBufferPos + bytesWritten] = 0xff & flags;\n    bytesWritten++;\n    if (abrBitrate >= 255) streamBuffer[streamBufferPos + bytesWritten] = 0xFF;else streamBuffer[streamBufferPos + bytesWritten] = 0xff & abrBitrate;\n    bytesWritten++;\n    streamBuffer[streamBufferPos + bytesWritten] = 0xff & encDelay >> 4;\n    streamBuffer[streamBufferPos + bytesWritten + 1] = 0xff & (encDelay << 4) + (encPadding >> 8);\n    streamBuffer[streamBufferPos + bytesWritten + 2] = 0xff & encPadding;\n    bytesWritten += 3;\n    streamBuffer[streamBufferPos + bytesWritten] = 0xff & misc;\n    bytesWritten++;\n\n    // unused in rev0\n    streamBuffer[streamBufferPos + bytesWritten++] = 0;\n    createShort(streamBuffer, streamBufferPos + bytesWritten, gfp.preset);\n    bytesWritten += 2;\n    createInteger(streamBuffer, streamBufferPos + bytesWritten, musicLength);\n    bytesWritten += 4;\n    createShort(streamBuffer, streamBufferPos + bytesWritten, musicCRC);\n    bytesWritten += 2;\n\n    // Calculate tag CRC.... must be done here, since it includes previous\n    // information\n\n    for (var i = 0; i < bytesWritten; i++) crc = crcUpdateLookup(streamBuffer[streamBufferPos + i], crc);\n    createShort(streamBuffer, streamBufferPos + bytesWritten, crc);\n    bytesWritten += 2;\n    return bytesWritten;\n  }\n  function skipId3v2(fpStream) {\n    // seek to the beginning of the stream\n    fpStream.seek(0);\n    // read 10 bytes in case there's an ID3 version 2 header here\n    var id3v2Header = new_byte(10);\n    fpStream.readFully(id3v2Header);\n    /* does the stream begin with the ID3 version 2 file identifier? */\n    var id3v2TagSize;\n    if (!new String(id3v2Header, \"ISO-8859-1\").startsWith(\"ID3\")) {\n      /*\n       * the tag size (minus the 10-byte header) is encoded into four\n       * bytes where the most significant bit is clear in each byte\n       */\n      id3v2TagSize = ((id3v2Header[6] & 0x7f) << 21 | (id3v2Header[7] & 0x7f) << 14 | (id3v2Header[8] & 0x7f) << 7 | id3v2Header[9] & 0x7f) + id3v2Header.length;\n    } else {\n      /* no ID3 version 2 tag in this stream */\n      id3v2TagSize = 0;\n    }\n    return id3v2TagSize;\n  }\n  this.getLameTagFrame = function (gfp, buffer) {\n    var gfc = gfp.internal_flags;\n    if (!gfp.bWriteVbrTag) {\n      return 0;\n    }\n    if (gfc.Class_ID != Lame.LAME_ID) {\n      return 0;\n    }\n    if (gfc.VBR_seek_table.pos <= 0) {\n      return 0;\n    }\n    if (buffer.length < gfc.VBR_seek_table.TotalFrameSize) {\n      return gfc.VBR_seek_table.TotalFrameSize;\n    }\n    Arrays.fill(buffer, 0, gfc.VBR_seek_table.TotalFrameSize, 0);\n\n    // 4 bytes frame header\n    setLameTagFrameHeader(gfp, buffer);\n\n    // Create TOC entries\n    var toc = new_byte(NUMTOCENTRIES);\n    if (gfp.free_format) {\n      for (var i = 1; i < NUMTOCENTRIES; ++i) toc[i] = 0xff & 255 * i / 100;\n    } else {\n      xingSeekTable(gfc.VBR_seek_table, toc);\n    }\n\n    // Start writing the tag after the zero frame\n    var streamIndex = gfc.sideinfo_len;\n    /**\n     * Note: Xing header specifies that Xing data goes in the ancillary data\n     * with NO ERROR PROTECTION. If error protecton in enabled, the Xing\n     * data still starts at the same offset, and now it is in sideinfo data\n     * block, and thus will not decode correctly by non-Xing tag aware\n     * players\n     */\n    if (gfp.error_protection) streamIndex -= 2;\n\n    // Put Vbr tag\n    if (gfp.VBR == VbrMode.vbr_off) {\n      buffer[streamIndex++] = 0xff & VBRTag1.charAt(0);\n      buffer[streamIndex++] = 0xff & VBRTag1.charAt(1);\n      buffer[streamIndex++] = 0xff & VBRTag1.charAt(2);\n      buffer[streamIndex++] = 0xff & VBRTag1.charAt(3);\n    } else {\n      buffer[streamIndex++] = 0xff & VBRTag0.charAt(0);\n      buffer[streamIndex++] = 0xff & VBRTag0.charAt(1);\n      buffer[streamIndex++] = 0xff & VBRTag0.charAt(2);\n      buffer[streamIndex++] = 0xff & VBRTag0.charAt(3);\n    }\n\n    // Put header flags\n    createInteger(buffer, streamIndex, FRAMES_FLAG + BYTES_FLAG + TOC_FLAG + VBR_SCALE_FLAG);\n    streamIndex += 4;\n\n    // Put Total Number of frames\n    createInteger(buffer, streamIndex, gfc.VBR_seek_table.nVbrNumFrames);\n    streamIndex += 4;\n\n    // Put total audio stream size, including Xing/LAME Header\n    var streamSize = gfc.VBR_seek_table.nBytesWritten + gfc.VBR_seek_table.TotalFrameSize;\n    createInteger(buffer, streamIndex, 0 | streamSize);\n    streamIndex += 4;\n\n    /* Put TOC */\n    System.arraycopy(toc, 0, buffer, streamIndex, toc.length);\n    streamIndex += toc.length;\n    if (gfp.error_protection) {\n      // (jo) error_protection: add crc16 information to header\n      bs.CRC_writeheader(gfc, buffer);\n    }\n\n    // work out CRC so far: initially crc = 0\n    var crc = 0x00;\n    for (var i = 0; i < streamIndex; i++) crc = crcUpdateLookup(buffer[i], crc);\n    // Put LAME VBR info\n    streamIndex += putLameVBR(gfp, streamSize, buffer, streamIndex, crc);\n    return gfc.VBR_seek_table.TotalFrameSize;\n  };\n\n  /**\n   * Write final VBR tag to the file.\n   *\n   * @param gfp\n   *            global flags\n   * @param stream\n   *            stream to add the VBR tag to\n   * @return 0 (OK), -1 else\n   * @throws IOException\n   *             I/O error\n   */\n  this.putVbrTag = function (gfp, stream) {\n    var gfc = gfp.internal_flags;\n    if (gfc.VBR_seek_table.pos <= 0) return -1;\n\n    // Seek to end of file\n    stream.seek(stream.length());\n\n    // Get file size, abort if file has zero length.\n    if (stream.length() == 0) return -1;\n\n    // The VBR tag may NOT be located at the beginning of the stream. If an\n    // ID3 version 2 tag was added, then it must be skipped to write the VBR\n    // tag data.\n    var id3v2TagSize = skipId3v2(stream);\n\n    // Seek to the beginning of the stream\n    stream.seek(id3v2TagSize);\n    var buffer = new_byte(MAXFRAMESIZE);\n    var bytes = getLameTagFrame(gfp, buffer);\n    if (bytes > buffer.length) {\n      return -1;\n    }\n    if (bytes < 1) {\n      return 0;\n    }\n\n    // Put it all to disk again\n    stream.write(buffer, 0, bytes);\n    // success\n    return 0;\n  };\n}\nmodule.exports = VBRTag;","map":{"version":3,"names":["common","require","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","VBRTag","NUMTOCENTRIES","MAXFRAMESIZE","lame","bs","v","setModules","_lame","_bs","_v","FRAMES_FLAG","BYTES_FLAG","TOC_FLAG","VBR_SCALE_FLAG","VBRHEADERSIZE","LAMEHEADERSIZE","XING_BITRATE1","XING_BITRATE2","XING_BITRATE25","ISO_8859_1","VBRTag0","VBRTag1","crc16Lookup","addVbr","bitrate","nVbrNumFrames","sum","seen","want","pos","size","bag","i","xingSeekTable","t","j","act","indx","Math","floor","seek_point","addVbrFrame","gfp","gfc","internal_flags","kbps","Tables","bitrate_table","version","bitrate_index","VBR_seek_table","extractInteger","buf","bufPos","x","createInteger","value","createShort","isVbrTag","String","length","equals","shiftInBitsValue","n","setLameTagFrameHeader","buffer","out_samplerate","error_protection","samplerate_index","extension","mode","ordinal","mode_ext","copyright","original","emphasis","abyte","VBR","vbr_off","brate","bbyte","free_format","BitrateIndex","getVbrTag","pTagData","VBRTagData","flags","hId","hSrIndex","hMode","hBitrate","samprate","samplerate_table","head_flags","frames","bytes","toc","vbrScale","headersize","encDelay","encPadding","InitVbrTag","kbps_header","totalFrameSize","headerSize","sideinfo_len","TotalFrameSize","bWriteVbrTag","nBytesWritten","int","add_dummy_byte","crcUpdateLookup","crc","tmp","updateMusicCRC","bufferPos","putLameVBR","musicLength","streamBuffer","streamBufferPos","bytesWritten","encoder_delay","encoder_padding","quality","VBR_q","getLameVeryShortVersion","vbr","revision","revMethod","vbrTypeTranslator","lowpass","lowpassfreq","peakSignalAmplitude","radioReplayGain","audiophileReplayGain","noiseShaping","noise_shaping","stereoMode","nonOptimal","sourceFreq","misc","musicCRC","expNPsyTune","exp_nspsytune","safeJoint","noGapMore","noGapPrevious","noGapCount","nogap_total","noGapCurr","nogap_current","athType","ATHtype","abrBitrate","vbr_abr","VBR_mean_bitrate_kbps","VBR_min_bitrate_kbps","findReplayGain","RadioGain","findPeakSample","abs","PeakSample","pow","MONO","STEREO","DUAL_CHANNEL","JOINT_STEREO","force_ms","NOT_SET","in_samplerate","short_blocks","short_block_forced","short_block_dispensed","highpassfreq","scale_left","scale_right","disable_reservoir","noATH","ATHonly","nMusicCRC","charAt","preset","skipId3v2","fpStream","seek","id3v2Header","readFully","id3v2TagSize","startsWith","getLameTagFrame","Class_ID","Lame","LAME_ID","fill","streamIndex","streamSize","arraycopy","CRC_writeheader","putVbrTag","stream","write","module","exports"],"sources":["D:/代码/vscodeProjects/AiEducation/vue_aieducation/node_modules/lamejs/src/js/VBRTag.js"],"sourcesContent":["var common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\n/**\n * A Vbr header may be present in the ancillary data field of the first frame of\n * an mp3 bitstream<BR>\n * The Vbr header (optionally) contains\n * <UL>\n * <LI>frames total number of audio frames in the bitstream\n * <LI>bytes total number of bytes in the bitstream\n * <LI>toc table of contents\n * </UL>\n *\n * toc (table of contents) gives seek points for random access.<BR>\n * The ith entry determines the seek point for i-percent duration.<BR>\n * seek point in bytes = (toc[i]/256.0) * total_bitstream_bytes<BR>\n * e.g. half duration seek point = (toc[50]/256.0) * total_bitstream_bytes\n */\nVBRTag.NUMTOCENTRIES = 100;\nVBRTag.MAXFRAMESIZE = 2880;\n\nfunction VBRTag() {\n\n    var lame;\n    var bs;\n    var v;\n\n    this.setModules = function (_lame, _bs, _v) {\n        lame = _lame;\n        bs = _bs;\n        v = _v;\n    };\n\n    var FRAMES_FLAG = 0x0001;\n    var BYTES_FLAG = 0x0002;\n    var TOC_FLAG = 0x0004;\n    var VBR_SCALE_FLAG = 0x0008;\n\n    var NUMTOCENTRIES = VBRTag.NUMTOCENTRIES;\n\n    /**\n     * (0xB40) the max freeformat 640 32kHz framesize.\n     */\n    var MAXFRAMESIZE = VBRTag.MAXFRAMESIZE;\n\n    /**\n     * <PRE>\n     *    4 bytes for Header Tag\n     *    4 bytes for Header Flags\n     *  100 bytes for entry (toc)\n     *    4 bytes for frame size\n     *    4 bytes for stream size\n     *    4 bytes for VBR scale. a VBR quality indicator: 0=best 100=worst\n     *   20 bytes for LAME tag.  for example, \"LAME3.12 (beta 6)\"\n     * ___________\n     *  140 bytes\n     * </PRE>\n     */\n    var VBRHEADERSIZE = (NUMTOCENTRIES + 4 + 4 + 4 + 4 + 4);\n\n    var LAMEHEADERSIZE = (VBRHEADERSIZE + 9 + 1 + 1 + 8\n    + 1 + 1 + 3 + 1 + 1 + 2 + 4 + 2 + 2);\n\n    /**\n     * The size of the Xing header MPEG-1, bit rate in kbps.\n     */\n    var XING_BITRATE1 = 128;\n    /**\n     * The size of the Xing header MPEG-2, bit rate in kbps.\n     */\n    var XING_BITRATE2 = 64;\n    /**\n     * The size of the Xing header MPEG-2.5, bit rate in kbps.\n     */\n    var XING_BITRATE25 = 32;\n\n    /**\n     * ISO-8859-1 charset for byte to string operations.\n     */\n    var ISO_8859_1 = null; //Charset.forName(\"ISO-8859-1\");\n\n    /**\n     * VBR header magic string.\n     */\n    var VBRTag0 = \"Xing\";\n    /**\n     * VBR header magic string (VBR == VBRMode.vbr_off).\n     */\n    var VBRTag1 = \"Info\";\n\n    /**\n     * Lookup table for fast CRC-16 computation. Uses the polynomial\n     * x^16+x^15+x^2+1\n     */\n    var crc16Lookup = [0x0000, 0xC0C1, 0xC181, 0x0140,\n        0xC301, 0x03C0, 0x0280, 0xC241, 0xC601, 0x06C0, 0x0780, 0xC741,\n        0x0500, 0xC5C1, 0xC481, 0x0440, 0xCC01, 0x0CC0, 0x0D80, 0xCD41,\n        0x0F00, 0xCFC1, 0xCE81, 0x0E40, 0x0A00, 0xCAC1, 0xCB81, 0x0B40,\n        0xC901, 0x09C0, 0x0880, 0xC841, 0xD801, 0x18C0, 0x1980, 0xD941,\n        0x1B00, 0xDBC1, 0xDA81, 0x1A40, 0x1E00, 0xDEC1, 0xDF81, 0x1F40,\n        0xDD01, 0x1DC0, 0x1C80, 0xDC41, 0x1400, 0xD4C1, 0xD581, 0x1540,\n        0xD701, 0x17C0, 0x1680, 0xD641, 0xD201, 0x12C0, 0x1380, 0xD341,\n        0x1100, 0xD1C1, 0xD081, 0x1040, 0xF001, 0x30C0, 0x3180, 0xF141,\n        0x3300, 0xF3C1, 0xF281, 0x3240, 0x3600, 0xF6C1, 0xF781, 0x3740,\n        0xF501, 0x35C0, 0x3480, 0xF441, 0x3C00, 0xFCC1, 0xFD81, 0x3D40,\n        0xFF01, 0x3FC0, 0x3E80, 0xFE41, 0xFA01, 0x3AC0, 0x3B80, 0xFB41,\n        0x3900, 0xF9C1, 0xF881, 0x3840, 0x2800, 0xE8C1, 0xE981, 0x2940,\n        0xEB01, 0x2BC0, 0x2A80, 0xEA41, 0xEE01, 0x2EC0, 0x2F80, 0xEF41,\n        0x2D00, 0xEDC1, 0xEC81, 0x2C40, 0xE401, 0x24C0, 0x2580, 0xE541,\n        0x2700, 0xE7C1, 0xE681, 0x2640, 0x2200, 0xE2C1, 0xE381, 0x2340,\n        0xE101, 0x21C0, 0x2080, 0xE041, 0xA001, 0x60C0, 0x6180, 0xA141,\n        0x6300, 0xA3C1, 0xA281, 0x6240, 0x6600, 0xA6C1, 0xA781, 0x6740,\n        0xA501, 0x65C0, 0x6480, 0xA441, 0x6C00, 0xACC1, 0xAD81, 0x6D40,\n        0xAF01, 0x6FC0, 0x6E80, 0xAE41, 0xAA01, 0x6AC0, 0x6B80, 0xAB41,\n        0x6900, 0xA9C1, 0xA881, 0x6840, 0x7800, 0xB8C1, 0xB981, 0x7940,\n        0xBB01, 0x7BC0, 0x7A80, 0xBA41, 0xBE01, 0x7EC0, 0x7F80, 0xBF41,\n        0x7D00, 0xBDC1, 0xBC81, 0x7C40, 0xB401, 0x74C0, 0x7580, 0xB541,\n        0x7700, 0xB7C1, 0xB681, 0x7640, 0x7200, 0xB2C1, 0xB381, 0x7340,\n        0xB101, 0x71C0, 0x7080, 0xB041, 0x5000, 0x90C1, 0x9181, 0x5140,\n        0x9301, 0x53C0, 0x5280, 0x9241, 0x9601, 0x56C0, 0x5780, 0x9741,\n        0x5500, 0x95C1, 0x9481, 0x5440, 0x9C01, 0x5CC0, 0x5D80, 0x9D41,\n        0x5F00, 0x9FC1, 0x9E81, 0x5E40, 0x5A00, 0x9AC1, 0x9B81, 0x5B40,\n        0x9901, 0x59C0, 0x5880, 0x9841, 0x8801, 0x48C0, 0x4980, 0x8941,\n        0x4B00, 0x8BC1, 0x8A81, 0x4A40, 0x4E00, 0x8EC1, 0x8F81, 0x4F40,\n        0x8D01, 0x4DC0, 0x4C80, 0x8C41, 0x4400, 0x84C1, 0x8581, 0x4540,\n        0x8701, 0x47C0, 0x4680, 0x8641, 0x8201, 0x42C0, 0x4380, 0x8341,\n        0x4100, 0x81C1, 0x8081, 0x4040];\n\n    /***********************************************************************\n     * Robert Hegemann 2001-01-17\n     ***********************************************************************/\n\n    function addVbr(v, bitrate) {\n        v.nVbrNumFrames++;\n        v.sum += bitrate;\n        v.seen++;\n\n        if (v.seen < v.want) {\n            return;\n        }\n\n        if (v.pos < v.size) {\n            v.bag[v.pos] = v.sum;\n            v.pos++;\n            v.seen = 0;\n        }\n        if (v.pos == v.size) {\n            for (var i = 1; i < v.size; i += 2) {\n                v.bag[i / 2] = v.bag[i];\n            }\n            v.want *= 2;\n            v.pos /= 2;\n        }\n    }\n\n    function xingSeekTable(v, t) {\n        if (v.pos <= 0)\n            return;\n\n        for (var i = 1; i < NUMTOCENTRIES; ++i) {\n            var j = i / NUMTOCENTRIES, act, sum;\n            var indx = 0 | (Math.floor(j * v.pos));\n            if (indx > v.pos - 1)\n                indx = v.pos - 1;\n            act = v.bag[indx];\n            sum = v.sum;\n            var seek_point = 0 | (256. * act / sum);\n            if (seek_point > 255)\n                seek_point = 255;\n            t[i] = 0xff & seek_point;\n        }\n    }\n\n    /**\n     * Add VBR entry, used to fill the VBR TOC entries.\n     *\n     * @param gfp\n     *            global flags\n     */\n    this.addVbrFrame = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var kbps = Tables.bitrate_table[gfp.version][gfc.bitrate_index];\n        assert(gfc.VBR_seek_table.bag != null);\n        addVbr(gfc.VBR_seek_table, kbps);\n    }\n\n    /**\n     * Read big endian integer (4-bytes) from header.\n     *\n     * @param buf\n     *            header containing the integer\n     * @param bufPos\n     *            offset into the header\n     * @return extracted integer\n     */\n    function extractInteger(buf, bufPos) {\n        var x = buf[bufPos + 0] & 0xff;\n        x <<= 8;\n        x |= buf[bufPos + 1] & 0xff;\n        x <<= 8;\n        x |= buf[bufPos + 2] & 0xff;\n        x <<= 8;\n        x |= buf[bufPos + 3] & 0xff;\n        return x;\n    }\n\n    /**\n     * Write big endian integer (4-bytes) in the header.\n     *\n     * @param buf\n     *            header to write the integer into\n     * @param bufPos\n     *            offset into the header\n     * @param value\n     *            integer value to write\n     */\n    function createInteger(buf, bufPos, value) {\n        buf[bufPos + 0] = 0xff & ((value >> 24) & 0xff);\n        buf[bufPos + 1] = 0xff & ((value >> 16) & 0xff);\n        buf[bufPos + 2] = 0xff & ((value >> 8) & 0xff);\n        buf[bufPos + 3] = 0xff & (value & 0xff);\n    }\n\n    /**\n     * Write big endian short (2-bytes) in the header.\n     *\n     * @param buf\n     *            header to write the integer into\n     * @param bufPos\n     *            offset into the header\n     * @param value\n     *            integer value to write\n     */\n    function createShort(buf, bufPos, value) {\n        buf[bufPos + 0] = 0xff & ((value >> 8) & 0xff);\n        buf[bufPos + 1] = 0xff & (value & 0xff);\n    }\n\n    /**\n     * Check for magic strings (Xing/Info).\n     *\n     * @param buf\n     *            header to check\n     * @param bufPos\n     *            header offset to check\n     * @return magic string found\n     */\n    function isVbrTag(buf, bufPos) {\n        return new String(buf, bufPos, VBRTag0.length(), ISO_8859_1)\n                .equals(VBRTag0)\n            || new String(buf, bufPos, VBRTag1.length(), ISO_8859_1)\n                .equals(VBRTag1);\n    }\n\n    function shiftInBitsValue(x, n, v) {\n        return 0xff & ((x << n) | (v & ~(-1 << n)));\n    }\n\n    /**\n     * Construct the MP3 header using the settings of the global flags.\n     *\n     * <img src=\"1000px-Mp3filestructure.svg.png\">\n     *\n     * @param gfp\n     *            global flags\n     * @param buffer\n     *            header\n     */\n    function setLameTagFrameHeader(gfp, buffer) {\n        var gfc = gfp.internal_flags;\n\n        // MP3 Sync Word\n        buffer[0] = shiftInBitsValue(buffer[0], 8, 0xff);\n\n        buffer[1] = shiftInBitsValue(buffer[1], 3, 7);\n        buffer[1] = shiftInBitsValue(buffer[1], 1,\n            (gfp.out_samplerate < 16000) ? 0 : 1);\n        // Version\n        buffer[1] = shiftInBitsValue(buffer[1], 1, gfp.version);\n        // 01 == Layer 3\n        buffer[1] = shiftInBitsValue(buffer[1], 2, 4 - 3);\n        // Error protection\n        buffer[1] = shiftInBitsValue(buffer[1], 1, (!gfp.error_protection) ? 1\n            : 0);\n\n        // Bit rate\n        buffer[2] = shiftInBitsValue(buffer[2], 4, gfc.bitrate_index);\n        // Frequency\n        buffer[2] = shiftInBitsValue(buffer[2], 2, gfc.samplerate_index);\n        // Pad. Bit\n        buffer[2] = shiftInBitsValue(buffer[2], 1, 0);\n        // Priv. Bit\n        buffer[2] = shiftInBitsValue(buffer[2], 1, gfp.extension);\n\n        // Mode\n        buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.mode.ordinal());\n        // Mode extension (Used with Joint Stereo)\n        buffer[3] = shiftInBitsValue(buffer[3], 2, gfc.mode_ext);\n        // Copy\n        buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.copyright);\n        // Original\n        buffer[3] = shiftInBitsValue(buffer[3], 1, gfp.original);\n        // Emphasis\n        buffer[3] = shiftInBitsValue(buffer[3], 2, gfp.emphasis);\n\n        /* the default VBR header. 48 kbps layer III, no padding, no crc */\n        /* but sampling freq, mode and copyright/copy protection taken */\n        /* from first valid frame */\n        buffer[0] = 0xff;\n        var abyte = 0xff & (buffer[1] & 0xf1);\n        var bitrate;\n        if (1 == gfp.version) {\n            bitrate = XING_BITRATE1;\n        } else {\n            if (gfp.out_samplerate < 16000)\n                bitrate = XING_BITRATE25;\n            else\n                bitrate = XING_BITRATE2;\n        }\n\n        if (gfp.VBR == VbrMode.vbr_off)\n            bitrate = gfp.brate;\n\n        var bbyte;\n        if (gfp.free_format)\n            bbyte = 0x00;\n        else\n            bbyte = 0xff & (16 * lame.BitrateIndex(bitrate, gfp.version,\n                    gfp.out_samplerate));\n\n        /*\n         * Use as much of the info from the real frames in the Xing header:\n         * samplerate, channels, crc, etc...\n         */\n        if (gfp.version == 1) {\n            /* MPEG1 */\n            buffer[1] = 0xff & (abyte | 0x0a);\n            /* was 0x0b; */\n            abyte = 0xff & (buffer[2] & 0x0d);\n            /* AF keep also private bit */\n            buffer[2] = 0xff & (bbyte | abyte);\n            /* 64kbs MPEG1 frame */\n        } else {\n            /* MPEG2 */\n            buffer[1] = 0xff & (abyte | 0x02);\n            /* was 0x03; */\n            abyte = 0xff & (buffer[2] & 0x0d);\n            /* AF keep also private bit */\n            buffer[2] = 0xff & (bbyte | abyte);\n            /* 64kbs MPEG2 frame */\n        }\n    }\n\n    /**\n     * Get VBR tag information\n     *\n     * @param buf\n     *            header to analyze\n     * @param bufPos\n     *            offset into the header\n     * @return VBR tag data\n     */\n    this.getVbrTag = function (buf) {\n        var pTagData = new VBRTagData();\n        var bufPos = 0;\n\n        /* get Vbr header data */\n        pTagData.flags = 0;\n\n        /* get selected MPEG header data */\n        var hId = (buf[bufPos + 1] >> 3) & 1;\n        var hSrIndex = (buf[bufPos + 2] >> 2) & 3;\n        var hMode = (buf[bufPos + 3] >> 6) & 3;\n        var hBitrate = ((buf[bufPos + 2] >> 4) & 0xf);\n        hBitrate = Tables.bitrate_table[hId][hBitrate];\n\n        /* check for FFE syncword */\n        if ((buf[bufPos + 1] >> 4) == 0xE)\n            pTagData.samprate = Tables.samplerate_table[2][hSrIndex];\n        else\n            pTagData.samprate = Tables.samplerate_table[hId][hSrIndex];\n\n        /* determine offset of header */\n        if (hId != 0) {\n            /* mpeg1 */\n            if (hMode != 3)\n                bufPos += (32 + 4);\n            else\n                bufPos += (17 + 4);\n        } else {\n            /* mpeg2 */\n            if (hMode != 3)\n                bufPos += (17 + 4);\n            else\n                bufPos += (9 + 4);\n        }\n\n        if (!isVbrTag(buf, bufPos))\n            return null;\n\n        bufPos += 4;\n\n        pTagData.hId = hId;\n\n        /* get flags */\n        var head_flags = pTagData.flags = extractInteger(buf, bufPos);\n        bufPos += 4;\n\n        if ((head_flags & FRAMES_FLAG) != 0) {\n            pTagData.frames = extractInteger(buf, bufPos);\n            bufPos += 4;\n        }\n\n        if ((head_flags & BYTES_FLAG) != 0) {\n            pTagData.bytes = extractInteger(buf, bufPos);\n            bufPos += 4;\n        }\n\n        if ((head_flags & TOC_FLAG) != 0) {\n            if (pTagData.toc != null) {\n                for (var i = 0; i < NUMTOCENTRIES; i++)\n                    pTagData.toc[i] = buf[bufPos + i];\n            }\n            bufPos += NUMTOCENTRIES;\n        }\n\n        pTagData.vbrScale = -1;\n\n        if ((head_flags & VBR_SCALE_FLAG) != 0) {\n            pTagData.vbrScale = extractInteger(buf, bufPos);\n            bufPos += 4;\n        }\n\n        pTagData.headersize = ((hId + 1) * 72000 * hBitrate)\n            / pTagData.samprate;\n\n        bufPos += 21;\n        var encDelay = buf[bufPos + 0] << 4;\n        encDelay += buf[bufPos + 1] >> 4;\n        var encPadding = (buf[bufPos + 1] & 0x0F) << 8;\n        encPadding += buf[bufPos + 2] & 0xff;\n        /* check for reasonable values (this may be an old Xing header, */\n        /* not a INFO tag) */\n        if (encDelay < 0 || encDelay > 3000)\n            encDelay = -1;\n        if (encPadding < 0 || encPadding > 3000)\n            encPadding = -1;\n\n        pTagData.encDelay = encDelay;\n        pTagData.encPadding = encPadding;\n\n        /* success */\n        return pTagData;\n    }\n\n    /**\n     * Initializes the header\n     *\n     * @param gfp\n     *            global flags\n     */\n    this.InitVbrTag = function (gfp) {\n        var gfc = gfp.internal_flags;\n\n        /**\n         * <PRE>\n         * Xing VBR pretends to be a 48kbs layer III frame.  (at 44.1kHz).\n         * (at 48kHz they use 56kbs since 48kbs frame not big enough for\n         * table of contents)\n         * let's always embed Xing header inside a 64kbs layer III frame.\n         * this gives us enough room for a LAME version string too.\n         * size determined by sampling frequency (MPEG1)\n         * 32kHz:    216 bytes@48kbs    288bytes@ 64kbs\n         * 44.1kHz:  156 bytes          208bytes@64kbs     (+1 if padding = 1)\n         * 48kHz:    144 bytes          192\n         *\n         * MPEG 2 values are the same since the framesize and samplerate\n         * are each reduced by a factor of 2.\n         * </PRE>\n         */\n        var kbps_header;\n        if (1 == gfp.version) {\n            kbps_header = XING_BITRATE1;\n        } else {\n            if (gfp.out_samplerate < 16000)\n                kbps_header = XING_BITRATE25;\n            else\n                kbps_header = XING_BITRATE2;\n        }\n\n        if (gfp.VBR == VbrMode.vbr_off)\n            kbps_header = gfp.brate;\n\n        // make sure LAME Header fits into Frame\n        var totalFrameSize = ((gfp.version + 1) * 72000 * kbps_header)\n            / gfp.out_samplerate;\n        var headerSize = (gfc.sideinfo_len + LAMEHEADERSIZE);\n        gfc.VBR_seek_table.TotalFrameSize = totalFrameSize;\n        if (totalFrameSize < headerSize || totalFrameSize > MAXFRAMESIZE) {\n            /* disable tag, it wont fit */\n            gfp.bWriteVbrTag = false;\n            return;\n        }\n\n        gfc.VBR_seek_table.nVbrNumFrames = 0;\n        gfc.VBR_seek_table.nBytesWritten = 0;\n        gfc.VBR_seek_table.sum = 0;\n\n        gfc.VBR_seek_table.seen = 0;\n        gfc.VBR_seek_table.want = 1;\n        gfc.VBR_seek_table.pos = 0;\n\n        if (gfc.VBR_seek_table.bag == null) {\n            gfc.VBR_seek_table.bag = new int[400];\n            gfc.VBR_seek_table.size = 400;\n        }\n\n        // write dummy VBR tag of all 0's into bitstream\n        var buffer = new_byte(MAXFRAMESIZE);\n\n        setLameTagFrameHeader(gfp, buffer);\n        var n = gfc.VBR_seek_table.TotalFrameSize;\n        for (var i = 0; i < n; ++i) {\n            bs.add_dummy_byte(gfp, buffer[i] & 0xff, 1);\n        }\n    }\n\n    /**\n     * Fast CRC-16 computation (uses table crc16Lookup).\n     *\n     * @param value\n     * @param crc\n     * @return\n     */\n    function crcUpdateLookup(value, crc) {\n        var tmp = crc ^ value;\n        crc = (crc >> 8) ^ crc16Lookup[tmp & 0xff];\n        return crc;\n    }\n\n    this.updateMusicCRC = function (crc, buffer, bufferPos, size) {\n        for (var i = 0; i < size; ++i)\n            crc[0] = crcUpdateLookup(buffer[bufferPos + i], crc[0]);\n    }\n\n    /**\n     * Write LAME info: mini version + info on various switches used (Jonathan\n     * Dee 2001/08/31).\n     *\n     * @param gfp\n     *            global flags\n     * @param musicLength\n     *            music length\n     * @param streamBuffer\n     *            pointer to output buffer\n     * @param streamBufferPos\n     *            offset into the output buffer\n     * @param crc\n     *            computation of CRC-16 of Lame Tag so far (starting at frame\n     *            sync)\n     * @return number of bytes written to the stream\n     */\n    function putLameVBR(gfp, musicLength, streamBuffer, streamBufferPos, crc) {\n        var gfc = gfp.internal_flags;\n        var bytesWritten = 0;\n\n        /* encoder delay */\n        var encDelay = gfp.encoder_delay;\n        /* encoder padding */\n        var encPadding = gfp.encoder_padding;\n\n        /* recall: gfp.VBR_q is for example set by the switch -V */\n        /* gfp.quality by -q, -h, -f, etc */\n        var quality = (100 - 10 * gfp.VBR_q - gfp.quality);\n\n        var version = v.getLameVeryShortVersion();\n        var vbr;\n        var revision = 0x00;\n        var revMethod;\n        // numbering different in vbr_mode vs. Lame tag\n        var vbrTypeTranslator = [1, 5, 3, 2, 4, 0, 3];\n        var lowpass = 0 | (((gfp.lowpassfreq / 100.0) + .5) > 255 ? 255\n                : (gfp.lowpassfreq / 100.0) + .5);\n        var peakSignalAmplitude = 0;\n        var radioReplayGain = 0;\n        var audiophileReplayGain = 0;\n        var noiseShaping = gfp.internal_flags.noise_shaping;\n        var stereoMode = 0;\n        var nonOptimal = 0;\n        var sourceFreq = 0;\n        var misc = 0;\n        var musicCRC = 0;\n\n        // psy model type: Gpsycho or NsPsytune\n        var expNPsyTune = (gfp.exp_nspsytune & 1) != 0;\n        var safeJoint = (gfp.exp_nspsytune & 2) != 0;\n        var noGapMore = false;\n        var noGapPrevious = false;\n        var noGapCount = gfp.internal_flags.nogap_total;\n        var noGapCurr = gfp.internal_flags.nogap_current;\n\n        // 4 bits\n        var athType = gfp.ATHtype;\n        var flags = 0;\n\n        // vbr modes\n        var abrBitrate;\n        switch (gfp.VBR) {\n            case vbr_abr:\n                abrBitrate = gfp.VBR_mean_bitrate_kbps;\n                break;\n            case vbr_off:\n                abrBitrate = gfp.brate;\n                break;\n            default:\n                abrBitrate = gfp.VBR_min_bitrate_kbps;\n        }\n\n        // revision and vbr method\n        if (gfp.VBR.ordinal() < vbrTypeTranslator.length)\n            vbr = vbrTypeTranslator[gfp.VBR.ordinal()];\n        else\n            vbr = 0x00; // unknown\n\n        revMethod = 0x10 * revision + vbr;\n\n        // ReplayGain\n        if (gfc.findReplayGain) {\n            if (gfc.RadioGain > 0x1FE)\n                gfc.RadioGain = 0x1FE;\n            if (gfc.RadioGain < -0x1FE)\n                gfc.RadioGain = -0x1FE;\n\n            // set name code\n            radioReplayGain = 0x2000;\n            // set originator code to `determined automatically'\n            radioReplayGain |= 0xC00;\n\n            if (gfc.RadioGain >= 0) {\n                // set gain adjustment\n                radioReplayGain |= gfc.RadioGain;\n            } else {\n                // set the sign bit\n                radioReplayGain |= 0x200;\n                // set gain adjustment\n                radioReplayGain |= -gfc.RadioGain;\n            }\n        }\n\n        // peak sample\n        if (gfc.findPeakSample)\n            peakSignalAmplitude = Math\n                .abs(0 | ((( gfc.PeakSample) / 32767.0) * Math.pow(2, 23) + .5));\n\n        // nogap\n        if (noGapCount != -1) {\n            if (noGapCurr > 0)\n                noGapPrevious = true;\n\n            if (noGapCurr < noGapCount - 1)\n                noGapMore = true;\n        }\n\n        // flags\n        flags = athType + ((expNPsyTune ? 1 : 0) << 4)\n            + ((safeJoint ? 1 : 0) << 5) + ((noGapMore ? 1 : 0) << 6)\n            + ((noGapPrevious ? 1 : 0) << 7);\n\n        if (quality < 0)\n            quality = 0;\n\n        // stereo mode field (Intensity stereo is not implemented)\n        switch (gfp.mode) {\n            case MONO:\n                stereoMode = 0;\n                break;\n            case STEREO:\n                stereoMode = 1;\n                break;\n            case DUAL_CHANNEL:\n                stereoMode = 2;\n                break;\n            case JOINT_STEREO:\n                if (gfp.force_ms)\n                    stereoMode = 4;\n                else\n                    stereoMode = 3;\n                break;\n            case NOT_SET:\n            //$FALL-THROUGH$\n            default:\n                stereoMode = 7;\n                break;\n        }\n\n        if (gfp.in_samplerate <= 32000)\n            sourceFreq = 0x00;\n        else if (gfp.in_samplerate == 48000)\n            sourceFreq = 0x02;\n        else if (gfp.in_samplerate > 48000)\n            sourceFreq = 0x03;\n        else {\n            // default is 44100Hz\n            sourceFreq = 0x01;\n        }\n\n        // Check if the user overrided the default LAME behavior with some\n        // nasty options\n        if (gfp.short_blocks == ShortBlock.short_block_forced\n            || gfp.short_blocks == ShortBlock.short_block_dispensed\n            || ((gfp.lowpassfreq == -1) && (gfp.highpassfreq == -1)) || /* \"-k\" */\n            (gfp.scale_left < gfp.scale_right)\n            || (gfp.scale_left > gfp.scale_right)\n            || (gfp.disable_reservoir && gfp.brate < 320) || gfp.noATH\n            || gfp.ATHonly || (athType == 0) || gfp.in_samplerate <= 32000)\n            nonOptimal = 1;\n\n        misc = noiseShaping + (stereoMode << 2) + (nonOptimal << 5)\n            + (sourceFreq << 6);\n\n        musicCRC = gfc.nMusicCRC;\n\n        // Write all this information into the stream\n\n        createInteger(streamBuffer, streamBufferPos + bytesWritten, quality);\n        bytesWritten += 4;\n\n        for (var j = 0; j < 9; j++) {\n            streamBuffer[streamBufferPos + bytesWritten + j] = 0xff & version .charAt(j);\n        }\n        bytesWritten += 9;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & revMethod;\n        bytesWritten++;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & lowpass;\n        bytesWritten++;\n\n        createInteger(streamBuffer, streamBufferPos + bytesWritten,\n            peakSignalAmplitude);\n        bytesWritten += 4;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten,\n            radioReplayGain);\n        bytesWritten += 2;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten,\n            audiophileReplayGain);\n        bytesWritten += 2;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & flags;\n        bytesWritten++;\n\n        if (abrBitrate >= 255)\n            streamBuffer[streamBufferPos + bytesWritten] = 0xFF;\n        else\n            streamBuffer[streamBufferPos + bytesWritten] = 0xff & abrBitrate;\n        bytesWritten++;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & (encDelay >> 4);\n        streamBuffer[streamBufferPos + bytesWritten + 1] = 0xff & ((encDelay << 4) + (encPadding >> 8));\n        streamBuffer[streamBufferPos + bytesWritten + 2] = 0xff & encPadding;\n\n        bytesWritten += 3;\n\n        streamBuffer[streamBufferPos + bytesWritten] = 0xff & misc;\n        bytesWritten++;\n\n        // unused in rev0\n        streamBuffer[streamBufferPos + bytesWritten++] = 0;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten, gfp.preset);\n        bytesWritten += 2;\n\n        createInteger(streamBuffer, streamBufferPos + bytesWritten, musicLength);\n        bytesWritten += 4;\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten, musicCRC);\n        bytesWritten += 2;\n\n        // Calculate tag CRC.... must be done here, since it includes previous\n        // information\n\n        for (var i = 0; i < bytesWritten; i++)\n            crc = crcUpdateLookup(streamBuffer[streamBufferPos + i], crc);\n\n        createShort(streamBuffer, streamBufferPos + bytesWritten, crc);\n        bytesWritten += 2;\n\n        return bytesWritten;\n    }\n\n    function skipId3v2(fpStream) {\n        // seek to the beginning of the stream\n        fpStream.seek(0);\n        // read 10 bytes in case there's an ID3 version 2 header here\n        var id3v2Header = new_byte(10);\n        fpStream.readFully(id3v2Header);\n        /* does the stream begin with the ID3 version 2 file identifier? */\n        var id3v2TagSize;\n        if (!new String(id3v2Header, \"ISO-8859-1\").startsWith(\"ID3\")) {\n            /*\n             * the tag size (minus the 10-byte header) is encoded into four\n             * bytes where the most significant bit is clear in each byte\n             */\n            id3v2TagSize = (((id3v2Header[6] & 0x7f) << 21)\n                | ((id3v2Header[7] & 0x7f) << 14)\n                | ((id3v2Header[8] & 0x7f) << 7) | (id3v2Header[9] & 0x7f))\n                + id3v2Header.length;\n        } else {\n            /* no ID3 version 2 tag in this stream */\n            id3v2TagSize = 0;\n        }\n        return id3v2TagSize;\n    }\n\n    this.getLameTagFrame = function (gfp, buffer) {\n        var gfc = gfp.internal_flags;\n\n        if (!gfp.bWriteVbrTag) {\n            return 0;\n        }\n        if (gfc.Class_ID != Lame.LAME_ID) {\n            return 0;\n        }\n        if (gfc.VBR_seek_table.pos <= 0) {\n            return 0;\n        }\n        if (buffer.length < gfc.VBR_seek_table.TotalFrameSize) {\n            return gfc.VBR_seek_table.TotalFrameSize;\n        }\n\n        Arrays.fill(buffer, 0, gfc.VBR_seek_table.TotalFrameSize, 0);\n\n        // 4 bytes frame header\n        setLameTagFrameHeader(gfp, buffer);\n\n        // Create TOC entries\n        var toc = new_byte(NUMTOCENTRIES);\n\n        if (gfp.free_format) {\n            for (var i = 1; i < NUMTOCENTRIES; ++i)\n                toc[i] = 0xff & (255 * i / 100);\n        } else {\n            xingSeekTable(gfc.VBR_seek_table, toc);\n        }\n\n        // Start writing the tag after the zero frame\n        var streamIndex = gfc.sideinfo_len;\n        /**\n         * Note: Xing header specifies that Xing data goes in the ancillary data\n         * with NO ERROR PROTECTION. If error protecton in enabled, the Xing\n         * data still starts at the same offset, and now it is in sideinfo data\n         * block, and thus will not decode correctly by non-Xing tag aware\n         * players\n         */\n        if (gfp.error_protection)\n            streamIndex -= 2;\n\n        // Put Vbr tag\n        if (gfp.VBR == VbrMode.vbr_off) {\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(0);\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(1);\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(2);\n            buffer[streamIndex++] = 0xff & VBRTag1.charAt(3);\n\n        } else {\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(0);\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(1);\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(2);\n            buffer[streamIndex++] = 0xff & VBRTag0.charAt(3);\n        }\n\n        // Put header flags\n        createInteger(buffer, streamIndex, FRAMES_FLAG + BYTES_FLAG + TOC_FLAG\n            + VBR_SCALE_FLAG);\n        streamIndex += 4;\n\n        // Put Total Number of frames\n        createInteger(buffer, streamIndex, gfc.VBR_seek_table.nVbrNumFrames);\n        streamIndex += 4;\n\n        // Put total audio stream size, including Xing/LAME Header\n        var streamSize = (gfc.VBR_seek_table.nBytesWritten + gfc.VBR_seek_table.TotalFrameSize);\n        createInteger(buffer, streamIndex, 0 | streamSize);\n        streamIndex += 4;\n\n        /* Put TOC */\n        System.arraycopy(toc, 0, buffer, streamIndex, toc.length);\n        streamIndex += toc.length;\n\n        if (gfp.error_protection) {\n            // (jo) error_protection: add crc16 information to header\n            bs.CRC_writeheader(gfc, buffer);\n        }\n\n        // work out CRC so far: initially crc = 0\n        var crc = 0x00;\n        for (var i = 0; i < streamIndex; i++)\n            crc = crcUpdateLookup(buffer[i], crc);\n        // Put LAME VBR info\n        streamIndex += putLameVBR(gfp, streamSize, buffer, streamIndex, crc);\n\n        return gfc.VBR_seek_table.TotalFrameSize;\n    }\n\n    /**\n     * Write final VBR tag to the file.\n     *\n     * @param gfp\n     *            global flags\n     * @param stream\n     *            stream to add the VBR tag to\n     * @return 0 (OK), -1 else\n     * @throws IOException\n     *             I/O error\n     */\n    this.putVbrTag = function (gfp, stream) {\n        var gfc = gfp.internal_flags;\n\n        if (gfc.VBR_seek_table.pos <= 0)\n            return -1;\n\n        // Seek to end of file\n        stream.seek(stream.length());\n\n        // Get file size, abort if file has zero length.\n        if (stream.length() == 0)\n            return -1;\n\n        // The VBR tag may NOT be located at the beginning of the stream. If an\n        // ID3 version 2 tag was added, then it must be skipped to write the VBR\n        // tag data.\n        var id3v2TagSize = skipId3v2(stream);\n\n        // Seek to the beginning of the stream\n        stream.seek(id3v2TagSize);\n\n        var buffer = new_byte(MAXFRAMESIZE);\n        var bytes = getLameTagFrame(gfp, buffer);\n        if (bytes > buffer.length) {\n            return -1;\n        }\n\n        if (bytes < 1) {\n            return 0;\n        }\n\n        // Put it all to disk again\n        stream.write(buffer, 0, bytes);\n        // success\n        return 0;\n    }\n\n}\n\nmodule.exports = VBRTag;\n"],"mappings":"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AE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAC9D,MAAM,EAAE,MA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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}