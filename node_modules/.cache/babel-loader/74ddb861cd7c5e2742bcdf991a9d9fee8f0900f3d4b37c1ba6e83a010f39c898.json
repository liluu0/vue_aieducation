{"ast":null,"code":"/*\n *      quantize_pvt source file\n *\n *      Copyright (c) 1999-2002 Takehiro Tominaga\n *      Copyright (c) 2000-2002 Robert Hegemann\n *      Copyright (c) 2001 Naoki Shibata\n *      Copyright (c) 2002-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: QuantizePVT.java,v 1.24 2011/05/24 20:48:06 kenchis Exp $ */\nvar ScaleFac = require('./ScaleFac.js');\nvar common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\nvar Encoder = require('./Encoder.js');\nvar MeanBits = require('./MeanBits.js');\nvar LameInternalFlags = require('./LameInternalFlags.js');\nQuantizePVT.Q_MAX = 256 + 1;\nQuantizePVT.Q_MAX2 = 116;\nQuantizePVT.LARGE_BITS = 100000;\nQuantizePVT.IXMAX_VAL = 8206;\nfunction QuantizePVT() {\n  var tak = null;\n  var rv = null;\n  var psy = null;\n  this.setModules = function (_tk, _rv, _psy) {\n    tak = _tk;\n    rv = _rv;\n    psy = _psy;\n  };\n  function POW20(x) {\n    assert(0 <= x + QuantizePVT.Q_MAX2 && x < QuantizePVT.Q_MAX);\n    return pow20[x + QuantizePVT.Q_MAX2];\n  }\n  this.IPOW20 = function (x) {\n    assert(0 <= x && x < QuantizePVT.Q_MAX);\n    return ipow20[x];\n  };\n\n  /**\n   * smallest such that 1.0+DBL_EPSILON != 1.0\n   */\n  var DBL_EPSILON = 2.2204460492503131e-016;\n\n  /**\n   * ix always <= 8191+15. see count_bits()\n   */\n  var IXMAX_VAL = QuantizePVT.IXMAX_VAL;\n  var PRECALC_SIZE = IXMAX_VAL + 2;\n  var Q_MAX = QuantizePVT.Q_MAX;\n\n  /**\n   * <CODE>\n   * minimum possible number of\n   * -cod_info.global_gain + ((scalefac[] + (cod_info.preflag ? pretab[sfb] : 0))\n   * << (cod_info.scalefac_scale + 1)) + cod_info.subblock_gain[cod_info.window[sfb]] * 8;\n   *\n   * for long block, 0+((15+3)<<2) = 18*4 = 72\n   * for short block, 0+(15<<2)+7*8 = 15*4+56 = 116\n   * </CODE>\n   */\n  var Q_MAX2 = QuantizePVT.Q_MAX2;\n  var LARGE_BITS = QuantizePVT.LARGE_BITS;\n\n  /**\n   * Assuming dynamic range=96dB, this value should be 92\n   */\n  var NSATHSCALE = 100;\n\n  /**\n   * The following table is used to implement the scalefactor partitioning for\n   * MPEG2 as described in section 2.4.3.2 of the IS. The indexing corresponds\n   * to the way the tables are presented in the IS:\n   *\n   * [table_number][row_in_table][column of nr_of_sfb]\n   */\n  this.nr_of_sfb_block = [[[6, 5, 5, 5], [9, 9, 9, 9], [6, 9, 9, 9]], [[6, 5, 7, 3], [9, 9, 12, 6], [6, 9, 12, 6]], [[11, 10, 0, 0], [18, 18, 0, 0], [15, 18, 0, 0]], [[7, 7, 7, 0], [12, 12, 12, 0], [6, 15, 12, 0]], [[6, 6, 6, 3], [12, 9, 9, 6], [6, 12, 9, 6]], [[8, 8, 5, 0], [15, 12, 9, 0], [6, 18, 9, 0]]];\n\n  /**\n   * Table B.6: layer3 preemphasis\n   */\n  var pretab = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 3, 3, 3, 2, 0];\n  this.pretab = pretab;\n\n  /**\n   * Here are MPEG1 Table B.8 and MPEG2 Table B.1 -- Layer III scalefactor\n   * bands. <BR>\n   * Index into this using a method such as:<BR>\n   * idx = fr_ps.header.sampling_frequency + (fr_ps.header.version * 3)\n   */\n  this.sfBandIndex = [\n  // Table B.2.b: 22.05 kHz\n  new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576], [0, 4, 8, 12, 18, 24, 32, 42, 56, 74, 100, 132, 174, 192], [0, 0, 0, 0, 0, 0, 0] //  sfb21 pseudo sub bands\n  , [0, 0, 0, 0, 0, 0, 0] //  sfb12 pseudo sub bands\n  ), /* Table B.2.c: 24 kHz */ /* docs: 332. mpg123(broken): 330 */\n  new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 114, 136, 162, 194, 232, 278, 332, 394, 464, 540, 576], [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 136, 180, 192], [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */, [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */), /* Table B.2.a: 16 kHz */\n  new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576], [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 134, 174, 192], [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */, [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */), /* Table B.8.b: 44.1 kHz */\n  new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 52, 62, 74, 90, 110, 134, 162, 196, 238, 288, 342, 418, 576], [0, 4, 8, 12, 16, 22, 30, 40, 52, 66, 84, 106, 136, 192], [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */, [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */), /* Table B.8.c: 48 kHz */\n  new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 42, 50, 60, 72, 88, 106, 128, 156, 190, 230, 276, 330, 384, 576], [0, 4, 8, 12, 16, 22, 28, 38, 50, 64, 80, 100, 126, 192], [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */, [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */), /* Table B.8.a: 32 kHz */\n  new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 54, 66, 82, 102, 126, 156, 194, 240, 296, 364, 448, 550, 576], [0, 4, 8, 12, 16, 22, 30, 42, 58, 78, 104, 138, 180, 192], [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */, [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */), /* MPEG-2.5 11.025 kHz */\n  new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576], [0 / 3, 12 / 3, 24 / 3, 36 / 3, 54 / 3, 78 / 3, 108 / 3, 144 / 3, 186 / 3, 240 / 3, 312 / 3, 402 / 3, 522 / 3, 576 / 3], [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */, [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */), /* MPEG-2.5 12 kHz */\n  new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464, 522, 576], [0 / 3, 12 / 3, 24 / 3, 36 / 3, 54 / 3, 78 / 3, 108 / 3, 144 / 3, 186 / 3, 240 / 3, 312 / 3, 402 / 3, 522 / 3, 576 / 3], [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */, [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */), /* MPEG-2.5 8 kHz */\n  new ScaleFac([0, 12, 24, 36, 48, 60, 72, 88, 108, 132, 160, 192, 232, 280, 336, 400, 476, 566, 568, 570, 572, 574, 576], [0 / 3, 24 / 3, 48 / 3, 72 / 3, 108 / 3, 156 / 3, 216 / 3, 288 / 3, 372 / 3, 480 / 3, 486 / 3, 492 / 3, 498 / 3, 576 / 3], [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */, [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */)];\n  var pow20 = new_float(Q_MAX + Q_MAX2 + 1);\n  var ipow20 = new_float(Q_MAX);\n  var pow43 = new_float(PRECALC_SIZE);\n  var adj43 = new_float(PRECALC_SIZE);\n  this.adj43 = adj43;\n\n  /**\n   * <PRE>\n   * compute the ATH for each scalefactor band cd range: 0..96db\n   *\n   * Input: 3.3kHz signal 32767 amplitude (3.3kHz is where ATH is smallest =\n   * -5db) longblocks: sfb=12 en0/bw=-11db max_en0 = 1.3db shortblocks: sfb=5\n   * -9db 0db\n   *\n   * Input: 1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated) longblocks: amp=1\n   * sfb=12 en0/bw=-103 db max_en0 = -92db amp=32767 sfb=12 -12 db -1.4db\n   *\n   * Input: 1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated) shortblocks: amp=1\n   * sfb=5 en0/bw= -99 -86 amp=32767 sfb=5 -9 db 4db\n   *\n   *\n   * MAX energy of largest wave at 3.3kHz = 1db AVE energy of largest wave at\n   * 3.3kHz = -11db Let's take AVE: -11db = maximum signal in sfb=12. Dynamic\n   * range of CD: 96db. Therefor energy of smallest audible wave in sfb=12 =\n   * -11 - 96 = -107db = ATH at 3.3kHz.\n   *\n   * ATH formula for this wave: -5db. To adjust to LAME scaling, we need ATH =\n   * ATH_formula - 103 (db) ATH = ATH * 2.5e-10 (ener)\n   * </PRE>\n   */\n  function ATHmdct(gfp, f) {\n    var ath = psy.ATHformula(f, gfp);\n    ath -= NSATHSCALE;\n\n    /* modify the MDCT scaling for the ATH and convert to energy */\n    ath = Math.pow(10.0, ath / 10.0 + gfp.ATHlower);\n    return ath;\n  }\n  function compute_ath(gfp) {\n    var ATH_l = gfp.internal_flags.ATH.l;\n    var ATH_psfb21 = gfp.internal_flags.ATH.psfb21;\n    var ATH_s = gfp.internal_flags.ATH.s;\n    var ATH_psfb12 = gfp.internal_flags.ATH.psfb12;\n    var gfc = gfp.internal_flags;\n    var samp_freq = gfp.out_samplerate;\n    for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n      var start = gfc.scalefac_band.l[sfb];\n      var end = gfc.scalefac_band.l[sfb + 1];\n      ATH_l[sfb] = Float.MAX_VALUE;\n      for (var i = start; i < end; i++) {\n        var freq = i * samp_freq / (2 * 576);\n        var ATH_f = ATHmdct(gfp, freq);\n        /* freq in kHz */\n        ATH_l[sfb] = Math.min(ATH_l[sfb], ATH_f);\n      }\n    }\n    for (var sfb = 0; sfb < Encoder.PSFB21; sfb++) {\n      var start = gfc.scalefac_band.psfb21[sfb];\n      var end = gfc.scalefac_band.psfb21[sfb + 1];\n      ATH_psfb21[sfb] = Float.MAX_VALUE;\n      for (var i = start; i < end; i++) {\n        var freq = i * samp_freq / (2 * 576);\n        var ATH_f = ATHmdct(gfp, freq);\n        /* freq in kHz */\n        ATH_psfb21[sfb] = Math.min(ATH_psfb21[sfb], ATH_f);\n      }\n    }\n    for (var sfb = 0; sfb < Encoder.SBMAX_s; sfb++) {\n      var start = gfc.scalefac_band.s[sfb];\n      var end = gfc.scalefac_band.s[sfb + 1];\n      ATH_s[sfb] = Float.MAX_VALUE;\n      for (var i = start; i < end; i++) {\n        var freq = i * samp_freq / (2 * 192);\n        var ATH_f = ATHmdct(gfp, freq);\n        /* freq in kHz */\n        ATH_s[sfb] = Math.min(ATH_s[sfb], ATH_f);\n      }\n      ATH_s[sfb] *= gfc.scalefac_band.s[sfb + 1] - gfc.scalefac_band.s[sfb];\n    }\n    for (var sfb = 0; sfb < Encoder.PSFB12; sfb++) {\n      var start = gfc.scalefac_band.psfb12[sfb];\n      var end = gfc.scalefac_band.psfb12[sfb + 1];\n      ATH_psfb12[sfb] = Float.MAX_VALUE;\n      for (var i = start; i < end; i++) {\n        var freq = i * samp_freq / (2 * 192);\n        var ATH_f = ATHmdct(gfp, freq);\n        /* freq in kHz */\n        ATH_psfb12[sfb] = Math.min(ATH_psfb12[sfb], ATH_f);\n      }\n      /* not sure about the following */\n      ATH_psfb12[sfb] *= gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12];\n    }\n\n    /*\n     * no-ATH mode: reduce ATH to -200 dB\n     */\n    if (gfp.noATH) {\n      for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n        ATH_l[sfb] = 1E-20;\n      }\n      for (var sfb = 0; sfb < Encoder.PSFB21; sfb++) {\n        ATH_psfb21[sfb] = 1E-20;\n      }\n      for (var sfb = 0; sfb < Encoder.SBMAX_s; sfb++) {\n        ATH_s[sfb] = 1E-20;\n      }\n      for (var sfb = 0; sfb < Encoder.PSFB12; sfb++) {\n        ATH_psfb12[sfb] = 1E-20;\n      }\n    }\n\n    /*\n     * work in progress, don't rely on it too much\n     */\n    gfc.ATH.floor = 10. * Math.log10(ATHmdct(gfp, -1.));\n  }\n\n  /**\n   * initialization for iteration_loop\n   */\n  this.iteration_init = function (gfp) {\n    var gfc = gfp.internal_flags;\n    var l3_side = gfc.l3_side;\n    var i;\n    if (gfc.iteration_init_init == 0) {\n      gfc.iteration_init_init = 1;\n      l3_side.main_data_begin = 0;\n      compute_ath(gfp);\n      pow43[0] = 0.0;\n      for (i = 1; i < PRECALC_SIZE; i++) pow43[i] = Math.pow(i, 4.0 / 3.0);\n      for (i = 0; i < PRECALC_SIZE - 1; i++) adj43[i] = i + 1 - Math.pow(0.5 * (pow43[i] + pow43[i + 1]), 0.75);\n      adj43[i] = 0.5;\n      for (i = 0; i < Q_MAX; i++) ipow20[i] = Math.pow(2.0, (i - 210) * -0.1875);\n      for (i = 0; i <= Q_MAX + Q_MAX2; i++) pow20[i] = Math.pow(2.0, (i - 210 - Q_MAX2) * 0.25);\n      tak.huffman_init(gfc);\n      {\n        var bass, alto, treble, sfb21;\n        i = gfp.exp_nspsytune >> 2 & 63;\n        if (i >= 32) i -= 64;\n        bass = Math.pow(10, i / 4.0 / 10.0);\n        i = gfp.exp_nspsytune >> 8 & 63;\n        if (i >= 32) i -= 64;\n        alto = Math.pow(10, i / 4.0 / 10.0);\n        i = gfp.exp_nspsytune >> 14 & 63;\n        if (i >= 32) i -= 64;\n        treble = Math.pow(10, i / 4.0 / 10.0);\n\n        /*\n         * to be compatible with Naoki's original code, the next 6 bits\n         * define only the amount of changing treble for sfb21\n         */\n        i = gfp.exp_nspsytune >> 20 & 63;\n        if (i >= 32) i -= 64;\n        sfb21 = treble * Math.pow(10, i / 4.0 / 10.0);\n        for (i = 0; i < Encoder.SBMAX_l; i++) {\n          var f;\n          if (i <= 6) f = bass;else if (i <= 13) f = alto;else if (i <= 20) f = treble;else f = sfb21;\n          gfc.nsPsy.longfact[i] = f;\n        }\n        for (i = 0; i < Encoder.SBMAX_s; i++) {\n          var f;\n          if (i <= 5) f = bass;else if (i <= 10) f = alto;else if (i <= 11) f = treble;else f = sfb21;\n          gfc.nsPsy.shortfact[i] = f;\n        }\n      }\n    }\n  };\n\n  /**\n   * allocate bits among 2 channels based on PE<BR>\n   * mt 6/99<BR>\n   * bugfixes rh 8/01: often allocated more than the allowed 4095 bits\n   */\n  this.on_pe = function (gfp, pe, targ_bits, mean_bits, gr, cbr) {\n    var gfc = gfp.internal_flags;\n    var tbits = 0,\n      bits;\n    var add_bits = new_int(2);\n    var ch;\n\n    /* allocate targ_bits for granule */\n    var mb = new MeanBits(tbits);\n    var extra_bits = rv.ResvMaxBits(gfp, mean_bits, mb, cbr);\n    tbits = mb.bits;\n    /* maximum allowed bits for this granule */\n    var max_bits = tbits + extra_bits;\n    if (max_bits > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n      // hard limit per granule\n      max_bits = LameInternalFlags.MAX_BITS_PER_GRANULE;\n    }\n    for (bits = 0, ch = 0; ch < gfc.channels_out; ++ch) {\n      /******************************************************************\n       * allocate bits for each channel\n       ******************************************************************/\n      targ_bits[ch] = Math.min(LameInternalFlags.MAX_BITS_PER_CHANNEL, tbits / gfc.channels_out);\n      add_bits[ch] = 0 | targ_bits[ch] * pe[gr][ch] / 700.0 - targ_bits[ch];\n\n      /* at most increase bits by 1.5*average */\n      if (add_bits[ch] > mean_bits * 3 / 4) add_bits[ch] = mean_bits * 3 / 4;\n      if (add_bits[ch] < 0) add_bits[ch] = 0;\n      if (add_bits[ch] + targ_bits[ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL) add_bits[ch] = Math.max(0, LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[ch]);\n      bits += add_bits[ch];\n    }\n    if (bits > extra_bits) {\n      for (ch = 0; ch < gfc.channels_out; ++ch) {\n        add_bits[ch] = extra_bits * add_bits[ch] / bits;\n      }\n    }\n    for (ch = 0; ch < gfc.channels_out; ++ch) {\n      targ_bits[ch] += add_bits[ch];\n      extra_bits -= add_bits[ch];\n    }\n    for (bits = 0, ch = 0; ch < gfc.channels_out; ++ch) {\n      bits += targ_bits[ch];\n    }\n    if (bits > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n      var sum = 0;\n      for (ch = 0; ch < gfc.channels_out; ++ch) {\n        targ_bits[ch] *= LameInternalFlags.MAX_BITS_PER_GRANULE;\n        targ_bits[ch] /= bits;\n        sum += targ_bits[ch];\n      }\n      assert(sum <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n    }\n    return max_bits;\n  };\n  this.reduce_side = function (targ_bits, ms_ener_ratio, mean_bits, max_bits) {\n    assert(max_bits <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n    assert(targ_bits[0] + targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n\n    /*\n     * ms_ener_ratio = 0: allocate 66/33 mid/side fac=.33 ms_ener_ratio =.5:\n     * allocate 50/50 mid/side fac= 0\n     */\n    /* 75/25 split is fac=.5 */\n    var fac = .33 * (.5 - ms_ener_ratio) / .5;\n    if (fac < 0) fac = 0;\n    if (fac > .5) fac = .5;\n\n    /* number of bits to move from side channel to mid channel */\n    /* move_bits = fac*targ_bits[1]; */\n    var move_bits = 0 | fac * .5 * (targ_bits[0] + targ_bits[1]);\n    if (move_bits > LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[0]) {\n      move_bits = LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[0];\n    }\n    if (move_bits < 0) move_bits = 0;\n    if (targ_bits[1] >= 125) {\n      /* dont reduce side channel below 125 bits */\n      if (targ_bits[1] - move_bits > 125) {\n        /* if mid channel already has 2x more than average, dont bother */\n        /* mean_bits = bits per granule (for both channels) */\n        if (targ_bits[0] < mean_bits) targ_bits[0] += move_bits;\n        targ_bits[1] -= move_bits;\n      } else {\n        targ_bits[0] += targ_bits[1] - 125;\n        targ_bits[1] = 125;\n      }\n    }\n    move_bits = targ_bits[0] + targ_bits[1];\n    if (move_bits > max_bits) {\n      targ_bits[0] = max_bits * targ_bits[0] / move_bits;\n      targ_bits[1] = max_bits * targ_bits[1] / move_bits;\n    }\n    assert(targ_bits[0] <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n    assert(targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n    assert(targ_bits[0] + targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n  };\n\n  /**\n   *  Robert Hegemann 2001-04-27:\n   *  this adjusts the ATH, keeping the original noise floor\n   *  affects the higher frequencies more than the lower ones\n   */\n  this.athAdjust = function (a, x, athFloor) {\n    /*\n     * work in progress\n     */\n    var o = 90.30873362;\n    var p = 94.82444863;\n    var u = Util.FAST_LOG10_X(x, 10.0);\n    var v = a * a;\n    var w = 0.0;\n    u -= athFloor;\n    /* undo scaling */\n    if (v > 1E-20) w = 1. + Util.FAST_LOG10_X(v, 10.0 / o);\n    if (w < 0) w = 0.;\n    u *= w;\n    u += athFloor + o - p;\n    /* redo scaling */\n\n    return Math.pow(10., 0.1 * u);\n  };\n\n  /**\n   * Calculate the allowed distortion for each scalefactor band, as determined\n   * by the psychoacoustic model. xmin(sb) = ratio(sb) * en(sb) / bw(sb)\n   *\n   * returns number of sfb's with energy > ATH\n   */\n  this.calc_xmin = function (gfp, ratio, cod_info, pxmin) {\n    var pxminPos = 0;\n    var gfc = gfp.internal_flags;\n    var gsfb,\n      j = 0,\n      ath_over = 0;\n    var ATH = gfc.ATH;\n    var xr = cod_info.xr;\n    var enable_athaa_fix = gfp.VBR == VbrMode.vbr_mtrh ? 1 : 0;\n    var masking_lower = gfc.masking_lower;\n    if (gfp.VBR == VbrMode.vbr_mtrh || gfp.VBR == VbrMode.vbr_mt) {\n      /* was already done in PSY-Model */\n      masking_lower = 1.0;\n    }\n    for (gsfb = 0; gsfb < cod_info.psy_lmax; gsfb++) {\n      var en0, xmin;\n      var rh1, rh2;\n      var width, l;\n      if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh) xmin = athAdjust(ATH.adjust, ATH.l[gsfb], ATH.floor);else xmin = ATH.adjust * ATH.l[gsfb];\n      width = cod_info.width[gsfb];\n      rh1 = xmin / width;\n      rh2 = DBL_EPSILON;\n      l = width >> 1;\n      en0 = 0.0;\n      do {\n        var xa, xb;\n        xa = xr[j] * xr[j];\n        en0 += xa;\n        rh2 += xa < rh1 ? xa : rh1;\n        j++;\n        xb = xr[j] * xr[j];\n        en0 += xb;\n        rh2 += xb < rh1 ? xb : rh1;\n        j++;\n      } while (--l > 0);\n      if (en0 > xmin) ath_over++;\n      if (gsfb == Encoder.SBPSY_l) {\n        var x = xmin * gfc.nsPsy.longfact[gsfb];\n        if (rh2 < x) {\n          rh2 = x;\n        }\n      }\n      if (enable_athaa_fix != 0) {\n        xmin = rh2;\n      }\n      if (!gfp.ATHonly) {\n        var e = ratio.en.l[gsfb];\n        if (e > 0.0) {\n          var x;\n          x = en0 * ratio.thm.l[gsfb] * masking_lower / e;\n          if (enable_athaa_fix != 0) x *= gfc.nsPsy.longfact[gsfb];\n          if (xmin < x) xmin = x;\n        }\n      }\n      if (enable_athaa_fix != 0) pxmin[pxminPos++] = xmin;else pxmin[pxminPos++] = xmin * gfc.nsPsy.longfact[gsfb];\n    }\n    /* end of long block loop */\n\n    /* use this function to determine the highest non-zero coeff */\n    var max_nonzero = 575;\n    if (cod_info.block_type != Encoder.SHORT_TYPE) {\n      // NORM, START or STOP type, but not SHORT\n      var k = 576;\n      while (k-- != 0 && BitStream.EQ(xr[k], 0)) {\n        max_nonzero = k;\n      }\n    }\n    cod_info.max_nonzero_coeff = max_nonzero;\n    for (var sfb = cod_info.sfb_smin; gsfb < cod_info.psymax; sfb++, gsfb += 3) {\n      var width, b;\n      var tmpATH;\n      if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh) tmpATH = athAdjust(ATH.adjust, ATH.s[sfb], ATH.floor);else tmpATH = ATH.adjust * ATH.s[sfb];\n      width = cod_info.width[gsfb];\n      for (b = 0; b < 3; b++) {\n        var en0 = 0.0,\n          xmin;\n        var rh1, rh2;\n        var l = width >> 1;\n        rh1 = tmpATH / width;\n        rh2 = DBL_EPSILON;\n        do {\n          var xa, xb;\n          xa = xr[j] * xr[j];\n          en0 += xa;\n          rh2 += xa < rh1 ? xa : rh1;\n          j++;\n          xb = xr[j] * xr[j];\n          en0 += xb;\n          rh2 += xb < rh1 ? xb : rh1;\n          j++;\n        } while (--l > 0);\n        if (en0 > tmpATH) ath_over++;\n        if (sfb == Encoder.SBPSY_s) {\n          var x = tmpATH * gfc.nsPsy.shortfact[sfb];\n          if (rh2 < x) {\n            rh2 = x;\n          }\n        }\n        if (enable_athaa_fix != 0) xmin = rh2;else xmin = tmpATH;\n        if (!gfp.ATHonly && !gfp.ATHshort) {\n          var e = ratio.en.s[sfb][b];\n          if (e > 0.0) {\n            var x;\n            x = en0 * ratio.thm.s[sfb][b] * masking_lower / e;\n            if (enable_athaa_fix != 0) x *= gfc.nsPsy.shortfact[sfb];\n            if (xmin < x) xmin = x;\n          }\n        }\n        if (enable_athaa_fix != 0) pxmin[pxminPos++] = xmin;else pxmin[pxminPos++] = xmin * gfc.nsPsy.shortfact[sfb];\n      }\n      /* b */\n      if (gfp.useTemporal) {\n        if (pxmin[pxminPos - 3] > pxmin[pxminPos - 3 + 1]) pxmin[pxminPos - 3 + 1] += (pxmin[pxminPos - 3] - pxmin[pxminPos - 3 + 1]) * gfc.decay;\n        if (pxmin[pxminPos - 3 + 1] > pxmin[pxminPos - 3 + 2]) pxmin[pxminPos - 3 + 2] += (pxmin[pxminPos - 3 + 1] - pxmin[pxminPos - 3 + 2]) * gfc.decay;\n      }\n    }\n    /* end of short block sfb loop */\n\n    return ath_over;\n  };\n  function StartLine(j) {\n    this.s = j;\n  }\n  this.calc_noise_core = function (cod_info, startline, l, step) {\n    var noise = 0;\n    var j = startline.s;\n    var ix = cod_info.l3_enc;\n    if (j > cod_info.count1) {\n      while (l-- != 0) {\n        var temp;\n        temp = cod_info.xr[j];\n        j++;\n        noise += temp * temp;\n        temp = cod_info.xr[j];\n        j++;\n        noise += temp * temp;\n      }\n    } else if (j > cod_info.big_values) {\n      var ix01 = new_float(2);\n      ix01[0] = 0;\n      ix01[1] = step;\n      while (l-- != 0) {\n        var temp;\n        temp = Math.abs(cod_info.xr[j]) - ix01[ix[j]];\n        j++;\n        noise += temp * temp;\n        temp = Math.abs(cod_info.xr[j]) - ix01[ix[j]];\n        j++;\n        noise += temp * temp;\n      }\n    } else {\n      while (l-- != 0) {\n        var temp;\n        temp = Math.abs(cod_info.xr[j]) - pow43[ix[j]] * step;\n        j++;\n        noise += temp * temp;\n        temp = Math.abs(cod_info.xr[j]) - pow43[ix[j]] * step;\n        j++;\n        noise += temp * temp;\n      }\n    }\n    startline.s = j;\n    return noise;\n  };\n\n  /**\n   * <PRE>\n   * -oo dB  =>  -1.00\n   * - 6 dB  =>  -0.97\n   * - 3 dB  =>  -0.80\n   * - 2 dB  =>  -0.64\n   * - 1 dB  =>  -0.38\n   *   0 dB  =>   0.00\n   * + 1 dB  =>  +0.49\n   * + 2 dB  =>  +1.06\n   * + 3 dB  =>  +1.68\n   * + 6 dB  =>  +3.69\n   * +10 dB  =>  +6.45\n   * </PRE>\n   */\n  this.calc_noise = function (cod_info, l3_xmin, distort, res, prev_noise) {\n    var distortPos = 0;\n    var l3_xminPos = 0;\n    var sfb,\n      l,\n      over = 0;\n    var over_noise_db = 0;\n    /* 0 dB relative to masking */\n    var tot_noise_db = 0;\n    /* -200 dB relative to masking */\n    var max_noise = -20.0;\n    var j = 0;\n    var scalefac = cod_info.scalefac;\n    var scalefacPos = 0;\n    res.over_SSD = 0;\n    for (sfb = 0; sfb < cod_info.psymax; sfb++) {\n      var s = cod_info.global_gain - (scalefac[scalefacPos++] + (cod_info.preflag != 0 ? pretab[sfb] : 0) << cod_info.scalefac_scale + 1) - cod_info.subblock_gain[cod_info.window[sfb]] * 8;\n      var noise = 0.0;\n      if (prev_noise != null && prev_noise.step[sfb] == s) {\n        /* use previously computed values */\n        noise = prev_noise.noise[sfb];\n        j += cod_info.width[sfb];\n        distort[distortPos++] = noise / l3_xmin[l3_xminPos++];\n        noise = prev_noise.noise_log[sfb];\n      } else {\n        var step = POW20(s);\n        l = cod_info.width[sfb] >> 1;\n        if (j + cod_info.width[sfb] > cod_info.max_nonzero_coeff) {\n          var usefullsize;\n          usefullsize = cod_info.max_nonzero_coeff - j + 1;\n          if (usefullsize > 0) l = usefullsize >> 1;else l = 0;\n        }\n        var sl = new StartLine(j);\n        noise = this.calc_noise_core(cod_info, sl, l, step);\n        j = sl.s;\n        if (prev_noise != null) {\n          /* save noise values */\n          prev_noise.step[sfb] = s;\n          prev_noise.noise[sfb] = noise;\n        }\n        noise = distort[distortPos++] = noise / l3_xmin[l3_xminPos++];\n\n        /* multiplying here is adding in dB, but can overflow */\n        noise = Util.FAST_LOG10(Math.max(noise, 1E-20));\n        if (prev_noise != null) {\n          /* save noise values */\n          prev_noise.noise_log[sfb] = noise;\n        }\n      }\n      if (prev_noise != null) {\n        /* save noise values */\n        prev_noise.global_gain = cod_info.global_gain;\n      }\n      tot_noise_db += noise;\n      if (noise > 0.0) {\n        var tmp;\n        tmp = Math.max(0 | noise * 10 + .5, 1);\n        res.over_SSD += tmp * tmp;\n        over++;\n        /* multiplying here is adding in dB -but can overflow */\n        /* over_noise *= noise; */\n        over_noise_db += noise;\n      }\n      max_noise = Math.max(max_noise, noise);\n    }\n    res.over_count = over;\n    res.tot_noise = tot_noise_db;\n    res.over_noise = over_noise_db;\n    res.max_noise = max_noise;\n    return over;\n  };\n\n  /**\n   * updates plotting data\n   *\n   * Mark Taylor 2000-??-??\n   *\n   * Robert Hegemann: moved noise/distortion calc into it\n   */\n  this.set_pinfo = function (gfp, cod_info, ratio, gr, ch) {\n    var gfc = gfp.internal_flags;\n    var sfb, sfb2;\n    var l;\n    var en0, en1;\n    var ifqstep = cod_info.scalefac_scale == 0 ? .5 : 1.0;\n    var scalefac = cod_info.scalefac;\n    var l3_xmin = new_float(L3Side.SFBMAX);\n    var xfsf = new_float(L3Side.SFBMAX);\n    var noise = new CalcNoiseResult();\n    calc_xmin(gfp, ratio, cod_info, l3_xmin);\n    calc_noise(cod_info, l3_xmin, xfsf, noise, null);\n    var j = 0;\n    sfb2 = cod_info.sfb_lmax;\n    if (cod_info.block_type != Encoder.SHORT_TYPE && 0 == cod_info.mixed_block_flag) sfb2 = 22;\n    for (sfb = 0; sfb < sfb2; sfb++) {\n      var start = gfc.scalefac_band.l[sfb];\n      var end = gfc.scalefac_band.l[sfb + 1];\n      var bw = end - start;\n      for (en0 = 0.0; j < end; j++) en0 += cod_info.xr[j] * cod_info.xr[j];\n      en0 /= bw;\n      /* convert to MDCT units */\n      /* scaling so it shows up on FFT plot */\n      en1 = 1e15;\n      gfc.pinfo.en[gr][ch][sfb] = en1 * en0;\n      gfc.pinfo.xfsf[gr][ch][sfb] = en1 * l3_xmin[sfb] * xfsf[sfb] / bw;\n      if (ratio.en.l[sfb] > 0 && !gfp.ATHonly) en0 = en0 / ratio.en.l[sfb];else en0 = 0.0;\n      gfc.pinfo.thr[gr][ch][sfb] = en1 * Math.max(en0 * ratio.thm.l[sfb], gfc.ATH.l[sfb]);\n\n      /* there is no scalefactor bands >= SBPSY_l */\n      gfc.pinfo.LAMEsfb[gr][ch][sfb] = 0;\n      if (cod_info.preflag != 0 && sfb >= 11) gfc.pinfo.LAMEsfb[gr][ch][sfb] = -ifqstep * pretab[sfb];\n      if (sfb < Encoder.SBPSY_l) {\n        /* scfsi should be decoded by caller side */\n        assert(scalefac[sfb] >= 0);\n        gfc.pinfo.LAMEsfb[gr][ch][sfb] -= ifqstep * scalefac[sfb];\n      }\n    }\n    /* for sfb */\n\n    if (cod_info.block_type == Encoder.SHORT_TYPE) {\n      sfb2 = sfb;\n      for (sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n        var start = gfc.scalefac_band.s[sfb];\n        var end = gfc.scalefac_band.s[sfb + 1];\n        var bw = end - start;\n        for (var i = 0; i < 3; i++) {\n          for (en0 = 0.0, l = start; l < end; l++) {\n            en0 += cod_info.xr[j] * cod_info.xr[j];\n            j++;\n          }\n          en0 = Math.max(en0 / bw, 1e-20);\n          /* convert to MDCT units */\n          /* scaling so it shows up on FFT plot */\n          en1 = 1e15;\n          gfc.pinfo.en_s[gr][ch][3 * sfb + i] = en1 * en0;\n          gfc.pinfo.xfsf_s[gr][ch][3 * sfb + i] = en1 * l3_xmin[sfb2] * xfsf[sfb2] / bw;\n          if (ratio.en.s[sfb][i] > 0) en0 = en0 / ratio.en.s[sfb][i];else en0 = 0.0;\n          if (gfp.ATHonly || gfp.ATHshort) en0 = 0;\n          gfc.pinfo.thr_s[gr][ch][3 * sfb + i] = en1 * Math.max(en0 * ratio.thm.s[sfb][i], gfc.ATH.s[sfb]);\n\n          /* there is no scalefactor bands >= SBPSY_s */\n          gfc.pinfo.LAMEsfb_s[gr][ch][3 * sfb + i] = -2.0 * cod_info.subblock_gain[i];\n          if (sfb < Encoder.SBPSY_s) {\n            gfc.pinfo.LAMEsfb_s[gr][ch][3 * sfb + i] -= ifqstep * scalefac[sfb2];\n          }\n          sfb2++;\n        }\n      }\n    }\n    /* block type short */\n    gfc.pinfo.LAMEqss[gr][ch] = cod_info.global_gain;\n    gfc.pinfo.LAMEmainbits[gr][ch] = cod_info.part2_3_length + cod_info.part2_length;\n    gfc.pinfo.LAMEsfbits[gr][ch] = cod_info.part2_length;\n    gfc.pinfo.over[gr][ch] = noise.over_count;\n    gfc.pinfo.max_noise[gr][ch] = noise.max_noise * 10.0;\n    gfc.pinfo.over_noise[gr][ch] = noise.over_noise * 10.0;\n    gfc.pinfo.tot_noise[gr][ch] = noise.tot_noise * 10.0;\n    gfc.pinfo.over_SSD[gr][ch] = noise.over_SSD;\n  };\n\n  /**\n   * updates plotting data for a whole frame\n   *\n   * Robert Hegemann 2000-10-21\n   */\n  function set_frame_pinfo(gfp, ratio) {\n    var gfc = gfp.internal_flags;\n    gfc.masking_lower = 1.0;\n\n    /*\n     * for every granule and channel patch l3_enc and set info\n     */\n    for (var gr = 0; gr < gfc.mode_gr; gr++) {\n      for (var ch = 0; ch < gfc.channels_out; ch++) {\n        var cod_info = gfc.l3_side.tt[gr][ch];\n        var scalefac_sav = new_int(L3Side.SFBMAX);\n        System.arraycopy(cod_info.scalefac, 0, scalefac_sav, 0, scalefac_sav.length);\n\n        /*\n         * reconstruct the scalefactors in case SCFSI was used\n         */\n        if (gr == 1) {\n          var sfb;\n          for (sfb = 0; sfb < cod_info.sfb_lmax; sfb++) {\n            if (cod_info.scalefac[sfb] < 0) /* scfsi */\n              cod_info.scalefac[sfb] = gfc.l3_side.tt[0][ch].scalefac[sfb];\n          }\n        }\n        set_pinfo(gfp, cod_info, ratio[gr][ch], gr, ch);\n        System.arraycopy(scalefac_sav, 0, cod_info.scalefac, 0, scalefac_sav.length);\n      }\n      /* for ch */\n    }\n    /* for gr */\n  }\n}\nmodule.exports = QuantizePVT;","map":{"version":3,"names":["ScaleFac","require","common","System","VbrMode","Float","ShortBlock","Util","Arrays","new_array_n","new_byte","new_double","new_float","new_float_n","new_int","new_int_n","assert","Encoder","MeanBits","LameInternalFlags","QuantizePVT","Q_MAX","Q_MAX2","LARGE_BITS","IXMAX_VAL","tak","rv","psy","setModules","_tk","_rv","_psy","POW20","x","pow20","IPOW20","ipow20","DBL_EPSILON","PRECALC_SIZE","NSATHSCALE","nr_of_sfb_block","pretab","sfBandIndex","pow43","adj43","ATHmdct","gfp","f","ath","ATHformula","Math","pow","ATHlower","compute_ath","ATH_l","internal_flags","ATH","l","ATH_psfb21","psfb21","ATH_s","s","ATH_psfb12","psfb12","gfc","samp_freq","out_samplerate","sfb","SBMAX_l","start","scalefac_band","end","MAX_VALUE","i","freq","ATH_f","min","PSFB21","SBMAX_s","PSFB12","noATH","floor","log10","iteration_init","l3_side","iteration_init_init","main_data_begin","huffman_init","bass","alto","treble","sfb21","exp_nspsytune","nsPsy","longfact","shortfact","on_pe","pe","targ_bits","mean_bits","gr","cbr","tbits","bits","add_bits","ch","mb","extra_bits","ResvMaxBits","max_bits","MAX_BITS_PER_GRANULE","channels_out","MAX_BITS_PER_CHANNEL","max","sum","reduce_side","ms_ener_ratio","fac","move_bits","athAdjust","a","athFloor","o","p","u","FAST_LOG10_X","v","w","calc_xmin","ratio","cod_info","pxmin","pxminPos","gsfb","j","ath_over","xr","enable_athaa_fix","VBR","vbr_mtrh","masking_lower","vbr_mt","psy_lmax","en0","xmin","rh1","rh2","width","vbr_rh","adjust","xa","xb","SBPSY_l","ATHonly","e","en","thm","max_nonzero","block_type","SHORT_TYPE","k","BitStream","EQ","max_nonzero_coeff","sfb_smin","psymax","b","tmpATH","SBPSY_s","ATHshort","useTemporal","decay","StartLine","calc_noise_core","startline","step","noise","ix","l3_enc","count1","temp","big_values","ix01","abs","calc_noise","l3_xmin","distort","res","prev_noise","distortPos","l3_xminPos","over","over_noise_db","tot_noise_db","max_noise","scalefac","scalefacPos","over_SSD","global_gain","preflag","scalefac_scale","subblock_gain","window","noise_log","usefullsize","sl","FAST_LOG10","tmp","over_count","tot_noise","over_noise","set_pinfo","sfb2","en1","ifqstep","L3Side","SFBMAX","xfsf","CalcNoiseResult","sfb_lmax","mixed_block_flag","bw","pinfo","thr","LAMEsfb","en_s","xfsf_s","thr_s","LAMEsfb_s","LAMEqss","LAMEmainbits","part2_3_length","part2_length","LAMEsfbits","set_frame_pinfo","mode_gr","tt","scalefac_sav","arraycopy","length","module","exports"],"sources":["D:/代码/vscodeProjects/AiEducation/vue_aieducation/node_modules/lamejs/src/js/QuantizePVT.js"],"sourcesContent":["/*\n *      quantize_pvt source file\n *\n *      Copyright (c) 1999-2002 Takehiro Tominaga\n *      Copyright (c) 2000-2002 Robert Hegemann\n *      Copyright (c) 2001 Naoki Shibata\n *      Copyright (c) 2002-2005 Gabriel Bouvigne\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Library General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the\n * Free Software Foundation, Inc., 59 Temple Place - Suite 330,\n * Boston, MA 02111-1307, USA.\n */\n\n/* $Id: QuantizePVT.java,v 1.24 2011/05/24 20:48:06 kenchis Exp $ */\nvar ScaleFac = require('./ScaleFac.js');\nvar common = require('./common.js');\nvar System = common.System;\nvar VbrMode = common.VbrMode;\nvar Float = common.Float;\nvar ShortBlock = common.ShortBlock;\nvar Util = common.Util;\nvar Arrays = common.Arrays;\nvar new_array_n = common.new_array_n;\nvar new_byte = common.new_byte;\nvar new_double = common.new_double;\nvar new_float = common.new_float;\nvar new_float_n = common.new_float_n;\nvar new_int = common.new_int;\nvar new_int_n = common.new_int_n;\nvar assert = common.assert;\n\nvar Encoder = require('./Encoder.js');\nvar MeanBits = require('./MeanBits.js');\nvar LameInternalFlags = require('./LameInternalFlags.js');\n\nQuantizePVT.Q_MAX = (256 + 1);\nQuantizePVT.Q_MAX2 = 116;\nQuantizePVT.LARGE_BITS = 100000;\nQuantizePVT.IXMAX_VAL = 8206;\n\nfunction QuantizePVT() {\n\n    var tak = null;\n    var rv = null;\n    var psy = null;\n\n    this.setModules = function (_tk, _rv, _psy) {\n        tak = _tk;\n        rv = _rv;\n        psy = _psy;\n    };\n\n    function POW20(x) {\n        assert(0 <= (x + QuantizePVT.Q_MAX2) && x < QuantizePVT.Q_MAX);\n        return pow20[x + QuantizePVT.Q_MAX2];\n    }\n\n    this.IPOW20 = function (x) {\n        assert(0 <= x && x < QuantizePVT.Q_MAX);\n        return ipow20[x];\n    }\n\n    /**\n     * smallest such that 1.0+DBL_EPSILON != 1.0\n     */\n    var DBL_EPSILON = 2.2204460492503131e-016;\n\n    /**\n     * ix always <= 8191+15. see count_bits()\n     */\n    var IXMAX_VAL = QuantizePVT.IXMAX_VAL;\n\n    var PRECALC_SIZE = (IXMAX_VAL + 2);\n\n    var Q_MAX = QuantizePVT.Q_MAX;\n\n\n    /**\n     * <CODE>\n     * minimum possible number of\n     * -cod_info.global_gain + ((scalefac[] + (cod_info.preflag ? pretab[sfb] : 0))\n     * << (cod_info.scalefac_scale + 1)) + cod_info.subblock_gain[cod_info.window[sfb]] * 8;\n     *\n     * for long block, 0+((15+3)<<2) = 18*4 = 72\n     * for short block, 0+(15<<2)+7*8 = 15*4+56 = 116\n     * </CODE>\n     */\n    var Q_MAX2 = QuantizePVT.Q_MAX2;\n\n    var LARGE_BITS = QuantizePVT.LARGE_BITS;\n\n\n    /**\n     * Assuming dynamic range=96dB, this value should be 92\n     */\n    var NSATHSCALE = 100;\n\n    /**\n     * The following table is used to implement the scalefactor partitioning for\n     * MPEG2 as described in section 2.4.3.2 of the IS. The indexing corresponds\n     * to the way the tables are presented in the IS:\n     *\n     * [table_number][row_in_table][column of nr_of_sfb]\n     */\n    this.nr_of_sfb_block = [\n        [[6, 5, 5, 5], [9, 9, 9, 9], [6, 9, 9, 9]],\n        [[6, 5, 7, 3], [9, 9, 12, 6], [6, 9, 12, 6]],\n        [[11, 10, 0, 0], [18, 18, 0, 0], [15, 18, 0, 0]],\n        [[7, 7, 7, 0], [12, 12, 12, 0], [6, 15, 12, 0]],\n        [[6, 6, 6, 3], [12, 9, 9, 6], [6, 12, 9, 6]],\n        [[8, 8, 5, 0], [15, 12, 9, 0], [6, 18, 9, 0]]];\n\n    /**\n     * Table B.6: layer3 preemphasis\n     */\n    var pretab = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,\n        2, 2, 3, 3, 3, 2, 0];\n    this.pretab = pretab;\n\n    /**\n     * Here are MPEG1 Table B.8 and MPEG2 Table B.1 -- Layer III scalefactor\n     * bands. <BR>\n     * Index into this using a method such as:<BR>\n     * idx = fr_ps.header.sampling_frequency + (fr_ps.header.version * 3)\n     */\n    this.sfBandIndex = [\n        // Table B.2.b: 22.05 kHz\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464,\n                522, 576],\n            [0, 4, 8, 12, 18, 24, 32, 42, 56, 74, 100, 132, 174, 192]\n            , [0, 0, 0, 0, 0, 0, 0] //  sfb21 pseudo sub bands\n            , [0, 0, 0, 0, 0, 0, 0] //  sfb12 pseudo sub bands\n        ),\n        /* Table B.2.c: 24 kHz */ /* docs: 332. mpg123(broken): 330 */\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 114, 136, 162, 194, 232, 278, 332, 394, 464,\n                540, 576],\n            [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 136, 180, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* Table B.2.a: 16 kHz */\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464,\n                522, 576],\n            [0, 4, 8, 12, 18, 26, 36, 48, 62, 80, 104, 134, 174, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* Table B.8.b: 44.1 kHz */\n        new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 52, 62, 74, 90, 110, 134, 162, 196, 238, 288, 342, 418,\n                576],\n            [0, 4, 8, 12, 16, 22, 30, 40, 52, 66, 84, 106, 136, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* Table B.8.c: 48 kHz */\n        new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 42, 50, 60, 72, 88, 106, 128, 156, 190, 230, 276, 330, 384,\n                576],\n            [0, 4, 8, 12, 16, 22, 28, 38, 50, 64, 80, 100, 126, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* Table B.8.a: 32 kHz */\n        new ScaleFac([0, 4, 8, 12, 16, 20, 24, 30, 36, 44, 54, 66, 82, 102, 126, 156, 194, 240, 296, 364, 448, 550,\n                576],\n            [0, 4, 8, 12, 16, 22, 30, 42, 58, 78, 104, 138, 180, 192]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* MPEG-2.5 11.025 kHz */\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464,\n                522, 576],\n            [0 / 3, 12 / 3, 24 / 3, 36 / 3, 54 / 3, 78 / 3, 108 / 3, 144 / 3, 186 / 3, 240 / 3, 312 / 3,\n                402 / 3, 522 / 3, 576 / 3]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* MPEG-2.5 12 kHz */\n        new ScaleFac([0, 6, 12, 18, 24, 30, 36, 44, 54, 66, 80, 96, 116, 140, 168, 200, 238, 284, 336, 396, 464,\n                522, 576],\n            [0 / 3, 12 / 3, 24 / 3, 36 / 3, 54 / 3, 78 / 3, 108 / 3, 144 / 3, 186 / 3, 240 / 3, 312 / 3,\n                402 / 3, 522 / 3, 576 / 3]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        ),\n        /* MPEG-2.5 8 kHz */\n        new ScaleFac([0, 12, 24, 36, 48, 60, 72, 88, 108, 132, 160, 192, 232, 280, 336, 400, 476, 566, 568, 570,\n                572, 574, 576],\n            [0 / 3, 24 / 3, 48 / 3, 72 / 3, 108 / 3, 156 / 3, 216 / 3, 288 / 3, 372 / 3, 480 / 3, 486 / 3,\n                492 / 3, 498 / 3, 576 / 3]\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb21 pseudo sub bands */\n            , [0, 0, 0, 0, 0, 0, 0] /*  sfb12 pseudo sub bands */\n        )\n    ];\n\n    var pow20 = new_float(Q_MAX + Q_MAX2 + 1);\n    var ipow20 = new_float(Q_MAX);\n    var pow43 = new_float(PRECALC_SIZE);\n\n    var adj43 = new_float(PRECALC_SIZE);\n    this.adj43 = adj43;\n\n    /**\n     * <PRE>\n     * compute the ATH for each scalefactor band cd range: 0..96db\n     *\n     * Input: 3.3kHz signal 32767 amplitude (3.3kHz is where ATH is smallest =\n     * -5db) longblocks: sfb=12 en0/bw=-11db max_en0 = 1.3db shortblocks: sfb=5\n     * -9db 0db\n     *\n     * Input: 1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated) longblocks: amp=1\n     * sfb=12 en0/bw=-103 db max_en0 = -92db amp=32767 sfb=12 -12 db -1.4db\n     *\n     * Input: 1 1 1 1 1 1 1 -1 -1 -1 -1 -1 -1 -1 (repeated) shortblocks: amp=1\n     * sfb=5 en0/bw= -99 -86 amp=32767 sfb=5 -9 db 4db\n     *\n     *\n     * MAX energy of largest wave at 3.3kHz = 1db AVE energy of largest wave at\n     * 3.3kHz = -11db Let's take AVE: -11db = maximum signal in sfb=12. Dynamic\n     * range of CD: 96db. Therefor energy of smallest audible wave in sfb=12 =\n     * -11 - 96 = -107db = ATH at 3.3kHz.\n     *\n     * ATH formula for this wave: -5db. To adjust to LAME scaling, we need ATH =\n     * ATH_formula - 103 (db) ATH = ATH * 2.5e-10 (ener)\n     * </PRE>\n     */\n    function ATHmdct(gfp, f) {\n        var ath = psy.ATHformula(f, gfp);\n\n        ath -= NSATHSCALE;\n\n        /* modify the MDCT scaling for the ATH and convert to energy */\n        ath = Math.pow(10.0, ath / 10.0 + gfp.ATHlower);\n        return ath;\n    }\n\n    function compute_ath(gfp) {\n        var ATH_l = gfp.internal_flags.ATH.l;\n        var ATH_psfb21 = gfp.internal_flags.ATH.psfb21;\n        var ATH_s = gfp.internal_flags.ATH.s;\n        var ATH_psfb12 = gfp.internal_flags.ATH.psfb12;\n        var gfc = gfp.internal_flags;\n        var samp_freq = gfp.out_samplerate;\n\n        for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n            var start = gfc.scalefac_band.l[sfb];\n            var end = gfc.scalefac_band.l[sfb + 1];\n            ATH_l[sfb] = Float.MAX_VALUE;\n            for (var i = start; i < end; i++) {\n                var freq = i * samp_freq / (2 * 576);\n                var ATH_f = ATHmdct(gfp, freq);\n                /* freq in kHz */\n                ATH_l[sfb] = Math.min(ATH_l[sfb], ATH_f);\n            }\n        }\n\n        for (var sfb = 0; sfb < Encoder.PSFB21; sfb++) {\n            var start = gfc.scalefac_band.psfb21[sfb];\n            var end = gfc.scalefac_band.psfb21[sfb + 1];\n            ATH_psfb21[sfb] = Float.MAX_VALUE;\n            for (var i = start; i < end; i++) {\n                var freq = i * samp_freq / (2 * 576);\n                var ATH_f = ATHmdct(gfp, freq);\n                /* freq in kHz */\n                ATH_psfb21[sfb] = Math.min(ATH_psfb21[sfb], ATH_f);\n            }\n        }\n\n        for (var sfb = 0; sfb < Encoder.SBMAX_s; sfb++) {\n            var start = gfc.scalefac_band.s[sfb];\n            var end = gfc.scalefac_band.s[sfb + 1];\n            ATH_s[sfb] = Float.MAX_VALUE;\n            for (var i = start; i < end; i++) {\n                var freq = i * samp_freq / (2 * 192);\n                var ATH_f = ATHmdct(gfp, freq);\n                /* freq in kHz */\n                ATH_s[sfb] = Math.min(ATH_s[sfb], ATH_f);\n            }\n            ATH_s[sfb] *= (gfc.scalefac_band.s[sfb + 1] - gfc.scalefac_band.s[sfb]);\n        }\n\n        for (var sfb = 0; sfb < Encoder.PSFB12; sfb++) {\n            var start = gfc.scalefac_band.psfb12[sfb];\n            var end = gfc.scalefac_band.psfb12[sfb + 1];\n            ATH_psfb12[sfb] = Float.MAX_VALUE;\n            for (var i = start; i < end; i++) {\n                var freq = i * samp_freq / (2 * 192);\n                var ATH_f = ATHmdct(gfp, freq);\n                /* freq in kHz */\n                ATH_psfb12[sfb] = Math.min(ATH_psfb12[sfb], ATH_f);\n            }\n            /* not sure about the following */\n            ATH_psfb12[sfb] *= (gfc.scalefac_band.s[13] - gfc.scalefac_band.s[12]);\n        }\n\n        /*\n         * no-ATH mode: reduce ATH to -200 dB\n         */\n        if (gfp.noATH) {\n            for (var sfb = 0; sfb < Encoder.SBMAX_l; sfb++) {\n                ATH_l[sfb] = 1E-20;\n            }\n            for (var sfb = 0; sfb < Encoder.PSFB21; sfb++) {\n                ATH_psfb21[sfb] = 1E-20;\n            }\n            for (var sfb = 0; sfb < Encoder.SBMAX_s; sfb++) {\n                ATH_s[sfb] = 1E-20;\n            }\n            for (var sfb = 0; sfb < Encoder.PSFB12; sfb++) {\n                ATH_psfb12[sfb] = 1E-20;\n            }\n        }\n\n        /*\n         * work in progress, don't rely on it too much\n         */\n        gfc.ATH.floor = 10. * Math.log10(ATHmdct(gfp, -1.));\n    }\n\n    /**\n     * initialization for iteration_loop\n     */\n    this.iteration_init = function (gfp) {\n        var gfc = gfp.internal_flags;\n        var l3_side = gfc.l3_side;\n        var i;\n\n        if (gfc.iteration_init_init == 0) {\n            gfc.iteration_init_init = 1;\n\n            l3_side.main_data_begin = 0;\n            compute_ath(gfp);\n\n            pow43[0] = 0.0;\n            for (i = 1; i < PRECALC_SIZE; i++)\n                pow43[i] = Math.pow(i, 4.0 / 3.0);\n\n            for (i = 0; i < PRECALC_SIZE - 1; i++)\n                adj43[i] = ((i + 1) - Math.pow(\n                    0.5 * (pow43[i] + pow43[i + 1]), 0.75));\n            adj43[i] = 0.5;\n\n            for (i = 0; i < Q_MAX; i++)\n                ipow20[i] = Math.pow(2.0, (i - 210) * -0.1875);\n            for (i = 0; i <= Q_MAX + Q_MAX2; i++)\n                pow20[i] = Math.pow(2.0, (i - 210 - Q_MAX2) * 0.25);\n\n            tak.huffman_init(gfc);\n\n            {\n                var bass, alto, treble, sfb21;\n\n                i = (gfp.exp_nspsytune >> 2) & 63;\n                if (i >= 32)\n                    i -= 64;\n                bass = Math.pow(10, i / 4.0 / 10.0);\n\n                i = (gfp.exp_nspsytune >> 8) & 63;\n                if (i >= 32)\n                    i -= 64;\n                alto = Math.pow(10, i / 4.0 / 10.0);\n\n                i = (gfp.exp_nspsytune >> 14) & 63;\n                if (i >= 32)\n                    i -= 64;\n                treble = Math.pow(10, i / 4.0 / 10.0);\n\n                /*\n                 * to be compatible with Naoki's original code, the next 6 bits\n                 * define only the amount of changing treble for sfb21\n                 */\n                i = (gfp.exp_nspsytune >> 20) & 63;\n                if (i >= 32)\n                    i -= 64;\n                sfb21 = treble * Math.pow(10, i / 4.0 / 10.0);\n                for (i = 0; i < Encoder.SBMAX_l; i++) {\n                    var f;\n                    if (i <= 6)\n                        f = bass;\n                    else if (i <= 13)\n                        f = alto;\n                    else if (i <= 20)\n                        f = treble;\n                    else\n                        f = sfb21;\n\n                    gfc.nsPsy.longfact[i] = f;\n                }\n                for (i = 0; i < Encoder.SBMAX_s; i++) {\n                    var f;\n                    if (i <= 5)\n                        f = bass;\n                    else if (i <= 10)\n                        f = alto;\n                    else if (i <= 11)\n                        f = treble;\n                    else\n                        f = sfb21;\n\n                    gfc.nsPsy.shortfact[i] = f;\n                }\n            }\n        }\n    }\n\n    /**\n     * allocate bits among 2 channels based on PE<BR>\n     * mt 6/99<BR>\n     * bugfixes rh 8/01: often allocated more than the allowed 4095 bits\n     */\n    this.on_pe = function (gfp, pe,\n                           targ_bits, mean_bits, gr, cbr) {\n        var gfc = gfp.internal_flags;\n        var tbits = 0, bits;\n        var add_bits = new_int(2);\n        var ch;\n\n        /* allocate targ_bits for granule */\n        var mb = new MeanBits(tbits);\n        var extra_bits = rv.ResvMaxBits(gfp, mean_bits, mb, cbr);\n        tbits = mb.bits;\n        /* maximum allowed bits for this granule */\n        var max_bits = tbits + extra_bits;\n        if (max_bits > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n            // hard limit per granule\n            max_bits = LameInternalFlags.MAX_BITS_PER_GRANULE;\n        }\n        for (bits = 0, ch = 0; ch < gfc.channels_out; ++ch) {\n            /******************************************************************\n             * allocate bits for each channel\n             ******************************************************************/\n            targ_bits[ch] = Math.min(LameInternalFlags.MAX_BITS_PER_CHANNEL,\n                tbits / gfc.channels_out);\n\n            add_bits[ch] = 0 | (targ_bits[ch] * pe[gr][ch] / 700.0 - targ_bits[ch]);\n\n            /* at most increase bits by 1.5*average */\n            if (add_bits[ch] > mean_bits * 3 / 4)\n                add_bits[ch] = mean_bits * 3 / 4;\n            if (add_bits[ch] < 0)\n                add_bits[ch] = 0;\n\n            if (add_bits[ch] + targ_bits[ch] > LameInternalFlags.MAX_BITS_PER_CHANNEL)\n                add_bits[ch] = Math.max(0,\n                    LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[ch]);\n\n            bits += add_bits[ch];\n        }\n        if (bits > extra_bits) {\n            for (ch = 0; ch < gfc.channels_out; ++ch) {\n                add_bits[ch] = extra_bits * add_bits[ch] / bits;\n            }\n        }\n\n        for (ch = 0; ch < gfc.channels_out; ++ch) {\n            targ_bits[ch] += add_bits[ch];\n            extra_bits -= add_bits[ch];\n        }\n\n        for (bits = 0, ch = 0; ch < gfc.channels_out; ++ch) {\n            bits += targ_bits[ch];\n        }\n        if (bits > LameInternalFlags.MAX_BITS_PER_GRANULE) {\n            var sum = 0;\n            for (ch = 0; ch < gfc.channels_out; ++ch) {\n                targ_bits[ch] *= LameInternalFlags.MAX_BITS_PER_GRANULE;\n                targ_bits[ch] /= bits;\n                sum += targ_bits[ch];\n            }\n            assert(sum <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n        }\n\n        return max_bits;\n    }\n\n    this.reduce_side = function (targ_bits, ms_ener_ratio, mean_bits, max_bits) {\n        assert(max_bits <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n        assert(targ_bits[0] + targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n\n        /*\n         * ms_ener_ratio = 0: allocate 66/33 mid/side fac=.33 ms_ener_ratio =.5:\n         * allocate 50/50 mid/side fac= 0\n         */\n        /* 75/25 split is fac=.5 */\n        var fac = .33 * (.5 - ms_ener_ratio) / .5;\n        if (fac < 0)\n            fac = 0;\n        if (fac > .5)\n            fac = .5;\n\n        /* number of bits to move from side channel to mid channel */\n        /* move_bits = fac*targ_bits[1]; */\n        var move_bits = 0 | (fac * .5 * (targ_bits[0] + targ_bits[1]));\n\n        if (move_bits > LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[0]) {\n            move_bits = LameInternalFlags.MAX_BITS_PER_CHANNEL - targ_bits[0];\n        }\n        if (move_bits < 0)\n            move_bits = 0;\n\n        if (targ_bits[1] >= 125) {\n            /* dont reduce side channel below 125 bits */\n            if (targ_bits[1] - move_bits > 125) {\n\n                /* if mid channel already has 2x more than average, dont bother */\n                /* mean_bits = bits per granule (for both channels) */\n                if (targ_bits[0] < mean_bits)\n                    targ_bits[0] += move_bits;\n                targ_bits[1] -= move_bits;\n            } else {\n                targ_bits[0] += targ_bits[1] - 125;\n                targ_bits[1] = 125;\n            }\n        }\n\n        move_bits = targ_bits[0] + targ_bits[1];\n        if (move_bits > max_bits) {\n            targ_bits[0] = (max_bits * targ_bits[0]) / move_bits;\n            targ_bits[1] = (max_bits * targ_bits[1]) / move_bits;\n        }\n        assert(targ_bits[0] <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n        assert(targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_CHANNEL);\n        assert(targ_bits[0] + targ_bits[1] <= LameInternalFlags.MAX_BITS_PER_GRANULE);\n    };\n\n    /**\n     *  Robert Hegemann 2001-04-27:\n     *  this adjusts the ATH, keeping the original noise floor\n     *  affects the higher frequencies more than the lower ones\n     */\n    this.athAdjust = function (a, x, athFloor) {\n        /*\n         * work in progress\n         */\n        var o = 90.30873362;\n        var p = 94.82444863;\n        var u = Util.FAST_LOG10_X(x, 10.0);\n        var v = a * a;\n        var w = 0.0;\n        u -= athFloor;\n        /* undo scaling */\n        if (v > 1E-20)\n            w = 1. + Util.FAST_LOG10_X(v, 10.0 / o);\n        if (w < 0)\n            w = 0.;\n        u *= w;\n        u += athFloor + o - p;\n        /* redo scaling */\n\n        return Math.pow(10., 0.1 * u);\n    };\n\n    /**\n     * Calculate the allowed distortion for each scalefactor band, as determined\n     * by the psychoacoustic model. xmin(sb) = ratio(sb) * en(sb) / bw(sb)\n     *\n     * returns number of sfb's with energy > ATH\n     */\n    this.calc_xmin = function (gfp, ratio, cod_info, pxmin) {\n        var pxminPos = 0;\n        var gfc = gfp.internal_flags;\n        var gsfb, j = 0, ath_over = 0;\n        var ATH = gfc.ATH;\n        var xr = cod_info.xr;\n        var enable_athaa_fix = (gfp.VBR == VbrMode.vbr_mtrh) ? 1 : 0;\n        var masking_lower = gfc.masking_lower;\n\n        if (gfp.VBR == VbrMode.vbr_mtrh || gfp.VBR == VbrMode.vbr_mt) {\n            /* was already done in PSY-Model */\n            masking_lower = 1.0;\n        }\n\n        for (gsfb = 0; gsfb < cod_info.psy_lmax; gsfb++) {\n            var en0, xmin;\n            var rh1, rh2;\n            var width, l;\n\n            if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh)\n                xmin = athAdjust(ATH.adjust, ATH.l[gsfb], ATH.floor);\n            else\n                xmin = ATH.adjust * ATH.l[gsfb];\n\n            width = cod_info.width[gsfb];\n            rh1 = xmin / width;\n            rh2 = DBL_EPSILON;\n            l = width >> 1;\n            en0 = 0.0;\n            do {\n                var xa, xb;\n                xa = xr[j] * xr[j];\n                en0 += xa;\n                rh2 += (xa < rh1) ? xa : rh1;\n                j++;\n                xb = xr[j] * xr[j];\n                en0 += xb;\n                rh2 += (xb < rh1) ? xb : rh1;\n                j++;\n            } while (--l > 0);\n            if (en0 > xmin)\n                ath_over++;\n\n            if (gsfb == Encoder.SBPSY_l) {\n                var x = xmin * gfc.nsPsy.longfact[gsfb];\n                if (rh2 < x) {\n                    rh2 = x;\n                }\n            }\n            if (enable_athaa_fix != 0) {\n                xmin = rh2;\n            }\n            if (!gfp.ATHonly) {\n                var e = ratio.en.l[gsfb];\n                if (e > 0.0) {\n                    var x;\n                    x = en0 * ratio.thm.l[gsfb] * masking_lower / e;\n                    if (enable_athaa_fix != 0)\n                        x *= gfc.nsPsy.longfact[gsfb];\n                    if (xmin < x)\n                        xmin = x;\n                }\n            }\n            if (enable_athaa_fix != 0)\n                pxmin[pxminPos++] = xmin;\n            else\n                pxmin[pxminPos++] = xmin * gfc.nsPsy.longfact[gsfb];\n        }\n        /* end of long block loop */\n\n        /* use this function to determine the highest non-zero coeff */\n        var max_nonzero = 575;\n        if (cod_info.block_type != Encoder.SHORT_TYPE) {\n            // NORM, START or STOP type, but not SHORT\n            var k = 576;\n            while (k-- != 0 && BitStream.EQ(xr[k], 0)) {\n                max_nonzero = k;\n            }\n        }\n        cod_info.max_nonzero_coeff = max_nonzero;\n\n        for (var sfb = cod_info.sfb_smin; gsfb < cod_info.psymax; sfb++, gsfb += 3) {\n            var width, b;\n            var tmpATH;\n            if (gfp.VBR == VbrMode.vbr_rh || gfp.VBR == VbrMode.vbr_mtrh)\n                tmpATH = athAdjust(ATH.adjust, ATH.s[sfb], ATH.floor);\n            else\n                tmpATH = ATH.adjust * ATH.s[sfb];\n\n            width = cod_info.width[gsfb];\n            for (b = 0; b < 3; b++) {\n                var en0 = 0.0, xmin;\n                var rh1, rh2;\n                var l = width >> 1;\n\n                rh1 = tmpATH / width;\n                rh2 = DBL_EPSILON;\n                do {\n                    var xa, xb;\n                    xa = xr[j] * xr[j];\n                    en0 += xa;\n                    rh2 += (xa < rh1) ? xa : rh1;\n                    j++;\n                    xb = xr[j] * xr[j];\n                    en0 += xb;\n                    rh2 += (xb < rh1) ? xb : rh1;\n                    j++;\n                } while (--l > 0);\n                if (en0 > tmpATH)\n                    ath_over++;\n                if (sfb == Encoder.SBPSY_s) {\n                    var x = tmpATH * gfc.nsPsy.shortfact[sfb];\n                    if (rh2 < x) {\n                        rh2 = x;\n                    }\n                }\n                if (enable_athaa_fix != 0)\n                    xmin = rh2;\n                else\n                    xmin = tmpATH;\n\n                if (!gfp.ATHonly && !gfp.ATHshort) {\n                    var e = ratio.en.s[sfb][b];\n                    if (e > 0.0) {\n                        var x;\n                        x = en0 * ratio.thm.s[sfb][b] * masking_lower / e;\n                        if (enable_athaa_fix != 0)\n                            x *= gfc.nsPsy.shortfact[sfb];\n                        if (xmin < x)\n                            xmin = x;\n                    }\n                }\n                if (enable_athaa_fix != 0)\n                    pxmin[pxminPos++] = xmin;\n                else\n                    pxmin[pxminPos++] = xmin * gfc.nsPsy.shortfact[sfb];\n            }\n            /* b */\n            if (gfp.useTemporal) {\n                if (pxmin[pxminPos - 3] > pxmin[pxminPos - 3 + 1])\n                    pxmin[pxminPos - 3 + 1] += (pxmin[pxminPos - 3] - pxmin[pxminPos - 3 + 1])\n                        * gfc.decay;\n                if (pxmin[pxminPos - 3 + 1] > pxmin[pxminPos - 3 + 2])\n                    pxmin[pxminPos - 3 + 2] += (pxmin[pxminPos - 3 + 1] - pxmin[pxminPos - 3 + 2])\n                        * gfc.decay;\n            }\n        }\n        /* end of short block sfb loop */\n\n        return ath_over;\n    };\n\n    function StartLine(j) {\n        this.s = j;\n    }\n\n    this.calc_noise_core = function (cod_info, startline, l, step) {\n        var noise = 0;\n        var j = startline.s;\n        var ix = cod_info.l3_enc;\n\n        if (j > cod_info.count1) {\n            while ((l--) != 0) {\n                var temp;\n                temp = cod_info.xr[j];\n                j++;\n                noise += temp * temp;\n                temp = cod_info.xr[j];\n                j++;\n                noise += temp * temp;\n            }\n        } else if (j > cod_info.big_values) {\n            var ix01 = new_float(2);\n            ix01[0] = 0;\n            ix01[1] = step;\n            while ((l--) != 0) {\n                var temp;\n                temp = Math.abs(cod_info.xr[j]) - ix01[ix[j]];\n                j++;\n                noise += temp * temp;\n                temp = Math.abs(cod_info.xr[j]) - ix01[ix[j]];\n                j++;\n                noise += temp * temp;\n            }\n        } else {\n            while ((l--) != 0) {\n                var temp;\n                temp = Math.abs(cod_info.xr[j]) - pow43[ix[j]] * step;\n                j++;\n                noise += temp * temp;\n                temp = Math.abs(cod_info.xr[j]) - pow43[ix[j]] * step;\n                j++;\n                noise += temp * temp;\n            }\n        }\n\n        startline.s = j;\n        return noise;\n    }\n\n    /**\n     * <PRE>\n     * -oo dB  =>  -1.00\n     * - 6 dB  =>  -0.97\n     * - 3 dB  =>  -0.80\n     * - 2 dB  =>  -0.64\n     * - 1 dB  =>  -0.38\n     *   0 dB  =>   0.00\n     * + 1 dB  =>  +0.49\n     * + 2 dB  =>  +1.06\n     * + 3 dB  =>  +1.68\n     * + 6 dB  =>  +3.69\n     * +10 dB  =>  +6.45\n     * </PRE>\n     */\n    this.calc_noise = function (cod_info, l3_xmin, distort, res, prev_noise) {\n        var distortPos = 0;\n        var l3_xminPos = 0;\n        var sfb, l, over = 0;\n        var over_noise_db = 0;\n        /* 0 dB relative to masking */\n        var tot_noise_db = 0;\n        /* -200 dB relative to masking */\n        var max_noise = -20.0;\n        var j = 0;\n        var scalefac = cod_info.scalefac;\n        var scalefacPos = 0;\n\n        res.over_SSD = 0;\n\n        for (sfb = 0; sfb < cod_info.psymax; sfb++) {\n            var s = cod_info.global_gain\n                - (((scalefac[scalefacPos++]) + (cod_info.preflag != 0 ? pretab[sfb]\n                    : 0)) << (cod_info.scalefac_scale + 1))\n                - cod_info.subblock_gain[cod_info.window[sfb]] * 8;\n            var noise = 0.0;\n\n            if (prev_noise != null && (prev_noise.step[sfb] == s)) {\n\n                /* use previously computed values */\n                noise = prev_noise.noise[sfb];\n                j += cod_info.width[sfb];\n                distort[distortPos++] = noise / l3_xmin[l3_xminPos++];\n\n                noise = prev_noise.noise_log[sfb];\n\n            } else {\n                var step = POW20(s);\n                l = cod_info.width[sfb] >> 1;\n\n                if ((j + cod_info.width[sfb]) > cod_info.max_nonzero_coeff) {\n                    var usefullsize;\n                    usefullsize = cod_info.max_nonzero_coeff - j + 1;\n\n                    if (usefullsize > 0)\n                        l = usefullsize >> 1;\n                    else\n                        l = 0;\n                }\n\n                var sl = new StartLine(j);\n                noise = this.calc_noise_core(cod_info, sl, l, step);\n                j = sl.s;\n\n                if (prev_noise != null) {\n                    /* save noise values */\n                    prev_noise.step[sfb] = s;\n                    prev_noise.noise[sfb] = noise;\n                }\n\n                noise = distort[distortPos++] = noise / l3_xmin[l3_xminPos++];\n\n                /* multiplying here is adding in dB, but can overflow */\n                noise = Util.FAST_LOG10(Math.max(noise, 1E-20));\n\n                if (prev_noise != null) {\n                    /* save noise values */\n                    prev_noise.noise_log[sfb] = noise;\n                }\n            }\n\n            if (prev_noise != null) {\n                /* save noise values */\n                prev_noise.global_gain = cod_info.global_gain;\n            }\n\n            tot_noise_db += noise;\n\n            if (noise > 0.0) {\n                var tmp;\n\n                tmp = Math.max(0 | (noise * 10 + .5), 1);\n                res.over_SSD += tmp * tmp;\n\n                over++;\n                /* multiplying here is adding in dB -but can overflow */\n                /* over_noise *= noise; */\n                over_noise_db += noise;\n            }\n            max_noise = Math.max(max_noise, noise);\n\n        }\n\n        res.over_count = over;\n        res.tot_noise = tot_noise_db;\n        res.over_noise = over_noise_db;\n        res.max_noise = max_noise;\n\n        return over;\n    }\n\n    /**\n     * updates plotting data\n     *\n     * Mark Taylor 2000-??-??\n     *\n     * Robert Hegemann: moved noise/distortion calc into it\n     */\n    this.set_pinfo = function (gfp, cod_info, ratio, gr, ch) {\n        var gfc = gfp.internal_flags;\n        var sfb, sfb2;\n        var l;\n        var en0, en1;\n        var ifqstep = (cod_info.scalefac_scale == 0) ? .5 : 1.0;\n        var scalefac = cod_info.scalefac;\n\n        var l3_xmin = new_float(L3Side.SFBMAX);\n        var xfsf = new_float(L3Side.SFBMAX);\n        var noise = new CalcNoiseResult();\n\n        calc_xmin(gfp, ratio, cod_info, l3_xmin);\n        calc_noise(cod_info, l3_xmin, xfsf, noise, null);\n\n        var j = 0;\n        sfb2 = cod_info.sfb_lmax;\n        if (cod_info.block_type != Encoder.SHORT_TYPE\n            && 0 == cod_info.mixed_block_flag)\n            sfb2 = 22;\n        for (sfb = 0; sfb < sfb2; sfb++) {\n            var start = gfc.scalefac_band.l[sfb];\n            var end = gfc.scalefac_band.l[sfb + 1];\n            var bw = end - start;\n            for (en0 = 0.0; j < end; j++)\n                en0 += cod_info.xr[j] * cod_info.xr[j];\n            en0 /= bw;\n            /* convert to MDCT units */\n            /* scaling so it shows up on FFT plot */\n            en1 = 1e15;\n            gfc.pinfo.en[gr][ch][sfb] = en1 * en0;\n            gfc.pinfo.xfsf[gr][ch][sfb] = en1 * l3_xmin[sfb] * xfsf[sfb] / bw;\n\n            if (ratio.en.l[sfb] > 0 && !gfp.ATHonly)\n                en0 = en0 / ratio.en.l[sfb];\n            else\n                en0 = 0.0;\n\n            gfc.pinfo.thr[gr][ch][sfb] = en1\n                * Math.max(en0 * ratio.thm.l[sfb], gfc.ATH.l[sfb]);\n\n            /* there is no scalefactor bands >= SBPSY_l */\n            gfc.pinfo.LAMEsfb[gr][ch][sfb] = 0;\n            if (cod_info.preflag != 0 && sfb >= 11)\n                gfc.pinfo.LAMEsfb[gr][ch][sfb] = -ifqstep * pretab[sfb];\n\n            if (sfb < Encoder.SBPSY_l) {\n                /* scfsi should be decoded by caller side */\n                assert(scalefac[sfb] >= 0);\n                gfc.pinfo.LAMEsfb[gr][ch][sfb] -= ifqstep * scalefac[sfb];\n            }\n        }\n        /* for sfb */\n\n        if (cod_info.block_type == Encoder.SHORT_TYPE) {\n            sfb2 = sfb;\n            for (sfb = cod_info.sfb_smin; sfb < Encoder.SBMAX_s; sfb++) {\n                var start = gfc.scalefac_band.s[sfb];\n                var end = gfc.scalefac_band.s[sfb + 1];\n                var bw = end - start;\n                for (var i = 0; i < 3; i++) {\n                    for (en0 = 0.0, l = start; l < end; l++) {\n                        en0 += cod_info.xr[j] * cod_info.xr[j];\n                        j++;\n                    }\n                    en0 = Math.max(en0 / bw, 1e-20);\n                    /* convert to MDCT units */\n                    /* scaling so it shows up on FFT plot */\n                    en1 = 1e15;\n\n                    gfc.pinfo.en_s[gr][ch][3 * sfb + i] = en1 * en0;\n                    gfc.pinfo.xfsf_s[gr][ch][3 * sfb + i] = en1 * l3_xmin[sfb2]\n                        * xfsf[sfb2] / bw;\n                    if (ratio.en.s[sfb][i] > 0)\n                        en0 = en0 / ratio.en.s[sfb][i];\n                    else\n                        en0 = 0.0;\n                    if (gfp.ATHonly || gfp.ATHshort)\n                        en0 = 0;\n\n                    gfc.pinfo.thr_s[gr][ch][3 * sfb + i] = en1\n                        * Math.max(en0 * ratio.thm.s[sfb][i],\n                            gfc.ATH.s[sfb]);\n\n                    /* there is no scalefactor bands >= SBPSY_s */\n                    gfc.pinfo.LAMEsfb_s[gr][ch][3 * sfb + i] = -2.0\n                        * cod_info.subblock_gain[i];\n                    if (sfb < Encoder.SBPSY_s) {\n                        gfc.pinfo.LAMEsfb_s[gr][ch][3 * sfb + i] -= ifqstep\n                            * scalefac[sfb2];\n                    }\n                    sfb2++;\n                }\n            }\n        }\n        /* block type short */\n        gfc.pinfo.LAMEqss[gr][ch] = cod_info.global_gain;\n        gfc.pinfo.LAMEmainbits[gr][ch] = cod_info.part2_3_length\n            + cod_info.part2_length;\n        gfc.pinfo.LAMEsfbits[gr][ch] = cod_info.part2_length;\n\n        gfc.pinfo.over[gr][ch] = noise.over_count;\n        gfc.pinfo.max_noise[gr][ch] = noise.max_noise * 10.0;\n        gfc.pinfo.over_noise[gr][ch] = noise.over_noise * 10.0;\n        gfc.pinfo.tot_noise[gr][ch] = noise.tot_noise * 10.0;\n        gfc.pinfo.over_SSD[gr][ch] = noise.over_SSD;\n    }\n\n    /**\n     * updates plotting data for a whole frame\n     *\n     * Robert Hegemann 2000-10-21\n     */\n    function set_frame_pinfo(gfp, ratio) {\n        var gfc = gfp.internal_flags;\n\n        gfc.masking_lower = 1.0;\n\n        /*\n         * for every granule and channel patch l3_enc and set info\n         */\n        for (var gr = 0; gr < gfc.mode_gr; gr++) {\n            for (var ch = 0; ch < gfc.channels_out; ch++) {\n                var cod_info = gfc.l3_side.tt[gr][ch];\n                var scalefac_sav = new_int(L3Side.SFBMAX);\n                System.arraycopy(cod_info.scalefac, 0, scalefac_sav, 0,\n                    scalefac_sav.length);\n\n                /*\n                 * reconstruct the scalefactors in case SCFSI was used\n                 */\n                if (gr == 1) {\n                    var sfb;\n                    for (sfb = 0; sfb < cod_info.sfb_lmax; sfb++) {\n                        if (cod_info.scalefac[sfb] < 0) /* scfsi */\n                            cod_info.scalefac[sfb] = gfc.l3_side.tt[0][ch].scalefac[sfb];\n                    }\n                }\n\n                set_pinfo(gfp, cod_info, ratio[gr][ch], gr, ch);\n                System.arraycopy(scalefac_sav, 0, cod_info.scalefac, 0,\n                    scalefac_sav.length);\n            }\n            /* for ch */\n        }\n        /* for gr */\n    }\n\n}\n\nmodule.exports = QuantizePVT;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}